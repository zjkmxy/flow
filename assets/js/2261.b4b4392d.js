"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[2261],{42261:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>r,toc:()=>d});var t=a(58168),i=(a(96540),a(15680));a(60681);const l={title:"Type Refinements",slug:"/lang/refinements"},o=void 0,r={unversionedId:"lang/refinements",id:"lang/refinements",title:"Type Refinements",description:"Refinements allow us to narrow the type of a value based on conditional tests.",source:"@site/docs/lang/refinements.md",sourceDirName:"lang",slug:"/lang/refinements",permalink:"/en/docs/lang/refinements",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/lang/refinements.md",tags:[],version:"current",frontMatter:{title:"Type Refinements",slug:"/lang/refinements"},sidebar:"docsSidebar",previous:{title:"Width Subtyping",permalink:"/en/docs/lang/width-subtyping"},next:{title:"Lazy Mode",permalink:"/en/docs/lang/lazy-modes"}},s={},d=[{value:"Ways to refine in Flow",id:"ways-to-refine-in-flow",level:2},{value:"<code>typeof</code> checks",id:"typeof-checks",level:3},{value:"Equality checks",id:"equality-checks",level:3},{value:"Truthiness checks",id:"truthiness-checks",level:3},{value:"<code>instanceof</code> checks",id:"instanceof-checks",level:3},{value:"Assignments",id:"assignments",level:3},{value:"Type Guards",id:"type-guards",level:3},{value:"Refinement Invalidations",id:"toc-refinement-invalidations",level:2}],u={toc:d};function p(e){let{components:n,...a}=e;return(0,i.mdx)("wrapper",(0,t.A)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"Refinements allow us to narrow the type of a value based on conditional tests."),(0,i.mdx)("p",null,"For example, in the function below ",(0,i.mdx)("inlineCode",{parentName:"p"},"value")," is a ",(0,i.mdx)("a",{parentName:"p",href:"../../types/unions"},"union")," of ",(0,i.mdx)("inlineCode",{parentName:"p"},'"A"')," or ",(0,i.mdx)("inlineCode",{parentName:"p"},'"B"'),"."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'function func(value: "A" | "B") {\n  if (value === "A") {\n    value as "A";\n  }\n}\n')),(0,i.mdx)("p",null,"Inside of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"if")," block we know that value must be ",(0,i.mdx)("inlineCode",{parentName:"p"},'"A"')," because that's the only\ntime the if-statement will be true."),(0,i.mdx)("p",null,"The ability for a static type checker to be able to tell that the value inside\nthe if statement must be ",(0,i.mdx)("inlineCode",{parentName:"p"},'"A"')," is known as a refinement."),(0,i.mdx)("p",null,"Next we'll add an ",(0,i.mdx)("inlineCode",{parentName:"p"},"else")," block to our if statement."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'function func(value: "A" | "B") {\n  if (value === "A") {\n    value as "A";\n  } else {\n    value as "B";\n  }\n}\n')),(0,i.mdx)("p",null,"Inside of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"else")," block we know that value must be ",(0,i.mdx)("inlineCode",{parentName:"p"},'"B"')," because it can only\nbe ",(0,i.mdx)("inlineCode",{parentName:"p"},'"A"')," or ",(0,i.mdx)("inlineCode",{parentName:"p"},'"B"')," and we've removed ",(0,i.mdx)("inlineCode",{parentName:"p"},'"A"')," from the possibilities."),(0,i.mdx)("h2",{id:"ways-to-refine-in-flow"},"Ways to refine in Flow"),(0,i.mdx)("h3",{id:"typeof-checks"},(0,i.mdx)("inlineCode",{parentName:"h3"},"typeof")," checks"),(0,i.mdx)("p",null,"You can use a ",(0,i.mdx)("inlineCode",{parentName:"p"},'typeof value === "<type>"')," check to refine a value to one of the categories supported by the ",(0,i.mdx)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof"},(0,i.mdx)("inlineCode",{parentName:"a"},"typeof"))," operator."),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"typeof")," operator can output ",(0,i.mdx)("inlineCode",{parentName:"p"},'"undefined"'),",",(0,i.mdx)("inlineCode",{parentName:"p"},'"boolean"'),", ",(0,i.mdx)("inlineCode",{parentName:"p"},'"number"'),", ",(0,i.mdx)("inlineCode",{parentName:"p"},'"bigint"'),", ",(0,i.mdx)("inlineCode",{parentName:"p"},'"string"'),", ",(0,i.mdx)("inlineCode",{parentName:"p"},'"symbol"'),", ",(0,i.mdx)("inlineCode",{parentName:"p"},'"function"'),", or ",(0,i.mdx)("inlineCode",{parentName:"p"},'"object"'),"."),(0,i.mdx)("p",null,"Keep in mind that the ",(0,i.mdx)("inlineCode",{parentName:"p"},"typeof")," operator will return ",(0,i.mdx)("inlineCode",{parentName:"p"},'"object"')," for objects, but also ",(0,i.mdx)("inlineCode",{parentName:"p"},"null")," and arrays as well."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'function func(value: mixed) {\n  if (typeof value === "string") {\n    value as string;\n  } else if (typeof value === "boolean") {\n    value as boolean;\n  } else if (typeof value === "object") {\n    // `value` could be null, an array, or an object\n    value as null | interface {} | $ReadOnlyArray<mixed>;\n  }\n}\n')),(0,i.mdx)("p",null,"To check for ",(0,i.mdx)("inlineCode",{parentName:"p"},"null"),", use a ",(0,i.mdx)("inlineCode",{parentName:"p"},"value === null")," ",(0,i.mdx)("a",{parentName:"p",href:"#equality-checks"},"equality")," check."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function func(value: mixed) {\n  if (value === null) {\n    value as null; // `value` is null\n  }\n}\n")),(0,i.mdx)("p",null,"To check for ",(0,i.mdx)("a",{parentName:"p",href:"../../types/arrays"},"arrays"),", use ",(0,i.mdx)("inlineCode",{parentName:"p"},"Array.isArray"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function func(value: mixed) {\n  if (Array.isArray(value)) {\n    value as $ReadOnlyArray<mixed>; // `value` is an array\n  }\n}\n")),(0,i.mdx)("h3",{id:"equality-checks"},"Equality checks"),(0,i.mdx)("p",null,"As shown in the introductory example, you can use an equality check to narrow a value to a specific type.\nThis also applies to equality checks made in ",(0,i.mdx)("inlineCode",{parentName:"p"},"switch")," statements."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'function func(value: "A" | "B" | "C") {\n  if (value === "A") {\n    value as "A";\n  } else {\n    value as "B" | "C";\n  }\n\n  switch (value) {\n    case "A":\n      value as "A";\n      break;\n    case "B":\n      value as "B";\n      break;\n    case "C":\n      value as "C";\n      break;\n  }\n}\n')),(0,i.mdx)("p",null,"While in general it is not recommended to use ",(0,i.mdx)("inlineCode",{parentName:"p"},"==")," in JavaScript, due to the coercions it performs,\ndoing ",(0,i.mdx)("inlineCode",{parentName:"p"},"value == null")," (or ",(0,i.mdx)("inlineCode",{parentName:"p"},"value != null"),") checks ",(0,i.mdx)("inlineCode",{parentName:"p"},"value")," exactly for ",(0,i.mdx)("inlineCode",{parentName:"p"},"null")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"void"),".\nThis works well with Flow's ",(0,i.mdx)("a",{parentName:"p",href:"../../types/maybe"},"maybe")," types, which create a union with ",(0,i.mdx)("inlineCode",{parentName:"p"},"null")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"void"),"."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function func(value: ?string) {\n  if (value != null) {\n    value as string;\n  } else {\n    value as null | void;\n  }\n}\n")),(0,i.mdx)("p",null,"You can refine a union of object types based on a common tag, which we call ",(0,i.mdx)("a",{parentName:"p",href:"../../types/unions/#toc-disjoint-object-unions"},"disjoint object unions"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'type A = {type: "A", s: string};\ntype B = {type: "B", n: number};\n\nfunction func(value: A | B) {\n  if (value.type === "A") {\n    // `value` is A\n    value.s as string; // Works\n  } else {\n    // `value` is B\n    value.n as number; // Works\n  }\n}\n')),(0,i.mdx)("h3",{id:"truthiness-checks"},"Truthiness checks"),(0,i.mdx)("p",null,"You can use non-booleans in JavaScript conditionals.\n",(0,i.mdx)("inlineCode",{parentName:"p"},"0"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"NaN"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},'""'),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"null"),", and ",(0,i.mdx)("inlineCode",{parentName:"p"},"undefined")," will all coerce to ",(0,i.mdx)("inlineCode",{parentName:"p"},"false"),' (and so are considered "falsey").\nOther values will coerce to ',(0,i.mdx)("inlineCode",{parentName:"p"},"true"),' (and so are considered "truthy").'),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":5,"startColumn":5,"endLine":5,"endColumn":9,"description":"Cannot cast `value` to union type because string [1] is incompatible with union type [2]. [incompatible-cast]"}]','[{"startLine":5,"startColumn":5,"endLine":5,"endColumn":9,"description":"Cannot':!0,cast:!0,"`value`":!0,to:!0,union:!0,type:!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,"[2].":!0,'[incompatible-cast]"}]':!0},'function func(value: ?string) {\n  if (value) {\n    value as string; // Works\n  } else {\n    value as null | void; // Error! Could still be the empty string ""\n  }\n}\n')),(0,i.mdx)("p",null,"You can see in the above example why doing a truthy check when your value can be a string or number is not suggested:\nit is possible to unintentionally check against the ",(0,i.mdx)("inlineCode",{parentName:"p"},'""')," or ",(0,i.mdx)("inlineCode",{parentName:"p"},"0"),".\nWe created a ",(0,i.mdx)("a",{parentName:"p",href:"../../linting"},"Flow lint")," called ",(0,i.mdx)("a",{parentName:"p",href:"../../linting/rule-reference/#toc-sketchy-null"},"sketchy-null")," to guard against this scenario:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":7,"endLine":3,"endColumn":11,"description":"Sketchy null check on string [1] which is potentially an empty string. Perhaps you meant to check for null or undefined [2]? [sketchy-null-string]"}]','[{"startLine":3,"startColumn":7,"endLine":3,"endColumn":11,"description":"Sketchy':!0,null:!0,check:!0,on:!0,string:!0,"[1]":!0,which:!0,is:!0,potentially:!0,an:!0,empty:!0,"string.":!0,Perhaps:!0,you:!0,meant:!0,to:!0,for:!0,or:!0,undefined:!0,"[2]?":!0,'[sketchy-null-string]"}]':!0},"// flowlint sketchy-null:error\nfunction func(value: ?string) {\n  if (value) { // Error!\n  }\n}\n")),(0,i.mdx)("h3",{id:"instanceof-checks"},(0,i.mdx)("inlineCode",{parentName:"h3"},"instanceof")," checks"),(0,i.mdx)("p",null,"You can use the ",(0,i.mdx)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof"},"instanceof")," operator to narrow a value as well.\nIt checks if the supplied constructor's prototype is anywhere in a value's prototype chain."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":16,"startColumn":11,"endLine":16,"endColumn":15,"description":"Cannot call `value.build` because property `build` is missing in `A` [1]. [prop-missing]"}]','[{"startLine":16,"startColumn":11,"endLine":16,"endColumn":15,"description":"Cannot':!0,call:!0,"`value.build`":!0,because:!0,property:!0,"`build`":!0,is:!0,missing:!0,in:!0,"`A`":!0,"[1].":!0,'[prop-missing]"}]':!0},"class A {\n  amaze(): void {}\n}\nclass B extends A {\n  build(): void {}\n}\n\nfunction func(value: mixed) {\n  if (value instanceof B) {\n    value.amaze(); // Works\n    value.build(); // Works\n  }\n\n  if (value instanceof A) {\n    value.amaze(); // Works\n    value.build(); // Error\n  }\n\n  if (value instanceof Object) {\n    value.toString(); // Works\n  }\n}\n")),(0,i.mdx)("h3",{id:"assignments"},"Assignments"),(0,i.mdx)("p",null,"Flow follows your control flow and narrows the type of a variable after you have assigned to it."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'declare const b: boolean;\n\nlet x: ?string = b ? "str" : null;\n\nx as ?string;\n\nx = "hi";\n\n// We know `x` must now be a string after the assignment\nx as string; // Works\n')),(0,i.mdx)("h3",{id:"type-guards"},"Type Guards"),(0,i.mdx)("p",null,"You can create a reusable refinement by defining a function which is a ",(0,i.mdx)("a",{parentName:"p",href:"../../types/type-guards/"},"type guard"),"."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":30,"endLine":1,"endColumn":35,"description":"Inconsistent type guard declaration. The negation of the predicate encoded in return expression `x != null` [1] needs to completely refine away the guard type `T` [2]. Consider using a one-sided type-guard (`implies x is T`). See 2. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]"}]','[{"startLine":1,"startColumn":30,"endLine":1,"endColumn":35,"description":"Inconsistent':!0,type:!0,guard:!0,"declaration.":!0,The:!0,negation:!0,of:!0,the:!0,predicate:!0,encoded:!0,in:!0,return:!0,expression:!0,"`x":!0,"!":"","null`":!0,"[1]":!0,needs:!0,to:!0,completely:!0,refine:!0,away:!0,"`T`":!0,"[2].":!0,Consider:!0,using:!0,a:!0,"one-sided":!0,"type-guard":!0,"(`implies":!0,x:!0,is:!0,"T`).":!0,See:!0,"2.":!0,"https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions.":!0,'[incompatible-type-guard]"}]':!0},"function nonMaybe<T>(x: ?T): x is T {\n  return x != null;\n}\n\nfunction func(value: ?string) {\n  if (nonMaybe(value)) {\n    value as string; // Works!\n  }\n}\n")),(0,i.mdx)("h2",{id:"toc-refinement-invalidations"},"Refinement Invalidations"),(0,i.mdx)("p",null,"It is also possible to invalidate refinements, for example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":16,"endLine":6,"endColumn":21,"description":"Cannot call `value.prop.charAt` because property `charAt` is missing in undefined [1]. [incompatible-use]"}]','[{"startLine":6,"startColumn":16,"endLine":6,"endColumn":21,"description":"Cannot':!0,call:!0,"`value.prop.charAt`":!0,because:!0,property:!0,"`charAt`":!0,is:!0,missing:!0,in:!0,undefined:!0,"[1].":!0,'[incompatible-use]"}]':!0},"function otherFunc() { /* ... */ }\n\nfunction func(value: {prop?: string}) {\n  if (value.prop) {\n    otherFunc();\n    value.prop.charAt(0); // Error!\n  }\n}\n")),(0,i.mdx)("p",null,"The reason for this is that we don't know that ",(0,i.mdx)("inlineCode",{parentName:"p"},"otherFunc()")," hasn't done\nsomething to our value. Imagine the following scenario:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":12,"startColumn":16,"endLine":12,"endColumn":21,"description":"Cannot call `value.prop.charAt` because property `charAt` is missing in undefined [1]. [incompatible-use]"}]','[{"startLine":12,"startColumn":16,"endLine":12,"endColumn":21,"description":"Cannot':!0,call:!0,"`value.prop.charAt`":!0,because:!0,property:!0,"`charAt`":!0,is:!0,missing:!0,in:!0,undefined:!0,"[1].":!0,'[incompatible-use]"}]':!0},'const obj: {prop?: string} = {prop: "test"};\n\nfunction otherFunc() {\n  if (Math.random() > 0.5) {\n    delete obj.prop;\n  }\n}\n\nfunction func(value: {prop?: string}) {\n  if (value.prop) {\n    otherFunc();\n    value.prop.charAt(0); // Error!\n  }\n}\n\nfunc(obj);\n')),(0,i.mdx)("p",null,"Inside of ",(0,i.mdx)("inlineCode",{parentName:"p"},"otherFunc()")," we sometimes remove ",(0,i.mdx)("inlineCode",{parentName:"p"},"prop"),". Flow doesn't know if the\n",(0,i.mdx)("inlineCode",{parentName:"p"},"if (value.prop)")," check is still true, so it invalidates the refinement."),(0,i.mdx)("p",null,"There's a straightforward way to get around this. Store the value before\ncalling another function and use the stored value instead. This way you can\nprevent the refinement from invalidating."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function otherFunc() { /* ... */ }\n\nfunction func(value: {prop?: string}) {\n  if (value.prop) {\n    const prop = value.prop;\n    otherFunc();\n    prop.charAt(0);\n  }\n}\n")))}p.isMDXComponent=!0}}]);