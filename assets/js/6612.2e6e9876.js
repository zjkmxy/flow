"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[6612],{6612:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>p,toc:()=>l});var t=a(58168),i=(a(96540),a(15680));a(60681);const o={title:"Type Variance",slug:"/lang/variance"},r=void 0,p={unversionedId:"lang/variance",id:"lang/variance",title:"Type Variance",description:"Variance is a topic that comes up fairly often in type systems. It is used to determine",source:"@site/docs/lang/variance.md",sourceDirName:"lang",slug:"/lang/variance",permalink:"/en/docs/lang/variance",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/lang/variance.md",tags:[],version:"current",frontMatter:{title:"Type Variance",slug:"/lang/variance"},sidebar:"docsSidebar",previous:{title:"Type Hierarchy",permalink:"/en/docs/lang/type-hierarchy"},next:{title:"Nominal & Structural Typing",permalink:"/en/docs/lang/nominal-structural"}},d={},l=[{value:"Covariance",id:"toc-covariance",level:2},{value:"Invariance",id:"toc-invariance",level:2},{value:"Contravariance",id:"toc-contravariance",level:2}],s={toc:l};function m(e){let{components:n,...a}=e;return(0,i.mdx)("wrapper",(0,t.A)({},s,a,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"Variance is a topic that comes up fairly often in type systems. It is used to determine\nhow type parameters behave with respect to subtyping."),(0,i.mdx)("p",null,"First we'll setup a couple of classes that extend one another."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"class Noun {}\nclass City extends Noun {}\nclass SanFrancisco extends City {}\n")),(0,i.mdx)("p",null,"We saw in the section on ",(0,i.mdx)("a",{parentName:"p",href:"../../types/generics/#toc-variance-sigils"},"generic types"),"\nthat it is possible to\nuse variance sigils to describe when a type parameter is used in an output position,\nwhen it is used in an input position, and when it is used in either one."),(0,i.mdx)("p",null,"Here we'll dive deeper into each one of these cases."),(0,i.mdx)("h2",{id:"toc-covariance"},"Covariance"),(0,i.mdx)("p",null,"Consider for example the type"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"type CovariantOf<X> = {\n  +prop: X;\n  getter(): X;\n}\n")),(0,i.mdx)("p",null,"Here, ",(0,i.mdx)("inlineCode",{parentName:"p"},"X")," appears strictly in ",(0,i.mdx)("em",{parentName:"p"},"output")," positions: it is used to read out information\nfrom objects ",(0,i.mdx)("inlineCode",{parentName:"p"},"o")," of type ",(0,i.mdx)("inlineCode",{parentName:"p"},"CovariantOf<X>"),", either through property accesses ",(0,i.mdx)("inlineCode",{parentName:"p"},"o.prop"),",\nor through calls to ",(0,i.mdx)("inlineCode",{parentName:"p"},"o.getter()"),"."),(0,i.mdx)("p",null,"Notably, there is no way to input data through the reference to the object ",(0,i.mdx)("inlineCode",{parentName:"p"},"o"),",\ngiven that ",(0,i.mdx)("inlineCode",{parentName:"p"},"prop")," is a readonly property."),(0,i.mdx)("p",null,"When these conditions hold, we can use the sigil ",(0,i.mdx)("inlineCode",{parentName:"p"},"+")," to annotate ",(0,i.mdx)("inlineCode",{parentName:"p"},"X")," in the definition\nof ",(0,i.mdx)("inlineCode",{parentName:"p"},"CovariantOf"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"type CovariantOf<+X> = {\n  +prop: X;\n  getter(): X;\n}\n")),(0,i.mdx)("p",null,"These conditions have important implications on the way that we can treat an object\nof type ",(0,i.mdx)("inlineCode",{parentName:"p"},"CovariantOf<T>"),' with respect to subtyping. As a reminder, subtyping rules\nhelp us answer the question: "given some context that expects values of type\n',(0,i.mdx)("inlineCode",{parentName:"p"},"T"),", is it safe to pass in values of type ",(0,i.mdx)("inlineCode",{parentName:"p"},"S"),'?" If this is the case, then ',(0,i.mdx)("inlineCode",{parentName:"p"},"S")," is a\nsubtype of ",(0,i.mdx)("inlineCode",{parentName:"p"},"T"),"."),(0,i.mdx)("p",null,"Using our ",(0,i.mdx)("inlineCode",{parentName:"p"},"CovariantOf")," definition, and given that ",(0,i.mdx)("inlineCode",{parentName:"p"},"City")," is a subtype of ",(0,i.mdx)("inlineCode",{parentName:"p"},"Noun"),", it is\nalso the case that ",(0,i.mdx)("inlineCode",{parentName:"p"},"CovariantOf<City>")," is a subtype of ",(0,i.mdx)("inlineCode",{parentName:"p"},"CovariantOf<Noun>"),". Indeed"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"it is safe to ",(0,i.mdx)("em",{parentName:"li"},"read")," a property ",(0,i.mdx)("inlineCode",{parentName:"li"},"prop")," of type ",(0,i.mdx)("inlineCode",{parentName:"li"},"City")," when a property\nof type ",(0,i.mdx)("inlineCode",{parentName:"li"},"Noun")," is expected, and"),(0,i.mdx)("li",{parentName:"ul"},"it is safe to ",(0,i.mdx)("em",{parentName:"li"},"return")," values of type ",(0,i.mdx)("inlineCode",{parentName:"li"},"City")," when calling ",(0,i.mdx)("inlineCode",{parentName:"li"},"getter()"),", when\nvalues of type ",(0,i.mdx)("inlineCode",{parentName:"li"},"Noun")," are expected.")),(0,i.mdx)("p",null,"Combining these two, it will always be safe to use ",(0,i.mdx)("inlineCode",{parentName:"p"},"CovariantOf<City>")," whenever a\n",(0,i.mdx)("inlineCode",{parentName:"p"},"CovariantOf<Noun>")," is expected."),(0,i.mdx)("p",null,"A commonly used example where covariance is used is ",(0,i.mdx)("a",{parentName:"p",href:"../../types/arrays/#toc-readonlyarray"},(0,i.mdx)("inlineCode",{parentName:"a"},"$ReadOnlyArray<T>")),".\nJust like with the ",(0,i.mdx)("inlineCode",{parentName:"p"},"prop")," property, one cannot use a ",(0,i.mdx)("inlineCode",{parentName:"p"},"$ReadOnlyArray")," reference to write data\nto an array. This allows more flexible subtyping rules: Flow only needs to prove that\n",(0,i.mdx)("inlineCode",{parentName:"p"},"S")," is a subtype of ",(0,i.mdx)("inlineCode",{parentName:"p"},"T")," to determine that ",(0,i.mdx)("inlineCode",{parentName:"p"},"$ReadOnlyArray<S>")," is also a subtype\nof ",(0,i.mdx)("inlineCode",{parentName:"p"},"$ReadOnlyArray<T>"),"."),(0,i.mdx)("h2",{id:"toc-invariance"},"Invariance"),(0,i.mdx)("p",null,"Let's see what happens if we try to relax the restrictions on the use of ",(0,i.mdx)("inlineCode",{parentName:"p"},"X")," and make,\nfor example, ",(0,i.mdx)("inlineCode",{parentName:"p"},"prop")," be a read-write property. We arrive at the type definition"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"type NonCovariantOf<X> = {\n  prop: X;\n  getter(): X;\n};\n")),(0,i.mdx)("p",null,"Let's also declare a variable ",(0,i.mdx)("inlineCode",{parentName:"p"},"nonCovariantCity")," of type ",(0,i.mdx)("inlineCode",{parentName:"p"},"NonCovariantOf<City>")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"declare const nonCovariantCity: NonCovariantOf<City>;\n")),(0,i.mdx)("p",null,"Now, it is not safe to consider ",(0,i.mdx)("inlineCode",{parentName:"p"},"nonCovariantCity")," as an object of type ",(0,i.mdx)("inlineCode",{parentName:"p"},"NonCovariantOf<Noun>"),".\nWere we allowed to do this, we could have the following declaration:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"const nonCovariantNoun: NonCovariantOf<Noun> = nonCovariantCity;\n")),(0,i.mdx)("p",null,"This type permits the following assignment:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"nonCovariantNoun.prop = new Noun;\n")),(0,i.mdx)("p",null,"which would invalidate the original type for ",(0,i.mdx)("inlineCode",{parentName:"p"},"nonCovariantCity")," as it would now be storing\na ",(0,i.mdx)("inlineCode",{parentName:"p"},"Noun")," in its ",(0,i.mdx)("inlineCode",{parentName:"p"},"prop")," field."),(0,i.mdx)("p",null,"What distinguishes ",(0,i.mdx)("inlineCode",{parentName:"p"},"NonCovariantOf")," from the ",(0,i.mdx)("inlineCode",{parentName:"p"},"CovariantOf")," definition is that type parameter ",(0,i.mdx)("inlineCode",{parentName:"p"},"X")," is used both\nin input and output positions, as it is being used to both read and write to\nproperty ",(0,i.mdx)("inlineCode",{parentName:"p"},"prop"),". Such a type parameter is called ",(0,i.mdx)("em",{parentName:"p"},"invariant")," and is the default case\nof variance, thus requiring no prepending sigil:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"type InvariantOf<X> = {\n  prop: X;\n  getter(): X;\n  setter(X): void;\n};\n")),(0,i.mdx)("p",null,"Assuming a variable"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"declare const invariantCity: InvariantOf<City>;\n")),(0,i.mdx)("p",null,"it is ",(0,i.mdx)("em",{parentName:"p"},"not")," safe to use ",(0,i.mdx)("inlineCode",{parentName:"p"},"invariantCity")," in a context where:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"an ",(0,i.mdx)("inlineCode",{parentName:"li"},"InvariantOf<Noun>")," is needed, because we should not be able to write a ",(0,i.mdx)("inlineCode",{parentName:"li"},"Noun")," to property\n",(0,i.mdx)("inlineCode",{parentName:"li"},"prop"),"."),(0,i.mdx)("li",{parentName:"ul"},"an ",(0,i.mdx)("inlineCode",{parentName:"li"},"InvariantOf<SanFrancisco>")," is needed, because reading ",(0,i.mdx)("inlineCode",{parentName:"li"},"prop")," could return a ",(0,i.mdx)("inlineCode",{parentName:"li"},"City")," which\nmay not be ",(0,i.mdx)("inlineCode",{parentName:"li"},"SanFrancisco"),".")),(0,i.mdx)("p",null,"In orther words, ",(0,i.mdx)("inlineCode",{parentName:"p"},"InvariantOf<City>")," is neither a subtype of ",(0,i.mdx)("inlineCode",{parentName:"p"},"InvariantOf<Noun>")," nor\na subtype of ",(0,i.mdx)("inlineCode",{parentName:"p"},"InvariantOf<SanFrancisco>"),"."),(0,i.mdx)("h2",{id:"toc-contravariance"},"Contravariance"),(0,i.mdx)("p",null,"When a type parameter is only used in ",(0,i.mdx)("em",{parentName:"p"},"input")," positions, we say that it is used in\na ",(0,i.mdx)("em",{parentName:"p"},"contravariant")," way. This means that it only appears in positions through which\nwe write data to the structure. We use the sigil ",(0,i.mdx)("inlineCode",{parentName:"p"},"-")," to describe this kind of type\nparameters:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"type ContravariantOf<-X> = {\n  -prop: X;\n  setter(X): void;\n};\n")),(0,i.mdx)("p",null,'Common contravariant positions are write-only properties and "setter" functions.'),(0,i.mdx)("p",null,"An object of type ",(0,i.mdx)("inlineCode",{parentName:"p"},"ContravariantOf<City>")," can be used whenever an object of type\n",(0,i.mdx)("inlineCode",{parentName:"p"},"ContravariantOf<SanFrancisco>")," is expected, but not when a ",(0,i.mdx)("inlineCode",{parentName:"p"},"ContravariantOf<Noun>")," is.\nIn other words, ",(0,i.mdx)("inlineCode",{parentName:"p"},"ContravariantOf<City>")," is a subtype of ",(0,i.mdx)("inlineCode",{parentName:"p"},"ContravariantOf<SanFrancisco>"),", but not\n",(0,i.mdx)("inlineCode",{parentName:"p"},"ContravariantOf<Noun>"),".\nThis is because it is fine to write ",(0,i.mdx)("inlineCode",{parentName:"p"},"SanFrancisco")," into a property that can have any ",(0,i.mdx)("inlineCode",{parentName:"p"},"City")," written\nto, but it is not safe to write just any ",(0,i.mdx)("inlineCode",{parentName:"p"},"Noun"),"."))}m.isMDXComponent=!0}}]);