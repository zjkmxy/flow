"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[6403],{76403:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var a=t(58168),r=(t(96540),t(15680));const o={title:"Typing Generators with Flow","short-title":"Generators",author:"Sam Goldman",hide_table_of_contents:!0},i=void 0,l={permalink:"/blog/2015/11/09/Generators",source:"@site/blog/2015-11-09-Generators.md",title:"Typing Generators with Flow",description:"Flow 0.14.0 included support for generator functions. Generator functions provide a unique ability to JavaScript programs: the ability to suspend and resume execution. This kind of control paves the way for async/await, an upcoming feature already supported by Flow.",date:"2015-11-09T00:00:00.000Z",formattedDate:"November 9, 2015",tags:[],hasTruncateMarker:!0,authors:[{name:"Sam Goldman"}],frontMatter:{title:"Typing Generators with Flow","short-title":"Generators",author:"Sam Goldman",hide_table_of_contents:!0},prevItem:{title:"Version-0.19.0",permalink:"/blog/2015/12/01/Version-0.19.0"},nextItem:{title:"Version-0.17.0",permalink:"/blog/2015/10/07/Version-0.17.0"}},s={authorsImageUrls:[void 0]},d=[],p={toc:d};function m(e){let{components:n,...t}=e;return(0,r.mdx)("wrapper",(0,a.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"Flow 0.14.0 included support for generator functions. Generator functions provide a unique ability to JavaScript programs: the ability to suspend and resume execution. This kind of control paves the way for async/await, an ",(0,r.mdx)("a",{parentName:"p",href:"https://github.com/tc39/ecmascript-asyncawait"},"upcoming feature")," already supported by Flow."),(0,r.mdx)("p",null,"So much wonderful material has already been produced describing generators. I am going to focus on the interaction of static typing with generators. Please refer to the following materials for information about generators:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Jafar Husain gave an ",(0,r.mdx)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=DqMFX91ToLw#t=970"},"incredibly lucid and well-illustrated talk")," that covers generators. I have linked to the point where he gets into generators, but I highly recommend the entire talk."),(0,r.mdx)("li",{parentName:"ul"},"Exploring ES6, a comprehensive book by Axel Rauschmayer, who has generously made the contents available for free online, has a ",(0,r.mdx)("a",{parentName:"li",href:"http://exploringjs.com/es6/ch_generators.html"},"chapter on generators"),"."),(0,r.mdx)("li",{parentName:"ul"},"The venerable MDN has a ",(0,r.mdx)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators"},"useful page")," describing the ",(0,r.mdx)("inlineCode",{parentName:"li"},"Iterator")," interface and generators.")),(0,r.mdx)("p",null,"In Flow, the ",(0,r.mdx)("inlineCode",{parentName:"p"},"Generator")," interface has three type parameters: ",(0,r.mdx)("inlineCode",{parentName:"p"},"Yield"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"Return"),", and ",(0,r.mdx)("inlineCode",{parentName:"p"},"Next"),". ",(0,r.mdx)("inlineCode",{parentName:"p"},"Yield")," is the type of values which are yielded from the generator function. ",(0,r.mdx)("inlineCode",{parentName:"p"},"Return")," is the type of the value which is returned from the generator function. ",(0,r.mdx)("inlineCode",{parentName:"p"},"Next")," is the type of values which are passed into the generator via the ",(0,r.mdx)("inlineCode",{parentName:"p"},"next")," method on the ",(0,r.mdx)("inlineCode",{parentName:"p"},"Generator")," itself. For example, a generator value of type ",(0,r.mdx)("inlineCode",{parentName:"p"},"Generator<string,number,boolean>")," will yield ",(0,r.mdx)("inlineCode",{parentName:"p"},"string"),"s, return a ",(0,r.mdx)("inlineCode",{parentName:"p"},"number"),", and will receive ",(0,r.mdx)("inlineCode",{parentName:"p"},"boolean"),"s from its caller."),(0,r.mdx)("p",null,"For any type ",(0,r.mdx)("inlineCode",{parentName:"p"},"T"),", a ",(0,r.mdx)("inlineCode",{parentName:"p"},"Generator<T,void,void>")," is both an ",(0,r.mdx)("inlineCode",{parentName:"p"},"Iterable<T>")," and an ",(0,r.mdx)("inlineCode",{parentName:"p"},"Iterator<T>"),"."),(0,r.mdx)("p",null,"The unique nature of generators allows us to represent infinite sequences naturally. Consider the infinite sequence of natural numbers:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-javascript"},"function *nats() {\n  let i = 0;\n  while (true) {\n    yield i++;\n  }\n}\n")),(0,r.mdx)("p",null,"Because generators are also iterators, we can manually iterate the generator:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-javascript"},"const gen = nats();\nconsole.log(gen.next()); // { done: false, value: 0 }\nconsole.log(gen.next()); // { done: false, value: 1 }\nconsole.log(gen.next()); // { done: false, value: 2 }\n")),(0,r.mdx)("p",null,"When ",(0,r.mdx)("inlineCode",{parentName:"p"},"done")," is false, ",(0,r.mdx)("inlineCode",{parentName:"p"},"value")," will have the generator's ",(0,r.mdx)("inlineCode",{parentName:"p"},"Yield")," type. When ",(0,r.mdx)("inlineCode",{parentName:"p"},"done")," is true, ",(0,r.mdx)("inlineCode",{parentName:"p"},"value")," will have the generator's ",(0,r.mdx)("inlineCode",{parentName:"p"},"Return")," type or ",(0,r.mdx)("inlineCode",{parentName:"p"},"void")," if the consumer iterates past the completion value."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-javascript"},'function *test() {\n  yield 1;\n  return "complete";\n}\nconst gen = test();\nconsole.log(gen.next()); // { done: false, value: 1 }\nconsole.log(gen.next()); // { done: true, value: "complete" }\nconsole.log(gen.next()); // { done: true, value: undefined }\n')),(0,r.mdx)("p",null,"Because of this behavior, manually iterating poses typing difficulties. Let's try to take the first 10 values from the ",(0,r.mdx)("inlineCode",{parentName:"p"},"nats")," generator through manual iteration:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-javascript"},"const gen = nats();\nconst take10: number[] = [];\nfor (let i = 0; i < 10; i++) {\n  const { done, value } = gen.next();\n  if (done) {\n    break;\n  } else {\n    take10.push(value); // error!\n  }\n}\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"test.js:13\n 13:   const { done, value } = gen.next();\n                               ^^^^^^^^^^ call of method `next`\n 17:     take10.push(value); // error!\n                     ^^^^^ undefined. This type is incompatible with\n 11: const take10: number[] = [];\n                   ^^^^^^ number\n")),(0,r.mdx)("p",null,"Flow is complaining that ",(0,r.mdx)("inlineCode",{parentName:"p"},"value")," might be ",(0,r.mdx)("inlineCode",{parentName:"p"},"undefined"),". This is because the type of ",(0,r.mdx)("inlineCode",{parentName:"p"},"value")," is ",(0,r.mdx)("inlineCode",{parentName:"p"},"Yield | Return | void"),", which simplifies in the instance of ",(0,r.mdx)("inlineCode",{parentName:"p"},"nats")," to ",(0,r.mdx)("inlineCode",{parentName:"p"},"number | void"),". We can introduce a dynamic type test to convince Flow of the invariant that ",(0,r.mdx)("inlineCode",{parentName:"p"},"value")," will always be ",(0,r.mdx)("inlineCode",{parentName:"p"},"number")," when ",(0,r.mdx)("inlineCode",{parentName:"p"},"done")," is false."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-javascript"},'const gen = nats();\nconst take10: number[] = [];\nfor (let i = 0; i < 10; i++) {\n  const { done, value } = gen.next();\n  if (done) {\n    break;\n  } else {\n    if (typeof value === "undefined") {\n      throw new Error("`value` must be a number.");\n    }\n    take10.push(value); // no error\n  }\n}\n')),(0,r.mdx)("p",null,"There is an ",(0,r.mdx)("a",{parentName:"p",href:"https://github.com/facebook/flow/issues/577"},"open issue")," which would make the dynamic type test above unnecessary, by using the ",(0,r.mdx)("inlineCode",{parentName:"p"},"done")," value as a sentinel to refine a tagged union. That is, when ",(0,r.mdx)("inlineCode",{parentName:"p"},"done")," is ",(0,r.mdx)("inlineCode",{parentName:"p"},"true"),", Flow would know that ",(0,r.mdx)("inlineCode",{parentName:"p"},"value")," is always of type ",(0,r.mdx)("inlineCode",{parentName:"p"},"Yield")," and otherwise of type ",(0,r.mdx)("inlineCode",{parentName:"p"},"Return | void"),"."),(0,r.mdx)("p",null,"Even without the dynamic type test, this code is quite verbose and it's hard to see the intent. Because generators are also iterable, we can also use ",(0,r.mdx)("inlineCode",{parentName:"p"},"for...of")," loops:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-javascript"},"const take10: number[] = [];\nlet i = 0;\nfor (let nat of nats()) {\n  if (i === 10) break;\n  take10.push(nat);\n  i++;\n}\n")),(0,r.mdx)("p",null,"That's much better. The ",(0,r.mdx)("inlineCode",{parentName:"p"},"for...of")," looping construct ignores completion values, so Flow understands that ",(0,r.mdx)("inlineCode",{parentName:"p"},"nat")," will always be ",(0,r.mdx)("inlineCode",{parentName:"p"},"number"),". Let's generalize this pattern further using generator functions:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-javascript"},"function *take<T>(n: number, xs: Iterable<T>): Iterable<T> {\n  if (n <= 0) return;\n  let i = 0;\n  for (let x of xs) {\n    yield x;\n    if (++i === n) return;\n  }\n}\n\nfor (let n of take(10, nats())) {\n  console.log(n); // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n}\n")),(0,r.mdx)("p",null,"Note that we explicitly annotated the parameters and return type of the ",(0,r.mdx)("inlineCode",{parentName:"p"},"take")," generator. This is necessary to ensure Flow understands the fully generic type. This is because Flow does not currently infer a fully generic type, but instead accumulates lower bounds, resulting in a union type."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-javascript"},'function identity(x) { return x }\nvar a: string = identity(""); // error\nvar b: number = identity(0);  // error\n')),(0,r.mdx)("p",null,"The above code produces errors because Flow adds ",(0,r.mdx)("inlineCode",{parentName:"p"},"string")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"number")," as lower bounds to the type variable describing the type of the value bound by ",(0,r.mdx)("inlineCode",{parentName:"p"},"x"),". That is, Flow believes the type of ",(0,r.mdx)("inlineCode",{parentName:"p"},"identity")," is ",(0,r.mdx)("inlineCode",{parentName:"p"},"(x: string | number) => string | number")," because those are the types which actually passed through the function."),(0,r.mdx)("p",null,"Another important feature of generators is the ability to pass values into the generator from the consumer. Let's consider a generator ",(0,r.mdx)("inlineCode",{parentName:"p"},"scan"),", which reduces values passed into the generator using a provided function. Our ",(0,r.mdx)("inlineCode",{parentName:"p"},"scan")," is similar to ",(0,r.mdx)("inlineCode",{parentName:"p"},"Array.prototype.reduce"),", but it returns each intermediate value and the values are provided imperatively via ",(0,r.mdx)("inlineCode",{parentName:"p"},"next"),"."),(0,r.mdx)("p",null,"As a first pass, we might write this:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-javascript"},"function *scan<T,U>(init: U, f: (acc: U, x: T) => U): Generator<U,void,T> {\n  let acc = init;\n  while (true) {\n    const next = yield acc;\n    acc = f(acc, next);\n  }\n}\n")),(0,r.mdx)("p",null,"We can use this definition to implement an imperative sum procedure:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-javascript"},"let sum = scan(0, (a,b) => a + b);\nconsole.log(sum.next());  // { done: false, value: 0 }\nconsole.log(sum.next(1)); // { done: false, value: 1 }\nconsole.log(sum.next(2)); // { done: false, value: 3 }\nconsole.log(sum.next(3)); // { done: false, value: 6 }\n")),(0,r.mdx)("p",null,"However, when we try to check the above definition of ",(0,r.mdx)("inlineCode",{parentName:"p"},"scan"),", Flow complains:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"test.js:7\n  7:     acc = f(acc, next);\n               ^^^^^^^^^^^^ function call\n  7:     acc = f(acc, next);\n                      ^^^^ undefined. This type is incompatible with\n  3: function *scan<T,U>(init: U, f: (acc: U, x: T) => U): Generator<U,void,T> {\n     ^ some incompatible instantiation of T\n")),(0,r.mdx)("p",null,"Flow is complaining that our value, ",(0,r.mdx)("inlineCode",{parentName:"p"},"next"),", may be ",(0,r.mdx)("inlineCode",{parentName:"p"},"void")," instead of the expected ",(0,r.mdx)("inlineCode",{parentName:"p"},"T"),", which is ",(0,r.mdx)("inlineCode",{parentName:"p"},"number")," in the ",(0,r.mdx)("inlineCode",{parentName:"p"},"sum")," example. This behavior is necessary to ensure type safety. In order to prime the generator, our consumer must first call ",(0,r.mdx)("inlineCode",{parentName:"p"},"next")," without an argument. To accommodate this, Flow understands the argument to ",(0,r.mdx)("inlineCode",{parentName:"p"},"next")," to be optional. This means Flow will allow the following code:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-javascript"},"let sum = scan(0, (a,b) => a + b);\nconsole.log(sum.next());  // first call primes the generator\nconsole.log(sum.next());  // we should pass a value, but don't need to\n")),(0,r.mdx)("p",null,'In general, Flow doesn\'t know which invocation is "first." While it should be an error to pass a value to the first ',(0,r.mdx)("inlineCode",{parentName:"p"},"next"),", and an error to ",(0,r.mdx)("em",{parentName:"p"},"not")," pass a value to subsequent ",(0,r.mdx)("inlineCode",{parentName:"p"},"next"),"s, Flow compromises and forces your generator to deal with a potentially ",(0,r.mdx)("inlineCode",{parentName:"p"},"void")," value. In short, given a generator of type ",(0,r.mdx)("inlineCode",{parentName:"p"},"Generator<Y,R,N>")," and a value ",(0,r.mdx)("inlineCode",{parentName:"p"},"x")," of type ",(0,r.mdx)("inlineCode",{parentName:"p"},"Y"),", the type of the expression ",(0,r.mdx)("inlineCode",{parentName:"p"},"yield x")," is ",(0,r.mdx)("inlineCode",{parentName:"p"},"N | void"),"."),(0,r.mdx)("p",null,"We can update our definition to use a dynamic type test that enforces the non-",(0,r.mdx)("inlineCode",{parentName:"p"},"void")," invariant at runtime:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-javascript"},'function *scan<T,U>(init: U, f: (acc: U, x: T) => U): Generator<U,void,T> {\n  let acc = init;\n  while (true) {\n    const next = yield acc;\n    if (typeof next === "undefined") {\n      throw new Error("Caller must provide an argument to `next`.");\n    }\n    acc = f(acc, next);\n  }\n}\n')),(0,r.mdx)("p",null,"There is one more important caveat when dealing with typed generators. Every value yielded from the generator must be described by a single type. Similarly, every value passed to the generator via ",(0,r.mdx)("inlineCode",{parentName:"p"},"next")," must be described by a single type."),(0,r.mdx)("p",null,"Consider the following generator:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-javascript"},'function *foo() {\n  yield 0;\n  yield "";\n}\n\nconst gen = foo();\nconst a: number = gen.next().value; // error\nconst b: string = gen.next().value; // error\n')),(0,r.mdx)("p",null,"This is perfectly legal JavaScript and the values ",(0,r.mdx)("inlineCode",{parentName:"p"},"a")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"b")," do have the correct types at runtime. However, Flow rejects this program. Our generator's ",(0,r.mdx)("inlineCode",{parentName:"p"},"Yield")," type parameter has a concrete type of ",(0,r.mdx)("inlineCode",{parentName:"p"},"number | string"),". The ",(0,r.mdx)("inlineCode",{parentName:"p"},"value")," property of the iterator result object has the type ",(0,r.mdx)("inlineCode",{parentName:"p"},"number | string | void"),"."),(0,r.mdx)("p",null,"We can observe similar behavior for values passed into the generator:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},'function *bar() {\n  var a = yield;\n  var b = yield;\n  return {a,b};\n}\n\nconst gen = bar();\ngen.next(); // prime the generator\ngen.next(0);\nconst ret: { a: number, b: string } = gen.next("").value; // error\n')),(0,r.mdx)("p",null,"The value ",(0,r.mdx)("inlineCode",{parentName:"p"},"ret")," has the annotated type at runtime, but Flow also rejects this program. Our generator's ",(0,r.mdx)("inlineCode",{parentName:"p"},"Next")," type parameter has a concrete type of ",(0,r.mdx)("inlineCode",{parentName:"p"},"number | string"),". The ",(0,r.mdx)("inlineCode",{parentName:"p"},"value")," property of the iterator result object thus has the type ",(0,r.mdx)("inlineCode",{parentName:"p"},"void | { a: void | number | string, b: void | number | string }"),"."),(0,r.mdx)("p",null,"While it may be possible to use dynamic type tests to resolve these issues, another practical option is to use ",(0,r.mdx)("inlineCode",{parentName:"p"},"any")," to take on the type safety responsibility yourself."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-javascript"},'function *bar(): Generator {\n  var a = yield;\n  var b = yield;\n  return {a,b};\n}\n\nconst gen = bar();\ngen.next(); // prime the generator\ngen.next(0);\nconst ret: void | { a: number, b: string } = gen.next("").value; // OK\n')),(0,r.mdx)("p",null,"(Note that the annotation ",(0,r.mdx)("inlineCode",{parentName:"p"},"Generator")," is equivalent to ",(0,r.mdx)("inlineCode",{parentName:"p"},"Generator<any,any,any>"),".)"),(0,r.mdx)("p",null,"Phew! I hope that this will help you use generators in your own code. I also hope this gave you a little insight into the difficulties of applying static analysis to a highly dynamic language such as JavaScript."),(0,r.mdx)("p",null,"To summarize, here are some of the lessons we've learned for using generators in statically typed JS:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Use generators to implement custom iterables."),(0,r.mdx)("li",{parentName:"ul"},"Use dynamic type tests to unpack the optional return type of yield expressions."),(0,r.mdx)("li",{parentName:"ul"},"Avoid generators that yield or receive values of multiple types, or use ",(0,r.mdx)("inlineCode",{parentName:"li"},"any"),".")))}m.isMDXComponent=!0}}]);