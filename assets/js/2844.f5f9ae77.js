"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[2844],{18430:(e,n,t)=>{t.d(n,{V:()=>i,v:()=>o});var a=t(96540);function i(e){let{version:n}=e;return a.createElement("span",{class:"version added",title:"Added in "+n},"\u2265",n)}function o(e){let{version:n}=e;return a.createElement("span",{class:"version removed",title:"Removed after "+n},"\u2264",n)}},22844:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>m});var a=t(58168),i=(t(96540),t(15680)),o=(t(60681),t(18430));const r={title:"Utility Types",slug:"/types/utilities"},s=void 0,l={unversionedId:"types/utilities",id:"types/utilities",title:"Utility Types",description:"Flow provides a set of utility types to operate on other types to create new types.",source:"@site/docs/types/utilities.md",sourceDirName:"types",slug:"/types/utilities",permalink:"/en/docs/types/utilities",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/types/utilities.md",tags:[],version:"current",frontMatter:{title:"Utility Types",slug:"/types/utilities"},sidebar:"docsSidebar",previous:{title:"Type Casting Expressions",permalink:"/en/docs/types/casting"},next:{title:"Module Types",permalink:"/en/docs/types/modules"}},p={},m=[{value:"<code>$Keys&lt;T&gt;</code>",id:"toc-keys",level:2},{value:"<code>$Values&lt;T&gt;</code>",id:"toc-values",level:2},{value:"<code>$ReadOnly&lt;T&gt;</code>",id:"toc-readonly",level:2},{value:'<code>Partial&lt;T&gt;</code>  <SinceVersion version="0.201" />',id:"toc-partial",level:2},{value:'<code>Required&lt;T&gt;</code> <SinceVersion version="0.201" />',id:"toc-required",level:2},{value:'<code>ReturnType&lt;F&gt;</code> <SinceVersion version="0.209" />',id:"toc-return-type",level:2},{value:'<code>Parameters&lt;F&gt;</code> <SinceVersion version="0.209" />',id:"toc-parameters",level:2},{value:'<code>Exclude&lt;T, U&gt;</code> <SinceVersion version="0.209" />',id:"toc-exclude",level:2},{value:'<code>Extract&lt;T, U&gt;</code> <SinceVersion version="0.209" />',id:"toc-extract",level:2},{value:'<code>ThisParameterType&lt;F&gt;</code> <SinceVersion version="0.209" />',id:"toc-this-parameter-type",level:2},{value:'<code>OmitThisParameter&lt;F&gt;</code> <SinceVersion version="0.209" />',id:"toc-omit-this-parameter-type",level:2},{value:'<code>Pick&lt;O, Keys&gt;</code> <SinceVersion version="0.211" />',id:"toc-pick",level:2},{value:'<code>Omit&lt;O, Keys&gt;</code> <SinceVersion version="0.211" />',id:"toc-omit",level:2},{value:'<code>Record&lt;Keys, Type&gt;</code> <SinceVersion version="0.211" />',id:"toc-record",level:2},{value:"<code>$Exact&lt;T&gt;</code>",id:"toc-exact",level:2},{value:"<code>$Diff&lt;A, B&gt;</code>",id:"toc-diff",level:2},{value:"<code>$Rest&lt;A, B&gt;</code>",id:"toc-rest",level:2},{value:"<code>$NonMaybeType&lt;T&gt;</code>",id:"toc-nonmaybe",level:2},{value:"<code>$KeyMirror&lt;O&gt;</code>",id:"toc-keymirror",level:2},{value:"<code>$TupleMap&lt;T, F&gt;</code>",id:"toc-tuplemap",level:2},{value:"<code>Class&lt;T&gt;</code>",id:"toc-class",level:2},{value:"<code>$Exports&lt;T&gt;</code>",id:"toc-exports",level:2},{value:'<code>StringPrefix</code> and <code>StringSuffix</code> <SinceVersion version="0.242" />',id:"stringprefix-and-stringsuffix-",level:2},{value:"Deprecated utility types",id:"deprecated-utility-types",level:2},{value:"<code>$PropertyType&lt;T, k&gt;</code>",id:"toc-propertytype",level:3},{value:"<code>$ElementType&lt;T, K&gt;</code>",id:"toc-elementtype",level:3},{value:"<code>$Call&lt;F, T...&gt;</code>",id:"toc-call",level:3},{value:"To-be-removed utility types",id:"to-be-removed-utility-types",level:2},{value:"<code>$ObjMap&lt;T, F&gt;</code>",id:"toc-objmap",level:3},{value:"<code>$ObjMapi&lt;T, F&gt;</code>",id:"toc-objmapi",level:3},{value:"<code>$ObjMapConst&lt;O, T&gt;</code>",id:"toc-objmapconst",level:3},{value:"Removed utility types",id:"removed-utility-types",level:2},{value:'<code>$Partial</code> <UntilVersion version="0.202" />',id:"partial-",level:3},{value:'<code>$Shape&lt;T&gt;</code> <UntilVersion version="0.206" />',id:"toc-shape",level:3}],d={toc:m};function c(e){let{components:n,...t}=e;return(0,i.mdx)("wrapper",(0,a.A)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"Flow provides a set of utility types to operate on other types to create new types."),(0,i.mdx)("h2",{id:"toc-keys"},(0,i.mdx)("inlineCode",{parentName:"h2"},"$Keys<T>")),(0,i.mdx)("p",null,"You can extract the type of the keys from an ",(0,i.mdx)("a",{parentName:"p",href:"../objects"},"object type"),". Typically this will be a ",(0,i.mdx)("a",{parentName:"p",href:"../unions"},"union")," of ",(0,i.mdx)("a",{parentName:"p",href:"../literals"},"string literal")," types:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":10,"startColumn":23,"endLine":10,"endColumn":28,"description":"Cannot assign `\'nope\'` to `nope` because property `nope` is missing in object literal [1]. [prop-missing]"}]','[{"startLine":10,"startColumn":23,"endLine":10,"endColumn":28,"description":"Cannot':!0,assign:!0,"`'nope'`":!0,to:!0,"`nope`":!0,because:!0,property:!0,is:!0,missing:!0,in:!0,object:!0,literal:!0,"[1].":!0,'[prop-missing]"}]':!0},'const countries = {\n  US: "United States",\n  IT: "Italy",\n  FR: "France"\n};\n\ntype Country = $Keys<typeof countries>;\n\nconst italy: Country = \'IT\'; // Works\nconst nope: Country = \'nope\'; // Error!\n')),(0,i.mdx)("p",null,"In the example above, the type of ",(0,i.mdx)("inlineCode",{parentName:"p"},"Country")," is equivalent to ",(0,i.mdx)("inlineCode",{parentName:"p"},"type Country = 'US' | 'IT' | 'FR'"),", but Flow was able to extract it from the keys of ",(0,i.mdx)("inlineCode",{parentName:"p"},"countries"),"."),(0,i.mdx)("p",null,"If you want to create an enum type, ",(0,i.mdx)("a",{parentName:"p",href:"../../enums"},"Flow Enums")," might be a better fit for your use-case."),(0,i.mdx)("h2",{id:"toc-values"},(0,i.mdx)("inlineCode",{parentName:"h2"},"$Values<T>")),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"$Values<T>")," represents the union type of all the value types of the enumerable properties in an ",(0,i.mdx)("a",{parentName:"p",href:"../objects/"},"object type"),",\nor the elements of an ",(0,i.mdx)("a",{parentName:"p",href:"../arrays"},"array")," or ",(0,i.mdx)("a",{parentName:"p",href:"../tuples"},"tuple")," type (support for arrays and tuples in Flow version ",(0,i.mdx)(o.V,{version:"0.240",mdxType:"SinceVersion"}),"):"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":12,"startColumn":25,"endLine":12,"endColumn":28,"description":"Cannot assign `true` to `fn` because: [incompatible-type] Either boolean [1] is incompatible with string [2]. Or boolean [1] is incompatible with number [3]."}]','[{"startLine":12,"startColumn":25,"endLine":12,"endColumn":28,"description":"Cannot':!0,assign:!0,"`true`":!0,to:!0,"`fn`":!0,"because:":!0,"[incompatible-type]":!0,Either:!0,boolean:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,string:!0,"[2].":!0,Or:!0,number:!0,'[3]."}]':!0},"type Props = {\n  name: string,\n  age: number,\n};\n\n// The following two types are equivalent:\ntype PropValues = string | number;\ntype Prop$Values = $Values<Props>;\n\nconst name: Prop$Values = 'Jon';  // Works\nconst age: Prop$Values = 42;  // Works\nconst fn: Prop$Values = true; // Error!\n")),(0,i.mdx)("p",null,"For arrays and tuples:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Arr = Array<string>;\ntype Str = $Values<Arr>; //=> string\n's' as Str; // OK\n\ntype Tup = [1, 2];\ntype Num = $Values<Tup>; //=> 1 | 2\n1 as Num; // OK\n")),(0,i.mdx)("p",null,"Note that using ",(0,i.mdx)("inlineCode",{parentName:"p"},"$Values")," on the ",(0,i.mdx)("a",{parentName:"p",href:"../typeof"},(0,i.mdx)("inlineCode",{parentName:"a"},"typeof"))," an object or array literal will result in a type more general than you might expect:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const obj = {\n  foo: 1,\n  bar: 2,\n};\n\nfunction acceptsValues(x: $Values<typeof obj>) { /* ... */ }\n\nacceptsValues(1); // Works\nacceptsValues(3); // Works, because the type was interpreted as `number`.\n")),(0,i.mdx)("p",null,"This behavior changes if you use ",(0,i.mdx)("inlineCode",{parentName:"p"},"Object.freeze")," on the object literal expression:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":9,"startColumn":15,"endLine":9,"endColumn":15,"description":"Cannot call `acceptsValues` with `3` bound to `x` because number [1] is incompatible with `$Values` [2]. [incompatible-call]"}]','[{"startLine":9,"startColumn":15,"endLine":9,"endColumn":15,"description":"Cannot':!0,call:!0,"`acceptsValues`":!0,with:!0,"`3`":!0,bound:!0,to:!0,"`x`":!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,"`$Values`":!0,"[2].":!0,'[incompatible-call]"}]':!0},"const obj = Object.freeze({\n  foo: 1,\n  bar: 2,\n});\n\nfunction acceptsValues(x: $Values<typeof obj>) { /* ... */ }\n\nacceptsValues(1); // Works\nacceptsValues(3); // Error! Because the type was interpreted as `1 | 2`.\n")),(0,i.mdx)("p",null,"If you want to create an enum type, ",(0,i.mdx)("a",{parentName:"p",href:"../../enums"},"Flow Enums")," might be a better fit for your use-case."),(0,i.mdx)("h2",{id:"toc-readonly"},(0,i.mdx)("inlineCode",{parentName:"h2"},"$ReadOnly<T>")),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"$ReadOnly<T>")," is a type that represents the read-only version of a given ",(0,i.mdx)("a",{parentName:"p",href:"../objects/"},"object type"),"\nor ",(0,i.mdx)("a",{parentName:"p",href:"../tuples"},"tuple type")," ",(0,i.mdx)("inlineCode",{parentName:"p"},"T")," (support for tuples is for Flow ",(0,i.mdx)(o.V,{version:"0.212",mdxType:"SinceVersion"}),").\nA read-only object type is an object type whose keys are all ",(0,i.mdx)("a",{parentName:"p",href:"../objects/#read-only-object-properties"},"read-only"),".\nSimilarly, a read-only tuple is one where each element is ",(0,i.mdx)("a",{parentName:"p",href:"../tuples/#variance-annotations-and-read-only-tuples"},"read-only"),"."),(0,i.mdx)("p",null,"This means that the following are equivalent:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type ReadOnlyObj = {\n  +key: number,  // read-only field, marked by the `+` annotation\n};\ntype ReadOnlyTuple = [+foo: number];\n")),(0,i.mdx)("p",null,"\u2192"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type ReadOnlyObj = $ReadOnly<{\n  key: number,\n}>;\ntype ReadOnlyTuple = $ReadOnly<[number]>;\n")),(0,i.mdx)("p",null,"This is useful when you need to use a read-only version of an object type you've already defined, without manually having to re-define and annotate each key as read-only. For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":10,"startColumn":9,"endLine":10,"endColumn":11,"description":"Cannot assign `42` to `props.age` because property `age` is not writable. [cannot-write]"}]','[{"startLine":10,"startColumn":9,"endLine":10,"endColumn":11,"description":"Cannot':!0,assign:!0,"`42`":!0,to:!0,"`props.age`":!0,because:!0,property:!0,"`age`":!0,is:!0,not:!0,"writable.":!0,'[cannot-write]"}]':!0},"type Props = {\n  name: string,\n  age: number,\n};\n\ntype ReadOnlyProps = $ReadOnly<Props>;\n\nfunction render(props: ReadOnlyProps) {\n  const {name, age} = props;  // Works\n  props.age = 42;             // Error!\n}\n")),(0,i.mdx)("p",null,"Additionally, other utility types, such as ",(0,i.mdx)("a",{parentName:"p",href:"../objects/#object-type-spread"},"spread"),", may strip any read/write annotations, so ",(0,i.mdx)("inlineCode",{parentName:"p"},"$ReadOnly<T>")," is a handy way to quickly make the object read-only again after operating on it:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Obj = {\n  +key: number,\n};\n\ntype MappedObj = $ReadOnly<{...Obj, foo: string}> // Still read-only\n")),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"$ReadOnly")," utility works on object and tuple types.\nIf you want to make other types read-only, you can use one of the following:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Array<T>")," -> ",(0,i.mdx)("a",{parentName:"li",href:"../arrays/#toc-readonlyarray"},(0,i.mdx)("inlineCode",{parentName:"a"},"$ReadOnlyArray<T>"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Set<T>")," -> ",(0,i.mdx)("inlineCode",{parentName:"li"},"$ReadOnlySet<T>")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Map<K, V>")," -> ",(0,i.mdx)("inlineCode",{parentName:"li"},"$ReadOnlyMap<K, V>")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"WeakSet<T>")," -> ",(0,i.mdx)("inlineCode",{parentName:"li"},"$ReadOnlyWeakSet<T>")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"WeakMap<K, V>")," -> ",(0,i.mdx)("inlineCode",{parentName:"li"},"$ReadOnlyWeakMap<K, V>"))),(0,i.mdx)("h2",{id:"toc-partial"},(0,i.mdx)("inlineCode",{parentName:"h2"},"Partial<T>"),"  ",(0,i.mdx)(o.V,{version:"0.201",mdxType:"SinceVersion"})),(0,i.mdx)("p",null,"This utility converts all of an object or interface's named fields to be optional,\nwhile maintaining all the object's other properties (e.g. exactness, variance).\nUse this utility instead of ",(0,i.mdx)("inlineCode",{parentName:"p"},"$Shape"),"."),(0,i.mdx)("p",null,"Since Flow ",(0,i.mdx)(o.V,{version:"0.212",mdxType:"SinceVersion"}),", it also converts all of a tuple type's elements to be ",(0,i.mdx)("a",{parentName:"p",href:"../tuples/#optional-tuple-elements"},"optional"),"."),(0,i.mdx)("p",null,"Example for objects:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":12,"startColumn":1,"endLine":12,"endColumn":1,"description":"Cannot cast `c` to `Person` because undefined [1] is incompatible with number [1] in property `age`. [incompatible-cast]"},{"startLine":12,"startColumn":1,"endLine":12,"endColumn":1,"description":"Cannot cast `c` to `Person` because undefined [1] is incompatible with string [1] in property `name`. [incompatible-cast]"}]','[{"startLine":12,"startColumn":1,"endLine":12,"endColumn":1,"description":"Cannot':!0,cast:!0,"`c`":!0,to:!0,"`Person`":!0,because:!0,undefined:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,in:!0,property:!0,"`age`.":!0,'[incompatible-cast]"},{"startLine":12,"startColumn":1,"endLine":12,"endColumn":1,"description":"Cannot':!0,string:!0,"`name`.":!0,'[incompatible-cast]"}]':!0},"type Person = {\n  name: string,\n  age: number,\n};\ntype PartialPerson = Partial<Person>;\n// Above equivalent to `{name?: string, age?: number}`\n\nconst a: PartialPerson = {}; // OK\nconst b: PartialPerson = {name: 'George'}; // OK\nconst c: PartialPerson = {name: 'George', age: 123}; // OK\n\nc as Person; // ERROR: `PersonDetails` is not a `Person` (unlike with `$Shape`)\n")),(0,i.mdx)("p",null,"For tuples:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type AllRequired = [number, string];\n[] as Partial<AllRequired>; // OK: like `[a?: number, b?: string]` now\n")),(0,i.mdx)("p",null,"A object or tuple of type ",(0,i.mdx)("inlineCode",{parentName:"p"},"T")," cannot be supplied to ",(0,i.mdx)("inlineCode",{parentName:"p"},"Partial<T>"),", due to mutability. You can resolve this by making the object ",(0,i.mdx)("a",{parentName:"p",href:"#toc-readonly"},"read-only"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":12,"startColumn":10,"endLine":12,"endColumn":15,"description":"Cannot call `noPerson` with `person` bound to `o` because undefined [1] is incompatible with number [1] in property `age`. This property is invariantly typed. See https://flow.org/en/docs/faq/#why-cant-i-pass-a-string-to-a-function-that-takes-a-string-number. [incompatible-call]"},{"startLine":12,"startColumn":10,"endLine":12,"endColumn":15,"description":"Cannot call `noPerson` with `person` bound to `o` because undefined [1] is incompatible with string [1] in property `name`. This property is invariantly typed. See https://flow.org/en/docs/faq/#why-cant-i-pass-a-string-to-a-function-that-takes-a-string-number. [incompatible-call]"}]','[{"startLine":12,"startColumn":10,"endLine":12,"endColumn":15,"description":"Cannot':!0,call:!0,"`noPerson`":!0,with:!0,"`person`":!0,bound:!0,to:!0,"`o`":!0,because:!0,undefined:!0,"[1]":!0,is:!0,incompatible:!0,number:!0,in:!0,property:!0,"`age`.":!0,This:!0,invariantly:!0,"typed.":!0,See:!0,"https://flow.org/en/docs/faq/#why-cant-i-pass-a-string-to-a-function-that-takes-a-string-number.":!0,'[incompatible-call]"},{"startLine":12,"startColumn":10,"endLine":12,"endColumn":15,"description":"Cannot':!0,string:!0,"`name`.":!0,'[incompatible-call]"}]':!0},"type Person = {\n  name: string,\n  age: number,\n};\n\nconst person: Person = {name: 'George', age: 123};\n\nfunction noPerson(o: Partial<Person>) {\n  // Can mutate:\n  o.name = undefined;\n}\nnoPerson(person); // Error!\n\nfunction okPerson(o: $ReadOnly<Partial<Person>>) {\n  // Can't mutate - it's read-only!\n}\nokPerson(person); // Works\n")),(0,i.mdx)("p",null,"Note: Up until Flow version 0.201, this utility type was named ",(0,i.mdx)("inlineCode",{parentName:"p"},"$Partial"),"."),(0,i.mdx)("h2",{id:"toc-required"},(0,i.mdx)("inlineCode",{parentName:"h2"},"Required<T>")," ",(0,i.mdx)(o.V,{version:"0.201",mdxType:"SinceVersion"})),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"Required")," utility type is the opposite of ",(0,i.mdx)("a",{parentName:"p",href:"#toc-partial"},(0,i.mdx)("inlineCode",{parentName:"a"},"Partial")),":\nit converts all of an object or interface\u2019s optional fields to be required."),(0,i.mdx)("p",null,"Since Flow ",(0,i.mdx)(o.V,{version:"0.212",mdxType:"SinceVersion"}),", it also converts all of a tuple type's elements to be ",(0,i.mdx)("a",{parentName:"p",href:"../tuples/#optional-tuple-elements"},"required"),"."),(0,i.mdx)("p",null,"Example for objects:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":9,"startColumn":19,"endLine":9,"endColumn":28,"description":"Cannot assign object literal to `b` because property `name` is missing in object literal [1] but exists in `PartialPerson` [2]. [prop-missing]"}]','[{"startLine":9,"startColumn":19,"endLine":9,"endColumn":28,"description":"Cannot':!0,assign:!0,object:!0,literal:!0,to:!0,"`b`":!0,because:!0,property:!0,"`name`":!0,is:!0,missing:!0,in:!0,"[1]":!0,but:!0,exists:!0,"`PartialPerson`":!0,"[2].":!0,'[prop-missing]"}]':!0},"type PartialPerson = {\n  name?: string,\n  age?: number,\n};\ntype Person = Required<PartialPerson>;\n// Above equivalent to `{name: string, age: number}`\n\nconst a: Person = {name: 'George', age: 123}; // OK\nconst b: Person = {age: 123}; // ERROR: missing `name` property\n")),(0,i.mdx)("p",null,"For tuples:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",0:!0,2:!0,className:"language-flow",metastring:'[{"startLine":2,"startColumn":1,"endLine":2,"endColumn":2,"description":"Cannot cast array literal to required of `AllOptional` because empty array literal [1] has 0 elements but `AllOptional` [2] has 2 elements. [invalid-tuple-arity]"}]','[{"startLine":2,"startColumn":1,"endLine":2,"endColumn":2,"description":"Cannot':!0,cast:!0,array:!0,literal:!0,to:!0,required:!0,of:!0,"`AllOptional`":!0,because:!0,empty:!0,"[1]":!0,has:!0,elements:!0,but:!0,"[2]":!0,"elements.":!0,'[invalid-tuple-arity]"}]':!0},"type AllOptional = [a?: number, b?: string];\n[] as Required<AllOptional>; // ERROR: like `[a: number, b: string]` now\n")),(0,i.mdx)("h2",{id:"toc-return-type"},(0,i.mdx)("inlineCode",{parentName:"h2"},"ReturnType<F>")," ",(0,i.mdx)(o.V,{version:"0.209",mdxType:"SinceVersion"})),(0,i.mdx)("p",null,"This utility type extracts the return type from a given function type."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":4,"startColumn":1,"endLine":4,"endColumn":1,"description":"Cannot cast `1` to `Bool` because number [1] is incompatible with boolean [2]. [incompatible-cast]"}]','[{"startLine":4,"startColumn":1,"endLine":4,"endColumn":1,"description":"Cannot':!0,cast:!0,"`1`":!0,to:!0,"`Bool`":!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,boolean:!0,"[2].":!0,'[incompatible-cast]"}]':!0},"declare function f(s: string, n: number): boolean;\ntype Bool = ReturnType<typeof f>;\ntrue as Bool;\n1 as Bool; // Error: number is not boolean\n")),(0,i.mdx)("h2",{id:"toc-parameters"},(0,i.mdx)("inlineCode",{parentName:"h2"},"Parameters<F>")," ",(0,i.mdx)(o.V,{version:"0.209",mdxType:"SinceVersion"})),(0,i.mdx)("p",null,"This utility type extracts the parameter types from a given function type into a ",(0,i.mdx)("a",{parentName:"p",href:"../tuples/"},"tuple type"),"."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",2:!0,className:"language-flow",metastring:'[{"startLine":5,"startColumn":16,"endLine":5,"endColumn":16,"description":"Cannot access number literal `2` on `Tuple` because tuple type [1] only has 2 elements, so index 2 is out of bounds. [invalid-tuple-index]"}]','[{"startLine":5,"startColumn":16,"endLine":5,"endColumn":16,"description":"Cannot':!0,access:!0,number:!0,literal:!0,"`2`":!0,on:!0,"`Tuple`":!0,because:!0,tuple:!0,type:!0,"[1]":!0,only:!0,has:!0,"elements,":!0,so:!0,index:!0,is:!0,out:!0,of:!0,"bounds.":!0,'[invalid-tuple-index]"}]':!0},"declare function f(s: string, n: number): boolean;\ntype Tuple = Parameters<typeof f>; // Evaluates to [string, number]\n's' as Tuple[0];\n1 as Tuple[1];\nfalse as Tuple[2]; // Error: tuple type only has two elements\n")),(0,i.mdx)("h2",{id:"toc-exclude"},(0,i.mdx)("inlineCode",{parentName:"h2"},"Exclude<T, U>")," ",(0,i.mdx)(o.V,{version:"0.209",mdxType:"SinceVersion"})),(0,i.mdx)("p",null,"This utility type excludes all subtypes of ",(0,i.mdx)("inlineCode",{parentName:"p"},"U")," from ",(0,i.mdx)("inlineCode",{parentName:"p"},"T"),"."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":2,"startColumn":1,"endLine":2,"endColumn":1,"description":"Cannot cast `1` to `T` because number [1] is incompatible with union type [2]. [incompatible-cast]"},{"startLine":4,"startColumn":1,"endLine":4,"endColumn":1,"description":"Cannot cast `3` to `T` because number [1] is incompatible with union type [2]. [incompatible-cast]"}]','[{"startLine":2,"startColumn":1,"endLine":2,"endColumn":1,"description":"Cannot':!0,cast:!0,"`1`":!0,to:!0,"`T`":!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,union:!0,type:!0,"[2].":!0,'[incompatible-cast]"},{"startLine":4,"startColumn":1,"endLine":4,"endColumn":1,"description":"Cannot':!0,"`3`":!0,'[incompatible-cast]"}]':!0},"type T = Exclude<1 | 2 | 3 | 4, 1 | 3>; // evaluates to 2 | 4\n1 as T; // error\n2 as T; // ok\n3 as T; // error\n4 as T; // ok\n")),(0,i.mdx)("h2",{id:"toc-extract"},(0,i.mdx)("inlineCode",{parentName:"h2"},"Extract<T, U>")," ",(0,i.mdx)(o.V,{version:"0.209",mdxType:"SinceVersion"})),(0,i.mdx)("p",null,"This utility type retains only subtypes of ",(0,i.mdx)("inlineCode",{parentName:"p"},"U")," from ",(0,i.mdx)("inlineCode",{parentName:"p"},"T"),"."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":1,"endLine":6,"endColumn":9,"description":"Cannot cast `new Car()` to `T` because: [incompatible-cast] Either `Car` [1] is incompatible with `Dog` [2]. Or `Car` [1] is incompatible with `Cat` [3]."}]','[{"startLine":6,"startColumn":1,"endLine":6,"endColumn":9,"description":"Cannot':!0,cast:!0,"`new":!0,"Car()`":!0,to:!0,"`T`":!0,"because:":!0,"[incompatible-cast]":!0,Either:!0,"`Car`":!0,"[1]":!0,is:!0,incompatible:!0,with:!0,"`Dog`":!0,"[2].":!0,Or:!0,"`Cat`":!0,'[3]."}]':!0},"declare class Car {}\ndeclare class Animal {}\ndeclare class Dog extends Animal {}\ndeclare class Cat extends Animal {}\ntype T = Extract<Car | Dog | Cat, Animal>; // evaluates to Dog | Cat\nnew Car() as T; // error\nnew Dog() as T; // ok\nnew Cat() as T; // ok\n")),(0,i.mdx)("h2",{id:"toc-this-parameter-type"},(0,i.mdx)("inlineCode",{parentName:"h2"},"ThisParameterType<F>")," ",(0,i.mdx)(o.V,{version:"0.209",mdxType:"SinceVersion"})),(0,i.mdx)("p",null,"This utility type extracts the type of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"this")," parameter of a given function type."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":2,"startColumn":1,"endLine":2,"endColumn":3,"description":"Cannot cast `\'1\'` to `T` because string [1] is incompatible with number [2]. [incompatible-cast]"}]','[{"startLine":2,"startColumn":1,"endLine":2,"endColumn":3,"description":"Cannot':!0,cast:!0,"`'1'`":!0,to:!0,"`T`":!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,"[2].":!0,'[incompatible-cast]"}]':!0},"type T = ThisParameterType<(this: number, bar: string) => void>; // Evaluates to number\n'1' as T; // error\n2 as T; // ok\n")),(0,i.mdx)("h2",{id:"toc-omit-this-parameter-type"},(0,i.mdx)("inlineCode",{parentName:"h2"},"OmitThisParameter<F>")," ",(0,i.mdx)(o.V,{version:"0.209",mdxType:"SinceVersion"})),(0,i.mdx)("p",null,"This utility type removes the ",(0,i.mdx)("inlineCode",{parentName:"p"},"this")," parameter from a given function type."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":1,"endLine":6,"endColumn":12,"description":"Cannot call `hasThisParam` because global object [1] is incompatible with number [2]. [incompatible-call]"}]','[{"startLine":6,"startColumn":1,"endLine":6,"endColumn":12,"description":"Cannot':!0,call:!0,"`hasThisParam`":!0,because:!0,global:!0,object:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,"[2].":!0,'[incompatible-call]"}]':!0},"type HasThisParamFun = (this: number, bar: string) => void;\ntype NoThisParamFun = OmitThisParameter<HasThisParamFun> // Evaluates to (bar: string) => void\ndeclare const hasThisParam: HasThisParamFun;\ndeclare const noThisParam: NoThisParamFun;\n\nhasThisParam(''); // error: global object is not number\nnoThisParam(''); // ok: no this type requirement\n")),(0,i.mdx)("h2",{id:"toc-pick"},(0,i.mdx)("inlineCode",{parentName:"h2"},"Pick<O, Keys>")," ",(0,i.mdx)(o.V,{version:"0.211",mdxType:"SinceVersion"})),(0,i.mdx)("p",null,"This utility type allows you to generate an object type using a subset of the fields from\nanother object type."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":5,"startColumn":11,"endLine":5,"endColumn":13,"description":"Cannot get `fooAndBar.baz` because property `baz` (did you mean `bar`?) is missing in `Pick` [1]. [prop-missing]"}]','[{"startLine":5,"startColumn":11,"endLine":5,"endColumn":13,"description":"Cannot':!0,get:!0,"`fooAndBar.baz`":!0,because:!0,property:!0,"`baz`":!0,"(did":!0,you:!0,mean:!0,"`bar`?)":!0,is:!0,missing:!0,in:!0,"`Pick`":!0,"[1].":!0,'[prop-missing]"}]':!0},"type O = {foo: number, bar: string, baz: boolean};\ntype FooAndBar = Pick<O, 'foo' | 'bar'>;\n\ndeclare const fooAndBar: FooAndBar;\nfooAndBar.baz; // error: baz is missing\nfooAndBar.foo as number; // ok\nfooAndBar.bar as string; // ok\n")),(0,i.mdx)("h2",{id:"toc-omit"},(0,i.mdx)("inlineCode",{parentName:"h2"},"Omit<O, Keys>")," ",(0,i.mdx)(o.V,{version:"0.211",mdxType:"SinceVersion"})),(0,i.mdx)("p",null,"This utility type allows you to generate an object type by omitting the specified fields from\nanother object type."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":9,"endLine":6,"endColumn":11,"description":"Cannot get `justBaz.foo` because property `foo` is missing in `Omit` [1]. [prop-missing]"},{"startLine":7,"startColumn":9,"endLine":7,"endColumn":11,"description":"Cannot get `justBaz.bar` because property `bar` (did you mean `baz`?) is missing in `Omit` [1]. [prop-missing]"}]','[{"startLine":6,"startColumn":9,"endLine":6,"endColumn":11,"description":"Cannot':!0,get:!0,"`justBaz.foo`":!0,because:!0,property:!0,"`foo`":!0,is:!0,missing:!0,in:!0,"`Omit`":!0,"[1].":!0,'[prop-missing]"},{"startLine":7,"startColumn":9,"endLine":7,"endColumn":11,"description":"Cannot':!0,"`justBaz.bar`":!0,"`bar`":!0,"(did":!0,you:!0,mean:!0,"`baz`?)":!0,'[prop-missing]"}]':!0},"type O = {foo: number, bar: string, baz: boolean};\ntype JustBaz= Omit<O, 'foo' | 'bar'>;\n\ndeclare const justBaz: JustBaz;\njustBaz.baz as boolean; // ok\njustBaz.foo; // error: missing foo\njustBaz.bar; // error: missing bar\n")),(0,i.mdx)("h2",{id:"toc-record"},(0,i.mdx)("inlineCode",{parentName:"h2"},"Record<Keys, Type>")," ",(0,i.mdx)(o.V,{version:"0.211",mdxType:"SinceVersion"})),(0,i.mdx)("p",null,"This utility type allows you to generate an object type from a union of keys with the given\n",(0,i.mdx)("inlineCode",{parentName:"p"},"Type")," for each field."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":5,"startColumn":14,"endLine":5,"endColumn":16,"description":"Cannot get `numberRecord.baz` because property `baz` (did you mean `bar`?) is missing in `Record` [1]. [prop-missing]"}]','[{"startLine":5,"startColumn":14,"endLine":5,"endColumn":16,"description":"Cannot':!0,get:!0,"`numberRecord.baz`":!0,because:!0,property:!0,"`baz`":!0,"(did":!0,you:!0,mean:!0,"`bar`?)":!0,is:!0,missing:!0,in:!0,"`Record`":!0,"[1].":!0,'[prop-missing]"}]':!0},"type NumberRecord = Record<'foo' | 'bar', number>;\ndeclare const numberRecord: NumberRecord;\nnumberRecord.foo as number; // ok\nnumberRecord.bar as number; // ok\nnumberRecord.baz; // error\n")),(0,i.mdx)("p",null,"Note that ",(0,i.mdx)("inlineCode",{parentName:"p"},"Record")," is different than using an indexer:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",2:!0,className:"language-flow",metastring:'[{"startLine":5,"startColumn":12,"endLine":5,"endColumn":17,"description":"Cannot use `Record` [1] without 2 type arguments. [missing-type-arg]"}]','[{"startLine":5,"startColumn":12,"endLine":5,"endColumn":17,"description":"Cannot':!0,use:!0,"`Record`":!0,"[1]":!0,without:!0,type:!0,"arguments.":!0,'[missing-type-arg]"}]':!0},"type NumberRecord = Record<'foo' | 'bar', number>;\ntype IndexedObject = {['foo' | 'bar']: number};\n\n// Record uses explicit fields, which means they are all required\nconst rec: Record = {}; // error\n// Indexers do not have this same requirement\nconst idx: IndexedObject = {}; // no error\n")),(0,i.mdx)("h2",{id:"toc-exact"},(0,i.mdx)("inlineCode",{parentName:"h2"},"$Exact<T>")),(0,i.mdx)("p",null,"You can use ",(0,i.mdx)("inlineCode",{parentName:"p"},"$Exact")," to make an ",(0,i.mdx)("a",{parentName:"p",href:"../objects/#exact-and-inexact-object-types"},"inexact object type")," exact:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type InexactUser = {name: string, ...};\ntype ExactUser = $Exact<InexactUser>;\n\nconst user = {name: 'John Wilkes Booth'};\n// These will both be satisfied because they are equivalent:\nconst a: ExactUser = user;\nconst b: {name: string} = user;\n")),(0,i.mdx)("p",null,"This is an utility type to avoid, as it's clearer and more concinse to start off with an exact object type and make it inexact using ",(0,i.mdx)("a",{parentName:"p",href:"../objects/#object-type-spread"},"object type spread"),"\n(if you wish to have both inexact and exact variants of one object type):"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type ExactUser = {name: string};\ntype InexactUser = {...ExactUser, ...};\n\nconst user = {name: 'John Wilkes Booth'};\nconst a: ExactUser = user;\n")),(0,i.mdx)("h2",{id:"toc-diff"},(0,i.mdx)("inlineCode",{parentName:"h2"},"$Diff<A, B>")),(0,i.mdx)("p",null,"As the name hints, ",(0,i.mdx)("inlineCode",{parentName:"p"},"$Diff<A, B>")," is the type representing the set difference of ",(0,i.mdx)("inlineCode",{parentName:"p"},"A")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"B"),", i.e. ",(0,i.mdx)("inlineCode",{parentName:"p"},"A \\ B"),", where ",(0,i.mdx)("inlineCode",{parentName:"p"},"A")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"B")," are both ",(0,i.mdx)("a",{parentName:"p",href:"../objects/"},"object types"),". Here's an example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":11,"startColumn":10,"endLine":11,"endColumn":18,"description":"Cannot call `setProps` with object literal bound to `props` because property `name` is missing in object literal [1] but exists in `Props` [2]. [prop-missing]"}]','[{"startLine":11,"startColumn":10,"endLine":11,"endColumn":18,"description":"Cannot':!0,call:!0,"`setProps`":!0,with:!0,object:!0,literal:!0,bound:!0,to:!0,"`props`":!0,because:!0,property:!0,"`name`":!0,is:!0,missing:!0,in:!0,"[1]":!0,but:!0,exists:!0,"`Props`":!0,"[2].":!0,'[prop-missing]"}]':!0},"type Props = {name: string, age: number, ...};\ntype DefaultProps = {age: number};\ntype RequiredProps = $Diff<Props, DefaultProps>;\n\nfunction setProps(props: RequiredProps) {\n  // ...\n}\n\nsetProps({name: 'foo'}); // Works\nsetProps({name: 'foo', age: 42, baz: false}); // Works, you can pass extra props too\nsetProps({age: 42}); // Error! `name` is required\n")),(0,i.mdx)("p",null,"As you may have noticed, the example is not a random one.\n",(0,i.mdx)("inlineCode",{parentName:"p"},"$Diff")," is exactly what the React definition file uses to define the type of the props accepted by a React Component."),(0,i.mdx)("p",null,"Note that ",(0,i.mdx)("inlineCode",{parentName:"p"},"$Diff<A, B>")," will error if the object you are removing properties from does not have the property being removed, i.e. if ",(0,i.mdx)("inlineCode",{parentName:"p"},"B")," has a key that doesn't exist in ",(0,i.mdx)("inlineCode",{parentName:"p"},"A"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":28,"endLine":3,"endColumn":32,"description":"Cannot instantiate `$Diff` because undefined property `other` [1] is incompatible with string [2]. [incompatible-type]"}]','[{"startLine":3,"startColumn":28,"endLine":3,"endColumn":32,"description":"Cannot':!0,instantiate:!0,"`$Diff`":!0,because:!0,undefined:!0,property:!0,"`other`":!0,"[1]":!0,is:!0,incompatible:!0,with:!0,string:!0,"[2].":!0,'[incompatible-type]"}]':!0},"type Props = {name: string, age: number};\ntype DefaultProps = {age: number, other: string};\ntype RequiredProps = $Diff<Props, DefaultProps>; // Error!\n\nfunction setProps(props: RequiredProps) {\n  props.name;\n  // ...\n}\n")),(0,i.mdx)("p",null,"As a workaround, you can specify the property not present in ",(0,i.mdx)("inlineCode",{parentName:"p"},"A")," as optional. For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":16,"endLine":1,"endColumn":17,"description":"Cannot instantiate `$Diff` because undefined property `nope` [1] is incompatible with number [2]. [incompatible-type]"}]','[{"startLine":1,"startColumn":16,"endLine":1,"endColumn":17,"description":"Cannot':!0,instantiate:!0,"`$Diff`":!0,because:!0,undefined:!0,property:!0,"`nope`":!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,"[2].":!0,'[incompatible-type]"}]':!0},"type A = $Diff<{}, {nope: number}>; // Error!\ntype B = $Diff<{}, {nope: number | void}>; // Works\n\nconst a: A = {};\nconst b: B = {};\n")),(0,i.mdx)("h2",{id:"toc-rest"},(0,i.mdx)("inlineCode",{parentName:"h2"},"$Rest<A, B>")),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"$Rest<A, B>")," is the type that represents the runtime object rest operation, e.g.: ",(0,i.mdx)("inlineCode",{parentName:"p"},"const {foo, ...rest} = obj"),", where ",(0,i.mdx)("inlineCode",{parentName:"p"},"A")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"B")," are both ",(0,i.mdx)("a",{parentName:"p",href:"../objects/"},"object types"),".\nThe resulting type from this operation will be an object type containing ",(0,i.mdx)("inlineCode",{parentName:"p"},"A"),"'s ",(0,i.mdx)("em",{parentName:"p"},"own")," properties that are not ",(0,i.mdx)("em",{parentName:"p"},"own")," properties in ",(0,i.mdx)("inlineCode",{parentName:"p"},"B"),".\nIn flow, we treat all properties on ",(0,i.mdx)("a",{parentName:"p",href:"../objects/#exact-and-inexact-object-types"},"exact object types")," as ",(0,i.mdx)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"},"own"),".\nFor inexact objects, a property may or may not be own."),(0,i.mdx)("p",null,"For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":12,"endLine":6,"endColumn":14,"description":"Cannot get `otherProps.age` because property `age` is missing in rest of object pattern [1]. [prop-missing]"}]','[{"startLine":6,"startColumn":12,"endLine":6,"endColumn":14,"description":"Cannot':!0,get:!0,"`otherProps.age`":!0,because:!0,property:!0,"`age`":!0,is:!0,missing:!0,in:!0,rest:!0,of:!0,object:!0,pattern:!0,"[1].":!0,'[prop-missing]"}]':!0},"type Props = {name: string, age: number};\n\nconst props: Props = {name: 'Jon', age: 42};\nconst {age, ...otherProps} = props;\notherProps as $Rest<Props, {age: number}>;\notherProps.age;  // Error!\n")),(0,i.mdx)("p",null,"The main difference with ",(0,i.mdx)("a",{parentName:"p",href:"#toc-diff"},(0,i.mdx)("inlineCode",{parentName:"a"},"$Diff<A, B>")),", is that ",(0,i.mdx)("inlineCode",{parentName:"p"},"$Rest<A, B>")," aims to represent the true runtime rest operation,\nwhich implies that exact object types are treated differently in ",(0,i.mdx)("inlineCode",{parentName:"p"},"$Rest<A, B>"),".\nFor example, ",(0,i.mdx)("inlineCode",{parentName:"p"},"$Rest<{n: number}, {...}>")," will result in ",(0,i.mdx)("inlineCode",{parentName:"p"},"{n?: number}")," because an in-exact empty object may have an ",(0,i.mdx)("inlineCode",{parentName:"p"},"n")," property,\nwhile ",(0,i.mdx)("inlineCode",{parentName:"p"},"$Diff<{n: number}, {...}>")," will result in ",(0,i.mdx)("inlineCode",{parentName:"p"},"{n: number}"),"."),(0,i.mdx)("h2",{id:"toc-nonmaybe"},(0,i.mdx)("inlineCode",{parentName:"h2"},"$NonMaybeType<T>")),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"$NonMaybeType<T>")," converts a type ",(0,i.mdx)("inlineCode",{parentName:"p"},"T")," to a non-",(0,i.mdx)("a",{parentName:"p",href:"../maybe"},"maybe type"),".\nIn other words, the values of ",(0,i.mdx)("inlineCode",{parentName:"p"},"$NonMaybeType<T>")," are the values of ",(0,i.mdx)("inlineCode",{parentName:"p"},"T")," except for ",(0,i.mdx)("inlineCode",{parentName:"p"},"null")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"undefined"),"."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":7,"startColumn":1,"endLine":7,"endColumn":4,"description":"Cannot cast `null` to `Name` because null [1] is incompatible with string [2]. [incompatible-cast]"}]','[{"startLine":7,"startColumn":1,"endLine":7,"endColumn":4,"description":"Cannot':!0,cast:!0,"`null`":!0,to:!0,"`Name`":!0,because:!0,null:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,string:!0,"[2].":!0,'[incompatible-cast]"}]':!0},"type MaybeName = ?string;\ntype Name = $NonMaybeType<MaybeName>;\n\n'Gabriel' as MaybeName; // Works\nnull as MaybeName; // Works\n'Gabriel' as Name; // Works\nnull as Name; // Error! `null` can't be annotated as Name because Name is not a maybe type\n")),(0,i.mdx)("h2",{id:"toc-keymirror"},(0,i.mdx)("inlineCode",{parentName:"h2"},"$KeyMirror<O>")),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"$KeyMirror<Obj>")," is a special case of ",(0,i.mdx)("inlineCode",{parentName:"p"},"$ObjMapi<Obj, F>"),", when ",(0,i.mdx)("inlineCode",{parentName:"p"},"F")," is the identity\nfunction type, ie. ",(0,i.mdx)("inlineCode",{parentName:"p"},"<K>(K) => K"),". In other words, it maps each property of an object\nto the type of the property key. Instead of writing ",(0,i.mdx)("inlineCode",{parentName:"p"},"$ObjMapi<Obj, <K>(K) => K>"),",\nyou can write ",(0,i.mdx)("inlineCode",{parentName:"p"},"$KeyMirror<Obj>"),". For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":12,"startColumn":1,"endLine":12,"endColumn":8,"description":"Cannot cast `newObj.b` to string literal `a` because string literal `b` [1] is incompatible with string literal `a` [2]. [incompatible-cast]"}]','[{"startLine":12,"startColumn":1,"endLine":12,"endColumn":8,"description":"Cannot':!0,cast:!0,"`newObj.b`":!0,to:!0,string:!0,literal:!0,"`a`":!0,because:!0,"`b`":!0,"[1]":!0,is:!0,incompatible:!0,with:!0,"[2].":!0,'[incompatible-cast]"}]':!0},"const obj = {\n  a: true,\n  b: 'foo'\n};\n\ndeclare function run<O: {...}>(o: O): $KeyMirror<O>;\n\n// newObj is of type {a: 'a', b: 'b'}\nconst newObj = run(obj);\n\nnewObj.a as 'a'; // Works\nnewObj.b as 'a'; // Error! String 'b' is incompatible with 'a'\n")),(0,i.mdx)("p",null,"Tip: Prefer using ",(0,i.mdx)("inlineCode",{parentName:"p"},"$KeyMirror")," instead of ",(0,i.mdx)("inlineCode",{parentName:"p"},"$ObjMapi")," (if possible) to fix certain\nkinds of ",(0,i.mdx)("inlineCode",{parentName:"p"},"[invalid-exported-annotation]")," errors."),(0,i.mdx)("h2",{id:"toc-tuplemap"},(0,i.mdx)("inlineCode",{parentName:"h2"},"$TupleMap<T, F>")),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"$TupleMap<T, F>")," takes an iterable type ",(0,i.mdx)("inlineCode",{parentName:"p"},"T")," (e.g.: ",(0,i.mdx)("a",{parentName:"p",href:"../tuples"},(0,i.mdx)("inlineCode",{parentName:"a"},"Tuple"))," or ",(0,i.mdx)("a",{parentName:"p",href:"../arrays"},(0,i.mdx)("inlineCode",{parentName:"a"},"Array")),"), and a ",(0,i.mdx)("a",{parentName:"p",href:"../functions"},"function type")," ",(0,i.mdx)("inlineCode",{parentName:"p"},"F"),",\nand returns the iterable type obtained by mapping the type of each value in the iterable with the provided function type ",(0,i.mdx)("inlineCode",{parentName:"p"},"F"),".\nThis is analogous to the JavaScript function ",(0,i.mdx)("inlineCode",{parentName:"p"},"map"),"."),(0,i.mdx)("p",null,"Following our example from ",(0,i.mdx)("a",{parentName:"p",href:"#toc-objmap"},(0,i.mdx)("inlineCode",{parentName:"a"},"$ObjMap<T>")),", let's assume that ",(0,i.mdx)("inlineCode",{parentName:"p"},"run")," takes an array of functions, instead of an object, and maps over them returning an array of the function call results. We could annotate its return type like this:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":11,"startColumn":1,"endLine":11,"endColumn":11,"description":"Cannot cast `run(...)[1]` to boolean because string [1] is incompatible with boolean [2]. [incompatible-cast]"}]','[{"startLine":11,"startColumn":1,"endLine":11,"endColumn":11,"description":"Cannot':!0,cast:!0,"`run(...)[1]`":!0,to:!0,boolean:!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,"[2].":!0,'[incompatible-cast]"}]':!0},"// Function type that takes a `() => V` and returns a `V` (its return type)\ntype ExtractReturnType = <V>(() => V) => V\n\nfunction run<A, I: Array<() => A>>(iter: I): $TupleMap<I, ExtractReturnType> {\n  return iter.map(fn => fn());\n}\n\nconst arr = [() => 'foo', () => 'bar'];\nrun(arr)[0] as string; // Works\nrun(arr)[1] as string; // Works\nrun(arr)[1] as boolean; // Error!\n")),(0,i.mdx)("h2",{id:"toc-class"},(0,i.mdx)("inlineCode",{parentName:"h2"},"Class<T>")),(0,i.mdx)("p",null,"Given a type ",(0,i.mdx)("inlineCode",{parentName:"p"},"T")," representing instances of a class ",(0,i.mdx)("inlineCode",{parentName:"p"},"C"),", the type ",(0,i.mdx)("inlineCode",{parentName:"p"},"Class<T>")," is the type of the class ",(0,i.mdx)("inlineCode",{parentName:"p"},"C"),".\nFor example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":11,"startColumn":1,"endLine":11,"endColumn":16,"description":"Cannot cast `makeStore(...)` to `Model` because `Store` [1] is incompatible with `Model` [2]. [incompatible-cast]"},{"startLine":11,"startColumn":11,"endLine":11,"endColumn":15,"description":"Cannot call `makeStore` with `Model` bound to `storeClass` because `Model` [1] is incompatible with `Store` [2]. [incompatible-call]"}]','[{"startLine":11,"startColumn":1,"endLine":11,"endColumn":16,"description":"Cannot':!0,cast:!0,"`makeStore(...)`":!0,to:!0,"`Model`":!0,because:!0,"`Store`":!0,"[1]":!0,is:!0,incompatible:!0,with:!0,"[2].":!0,'[incompatible-cast]"},{"startLine":11,"startColumn":11,"endLine":11,"endColumn":15,"description":"Cannot':!0,call:!0,"`makeStore`":!0,bound:!0,"`storeClass`":!0,'[incompatible-call]"}]':!0},"class Store {}\nclass ExtendedStore extends Store {}\nclass Model {}\n\nfunction makeStore(storeClass: Class<Store>) {\n  return new storeClass();\n}\n\nmakeStore(Store) as Store;\nmakeStore(ExtendedStore) as Store;\nmakeStore(Model) as Model; // Error!\n")),(0,i.mdx)("p",null,"For classes that take type parameters, you must also provide the parameter. For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":9,"startColumn":28,"endLine":9,"endColumn":28,"description":"Cannot call `makeParamStore` with `1` bound to `data` because number [1] is incompatible with boolean [2]. [incompatible-call]"}]','[{"startLine":9,"startColumn":28,"endLine":9,"endColumn":28,"description":"Cannot':!0,call:!0,"`makeParamStore`":!0,with:!0,"`1`":!0,bound:!0,to:!0,"`data`":!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,boolean:!0,"[2].":!0,'[incompatible-call]"}]':!0},"class ParamStore<T> {\n  constructor(data: T) {}\n}\n\nfunction makeParamStore<T>(storeClass: Class<ParamStore<T>>, data: T): ParamStore<T> {\n  return new storeClass(data);\n}\nmakeParamStore(ParamStore, 1) as ParamStore<number>;\nmakeParamStore(ParamStore, 1) as ParamStore<boolean>; // Error!\n")),(0,i.mdx)("h2",{id:"toc-exports"},(0,i.mdx)("inlineCode",{parentName:"h2"},"$Exports<T>")),(0,i.mdx)("p",null,"The following are functionally equivalent"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"import typeof * as T from 'my-module';\n")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"type T = $Exports<'my-module'>;\n")),(0,i.mdx)("p",null,"The advantage of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"$Exports")," syntax is that you can ",(0,i.mdx)("inlineCode",{parentName:"p"},"export")," the type on the same line"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"export type T = $Exports<'my-module'>;\n")),(0,i.mdx)("p",null,"where as you would otherwise need to export an alias in the ",(0,i.mdx)("inlineCode",{parentName:"p"},"import typeof")," case"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"import typeof * as T from 'my-module';\nexport type MyModuleType = T;\n")),(0,i.mdx)("h2",{id:"stringprefix-and-stringsuffix-"},(0,i.mdx)("inlineCode",{parentName:"h2"},"StringPrefix")," and ",(0,i.mdx)("inlineCode",{parentName:"h2"},"StringSuffix")," ",(0,i.mdx)(o.V,{version:"0.242",mdxType:"SinceVersion"})),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"StringPrefix")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"StringSuffix")," types represent strings with the specified prefix or suffix, respectively.\nTheir first type argument must be a string literal type, representing the prefix or suffix."),(0,i.mdx)("p",null,"You could use ",(0,i.mdx)("inlineCode",{parentName:"p"},"StringPrefix")," to define a type that accepts strings which start with ",(0,i.mdx)("inlineCode",{parentName:"p"},"data-"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":4,"startColumn":1,"endLine":4,"endColumn":15,"description":"Cannot cast `\'random string\'` to `DataProp` because string [1] is incompatible with string prefixed with `data-` [2]. [incompatible-cast]"}]','[{"startLine":4,"startColumn":1,"endLine":4,"endColumn":15,"description":"Cannot':!0,cast:!0,"`'random":!0,"string'`":!0,to:!0,"`DataProp`":!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,prefixed:!0,"`data-`":!0,"[2].":!0,'[incompatible-cast]"}]':!0},"type DataProp = StringPrefix<'data-'>;\n'data-foo' as DataProp; // OK\n'data-bar' as DataProp; // OK\n'random string' as DataProp; // ERROR\n")),(0,i.mdx)("p",null,"You could use ",(0,i.mdx)("inlineCode",{parentName:"p"},"StringSuffix")," to define a type that accepts strings which end with ",(0,i.mdx)("inlineCode",{parentName:"p"},"!"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":4,"startColumn":1,"endLine":4,"endColumn":15,"description":"Cannot cast `\'random string\'` to `Exclaim` because string [1] is incompatible with string suffixed with `!` [2]. [incompatible-cast]"}]','[{"startLine":4,"startColumn":1,"endLine":4,"endColumn":15,"description":"Cannot':!0,cast:!0,"`'random":!0,"string'`":!0,to:!0,"`Exclaim`":!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,suffixed:!0,"`!`":!0,"[2].":!0,'[incompatible-cast]"}]':!0},"type Exclaim = StringSuffix<'!'>;\n'yay!' as Exclaim; // OK\n'woo!' as Exclaim; // OK\n'random string' as Exclaim; // ERROR\n")),(0,i.mdx)("p",null,"You can combine these with ",(0,i.mdx)("a",{parentName:"p",href:"../intersections"},"intersection types"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":1,"endLine":3,"endColumn":15,"description":"Cannot cast `\'random string\'` to `CSSVar` because string [1] is incompatible with string prefixed with `var(--` [2]. [incompatible-cast]"},{"startLine":3,"startColumn":1,"endLine":3,"endColumn":15,"description":"Cannot cast `\'random string\'` to `CSSVar` because string [1] is incompatible with string suffixed with `)` [2]. [incompatible-cast]"}]','[{"startLine":3,"startColumn":1,"endLine":3,"endColumn":15,"description":"Cannot':!0,cast:!0,"`'random":!0,"string'`":!0,to:!0,"`CSSVar`":!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,prefixed:!0,"`var(--`":!0,"[2].":!0,'[incompatible-cast]"},{"startLine":3,"startColumn":1,"endLine":3,"endColumn":15,"description":"Cannot':!0,suffixed:!0,"`)`":!0,'[incompatible-cast]"}]':!0},"type CSSVar = StringPrefix<'var(--'> & StringSuffix<')'>;\n'var(--color)' as CSSVar; // OK\n'random string' as CSSVar; // ERROR\n")),(0,i.mdx)("p",null,"Both utilities accept an optional second type argument, which is the type of the remainder:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":4,"startColumn":1,"endLine":4,"endColumn":6,"description":"Cannot cast `\'$999\'` to `Price` because string with prefix `$` removed [1] is incompatible with union type [2]. [incompatible-cast]"}]','[{"startLine":4,"startColumn":1,"endLine":4,"endColumn":6,"description":"Cannot':!0,cast:!0,"`'$999'`":!0,to:!0,"`Price`":!0,because:!0,string:!0,with:!0,prefix:!0,"`$`":!0,removed:!0,"[1]":!0,is:!0,incompatible:!0,union:!0,type:!0,"[2].":!0,'[incompatible-cast]"}]':!0},"type Price = StringPrefix<'$', '1' | '2'>;\n'$1' as Price; // OK\n'$2' as Price; // OK\n'$999' as Price; // ERROR\n")),(0,i.mdx)("p",null,"When not specified, the type of the remainder is just ",(0,i.mdx)("inlineCode",{parentName:"p"},"string"),"."),(0,i.mdx)("h2",{id:"deprecated-utility-types"},"Deprecated utility types"),(0,i.mdx)("h3",{id:"toc-propertytype"},(0,i.mdx)("inlineCode",{parentName:"h3"},"$PropertyType<T, k>")),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"WARNING:")," ",(0,i.mdx)("inlineCode",{parentName:"p"},"$PropertyType")," is deprecated as of Flow version 0.155, and will be removed in a future version of Flow."),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"$PropertyType<T, 'k'>")," is equivalent to the ",(0,i.mdx)("inlineCode",{parentName:"p"},"T['k']")," ",(0,i.mdx)("a",{parentName:"p",href:"../indexed-access"},"indexed access type"),"."),(0,i.mdx)("h3",{id:"toc-elementtype"},(0,i.mdx)("inlineCode",{parentName:"h3"},"$ElementType<T, K>")),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"WARNING:")," ",(0,i.mdx)("inlineCode",{parentName:"p"},"$ElementType")," is deprecated as of Flow version 0.155, and will be removed in a future version of Flow."),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"$ElementType<T, K>")," is equivalent to the ",(0,i.mdx)("inlineCode",{parentName:"p"},"T[K]")," ",(0,i.mdx)("a",{parentName:"p",href:"../indexed-access"},"indexed access type"),"."),(0,i.mdx)("h3",{id:"toc-call"},(0,i.mdx)("inlineCode",{parentName:"h3"},"$Call<F, T...>")),(0,i.mdx)("p",null,"NOTE: ",(0,i.mdx)("strong",{parentName:"p"},"Deprecated!")," This utility is deprecated as of Flow version 0.208 - please use ",(0,i.mdx)("a",{parentName:"p",href:"../conditional"},"Conditional Types")," or ",(0,i.mdx)("a",{parentName:"p",href:"../indexed-access"},"Indexed Access Types")," to extract types instead."),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"$Call<F, T...>")," is a type that represents the result of calling the given ",(0,i.mdx)("a",{parentName:"p",href:"../functions"},"function type")," ",(0,i.mdx)("inlineCode",{parentName:"p"},"F")," with 0 or more arguments ",(0,i.mdx)("inlineCode",{parentName:"p"},"T..."),".\nThis is analogous to calling a function at runtime (or more specifically, it's analogous to calling ",(0,i.mdx)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"},(0,i.mdx)("inlineCode",{parentName:"a"},"Function.prototype.call")),"), but at the type level; this means that function type calls happens statically, i.e. not at runtime."),(0,i.mdx)("p",null,"Let's see a couple of examples:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":4,"startColumn":17,"endLine":4,"endColumn":43,"description":"Deprecated type. Use conditional types instead. See https://flow.org/en/docs/types/conditional/ for more information on conditional types. [deprecated-type]"},{"startLine":5,"startColumn":36,"endLine":5,"endColumn":49,"description":"Cannot instantiate `$Call` because property `prop` is missing in object type [1] but exists in object type [2] in the first argument. [prop-missing]"},{"startLine":5,"startColumn":13,"endLine":5,"endColumn":50,"description":"Deprecated type. Use conditional types instead. See https://flow.org/en/docs/types/conditional/ for more information on conditional types. [deprecated-type]"},{"startLine":8,"startColumn":1,"endLine":8,"endColumn":4,"description":"Cannot cast `true` to `PropType` because boolean [1] is incompatible with number [2]. [incompatible-cast]"}]','[{"startLine":4,"startColumn":17,"endLine":4,"endColumn":43,"description":"Deprecated':!0,"type.":!0,Use:!0,conditional:!0,types:!0,"instead.":!0,See:!0,"https://flow.org/en/docs/types/conditional/":!0,for:!0,more:!0,information:!0,on:!0,"types.":!0,'[deprecated-type]"},{"startLine":5,"startColumn":36,"endLine":5,"endColumn":49,"description":"Cannot':!0,instantiate:!0,"`$Call`":!0,because:!0,property:!0,"`prop`":!0,is:!0,missing:!0,in:!0,object:!0,type:!0,"[1]":!0,but:!0,exists:!0,"[2]":!0,the:!0,first:!0,"argument.":!0,'[prop-missing]"},{"startLine":5,"startColumn":13,"endLine":5,"endColumn":50,"description":"Deprecated':!0,'[deprecated-type]"},{"startLine":8,"startColumn":1,"endLine":8,"endColumn":4,"description":"Cannot':!0,cast:!0,"`true`":!0,to:!0,"`PropType`":!0,boolean:!0,incompatible:!0,with:!0,number:!0,"[2].":!0,'[incompatible-cast]"}]':!0},"// Takes an object type, returns the type of its `prop` key\ntype ExtractPropType = <T>({prop: T, ...}) => T;\ntype Obj = {prop: number};\ntype PropType = $Call<ExtractPropType, Obj>;  // Call `ExtractPropType` with `Obj` as an argument\ntype Nope = $Call<ExtractPropType, {nope: number}>;  // Error! Argument doesn't match `Obj`.\n\n5 as PropType; // Works\ntrue as PropType;  // Error! PropType is a number\n")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":4,"startColumn":19,"endLine":4,"endColumn":46,"description":"Deprecated type. Use conditional types instead. See https://flow.org/en/docs/types/conditional/ for more information on conditional types. [deprecated-type]"},{"startLine":7,"startColumn":1,"endLine":7,"endColumn":4,"description":"Cannot cast `true` to `ReturnType` because boolean [1] is incompatible with number [2]. [incompatible-cast]"}]','[{"startLine":4,"startColumn":19,"endLine":4,"endColumn":46,"description":"Deprecated':!0,"type.":!0,Use:!0,conditional:!0,types:!0,"instead.":!0,See:!0,"https://flow.org/en/docs/types/conditional/":!0,for:!0,more:!0,information:!0,on:!0,"types.":!0,'[deprecated-type]"},{"startLine":7,"startColumn":1,"endLine":7,"endColumn":4,"description":"Cannot':!0,cast:!0,"`true`":!0,to:!0,"`ReturnType`":!0,because:!0,boolean:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,"[2].":!0,'[incompatible-cast]"}]':!0},"// Takes a function type, and returns its return type\ntype ExtractReturnType = <R>(() => R) => R;\ntype Fn = () => number;\ntype ReturnType = $Call<ExtractReturnType, Fn>;\n\n5 as ReturnType;  // Works\ntrue as ReturnType;  // Error! ReturnType is a number\n")),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"$Call")," can be very powerful because it allows you to make calls in type-land that you would otherwise have to do at runtime.\nThe type-land calls happen statically and will be erased at runtime."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":10,"startColumn":14,"endLine":10,"endColumn":61,"description":"Deprecated type. Use conditional types instead. See https://flow.org/en/docs/types/conditional/ for more information on conditional types. [deprecated-type]"},{"startLine":13,"startColumn":1,"endLine":13,"endColumn":4,"description":"Cannot cast `true` to `Value` because boolean [1] is incompatible with number [2]. [incompatible-cast]"},{"startLine":17,"startColumn":3,"endLine":17,"endColumn":32,"description":"Deprecated type. Use conditional types instead. See https://flow.org/en/docs/types/conditional/ for more information on conditional types. [deprecated-type]"},{"startLine":21,"startColumn":1,"endLine":21,"endColumn":4,"description":"Cannot cast `true` to `GetMapValue` because boolean [1] is incompatible with number [2]. [incompatible-cast]"}]','[{"startLine":10,"startColumn":14,"endLine":10,"endColumn":61,"description":"Deprecated':!0,"type.":!0,Use:!0,conditional:!0,types:!0,"instead.":!0,See:!0,"https://flow.org/en/docs/types/conditional/":!0,for:!0,more:!0,information:!0,on:!0,"types.":!0,'[deprecated-type]"},{"startLine":13,"startColumn":1,"endLine":13,"endColumn":4,"description":"Cannot':!0,cast:!0,"`true`":!0,to:!0,"`Value`":!0,because:!0,boolean:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,"[2].":!0,'[incompatible-cast]"},{"startLine":17,"startColumn":3,"endLine":17,"endColumn":32,"description":"Deprecated':!0,'[deprecated-type]"},{"startLine":21,"startColumn":1,"endLine":21,"endColumn":4,"description":"Cannot':!0,"`GetMapValue`":!0,'[incompatible-cast]"}]':!0},"// Getting return types:\nfunction getFirstValue<V>(map: Map<string, V>): ?V {\n  for (const [key, value] of map.entries()) {\n    return value;\n  }\n  return null;\n}\n\n// Using $Call, we can get the actual return type of the function above:\ntype Value = $Call<typeof getFirstValue, Map<string, number>>;\n\n5 as Value;\ntrue as Value;  // Error! Value is a `number`\n\n// We could generalize it further:\ntype GetMapValue<M> =\n  $Call<typeof getFirstValue, M>;\n\n5 as GetMapValue<Map<string, number>>;\ntrue as GetMapValue<Map<string, boolean>>;\ntrue as GetMapValue<Map<string, number>>;  // Error! value is a `number`\n")),(0,i.mdx)("h2",{id:"to-be-removed-utility-types"},"To-be-removed utility types"),(0,i.mdx)("h3",{id:"toc-objmap"},(0,i.mdx)("inlineCode",{parentName:"h3"},"$ObjMap<T, F>")),(0,i.mdx)("p",null,"NOTE: ",(0,i.mdx)("strong",{parentName:"p"},"Deprecated!")," This utility is deprecated as of Flow version 0.211- please use ",(0,i.mdx)("a",{parentName:"p",href:"../mapped-types"},"Mapped Types")," instead."),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"ObjMap<T, F>")," takes an ",(0,i.mdx)("a",{parentName:"p",href:"../objects"},"object type")," ",(0,i.mdx)("inlineCode",{parentName:"p"},"T"),", and a ",(0,i.mdx)("a",{parentName:"p",href:"../functions"},"function type")," ",(0,i.mdx)("inlineCode",{parentName:"p"},"F"),", and returns the object type obtained by mapping the type of each value in the object with the provided function type ",(0,i.mdx)("inlineCode",{parentName:"p"},"F"),". In other words, ",(0,i.mdx)("inlineCode",{parentName:"p"},"$ObjMap")," will ",(0,i.mdx)("a",{parentName:"p",href:"#toc-call"},"call")," (at the type level) the given function type ",(0,i.mdx)("inlineCode",{parentName:"p"},"F")," for every property value type in ",(0,i.mdx)("inlineCode",{parentName:"p"},"T"),", and return the resulting object type from those calls."),(0,i.mdx)("p",null,"Let's see an example. Suppose you have a function called ",(0,i.mdx)("inlineCode",{parentName:"p"},"run")," that takes an object of thunks (functions in the form ",(0,i.mdx)("inlineCode",{parentName:"p"},"() => A"),") as input:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function run<O: {[key: string]: (...$ReadOnlyArray<mixed>) => mixed}>(o: O): $FlowFixMe {\n  return Object.keys(o).reduce<{[string]: (...$ReadOnlyArray<mixed>) => mixed}>(\n    (acc, k) => ({...acc, [(k: string)]: o[k]()}),\n    {},\n  );\n}\n")),(0,i.mdx)("p",null,"The function's purpose is to run all the thunks and return an object made of values. What's the return type of this function?"),(0,i.mdx)("p",null,"The keys are the same, but the values have a different type, namely the return type of each function.\nAt a value level (the implementation of the function) we're essentially mapping over the object to produce new values for the keys.\nHow to express this at a type level?"),(0,i.mdx)("p",null,"This is where ",(0,i.mdx)("inlineCode",{parentName:"p"},"ObjMap<T, F>")," comes in handy"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":4,"startColumn":86,"endLine":4,"endColumn":92,"description":"Cannot resolve name `$ObjMap`. [cannot-resolve-name]"}]','[{"startLine":4,"startColumn":86,"endLine":4,"endColumn":92,"description":"Cannot':!0,resolve:!0,name:!0,"`$ObjMap`.":!0,'[cannot-resolve-name]"}]':!0},"// let's write a function type that takes a `() => V` and returns a `V` (its return type)\ntype ExtractReturnType = <V>(() => V) => V;\n\ndeclare function run<O: {[key: string]: (...$ReadOnlyArray<mixed>) => mixed}>(o: O): $ObjMap<O, ExtractReturnType>;\n\nconst o = {\n  a: () => true,\n  b: () => 'foo'\n};\n\nrun(o).a as boolean; // Works\nrun(o).b as string;  // Works\nrun(o).b as boolean; // Error! `b` is a string\nrun(o).c;            // Error! `c` was not in the original object\n")),(0,i.mdx)("p",null,"This is extremely useful for expressing the return type of functions that manipulate objects values.\nYou could use a similar approach (for instance) to provide the return type of bluebird's ",(0,i.mdx)("a",{parentName:"p",href:"http://bluebirdjs.com/docs/api/promise.props.html"},(0,i.mdx)("inlineCode",{parentName:"a"},"Promise.props"))," function,\nwhich is like ",(0,i.mdx)("inlineCode",{parentName:"p"},"Promise.all")," but takes an object as input."),(0,i.mdx)("p",null,"Here's a possible declaration of this function, which is very similar to our first example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":112,"endLine":1,"endColumn":112,"description":"Unexpected token `>`, expected the token `;`"}]','[{"startLine":1,"startColumn":112,"endLine":1,"endColumn":112,"description":"Unexpected':!0,token:!0,"`>`,":!0,expected:!0,the:!0,'`;`"}]':!0},"declare function props<A, O: {[key: string]: A}>(promises: O): Promise<$ObjMap<O, <T>(p: Promise<T> | T) => T>>>;\n\nconst promises = {a: Promise.resolve(42)};\nprops(promises).then(o => {\n  o.a as 42; // Works\n  o.a as 43; // Error! Flow knows it's 42\n});\n")),(0,i.mdx)("h3",{id:"toc-objmapi"},(0,i.mdx)("inlineCode",{parentName:"h3"},"$ObjMapi<T, F>")),(0,i.mdx)("p",null,"NOTE: ",(0,i.mdx)("strong",{parentName:"p"},"Deprecated!")," This utility is deprecated as of Flow version 0.211- please use ",(0,i.mdx)("a",{parentName:"p",href:"../mapped-types"},"Mapped Types")," instead."),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"ObjMapi<T, F>")," is similar to ",(0,i.mdx)("a",{parentName:"p",href:"#toc-objmap"},(0,i.mdx)("inlineCode",{parentName:"a"},"ObjMap<T, F>")),". The difference is that function\ntype ",(0,i.mdx)("inlineCode",{parentName:"p"},"F")," will be ",(0,i.mdx)("a",{parentName:"p",href:"#toc-call"},"called")," with both the key and value types of the elements of\nthe object type ",(0,i.mdx)("inlineCode",{parentName:"p"},"T"),", instead of just the value types. For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":8,"startColumn":39,"endLine":8,"endColumn":46,"description":"Cannot resolve name `$ObjMapi`. [cannot-resolve-name]"}]','[{"startLine":8,"startColumn":39,"endLine":8,"endColumn":46,"description":"Cannot':!0,resolve:!0,name:!0,"`$ObjMapi`.":!0,'[cannot-resolve-name]"}]':!0},"const o = {\n  a: () => true,\n  b: () => 'foo'\n};\n\ntype ExtractReturnObjectType = <K, V>(K, () => V) => { k: K, v: V };\n\ndeclare function run<O: {...}>(o: O): $ObjMapi<O, ExtractReturnObjectType>;\n\nrun(o).a as {k: 'a', v: boolean}; // Works\nrun(o).b as {k: 'b', v: string};  // Works\nrun(o).a as {k: 'b', v: boolean}; // Error! `a.k` is \"a\"\nrun(o).b as {k: 'b', v: number};  // Error! `b.v` is a string\nrun(o).c;                         // Error! `c` was not in the original object\n")),(0,i.mdx)("h3",{id:"toc-objmapconst"},(0,i.mdx)("inlineCode",{parentName:"h3"},"$ObjMapConst<O, T>")),(0,i.mdx)("p",null,"NOTE: ",(0,i.mdx)("strong",{parentName:"p"},"Deprecated!")," This utility is deprecated as of Flow version 0.211- please use ",(0,i.mdx)("a",{parentName:"p",href:"../mapped-types"},"Mapped Types")," instead."),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"$ObjMapConst<Obj, T>")," is a special case of ",(0,i.mdx)("inlineCode",{parentName:"p"},"$ObjMap<Obj, F>"),", when ",(0,i.mdx)("inlineCode",{parentName:"p"},"F")," is a constant\nfunction type, e.g. ",(0,i.mdx)("inlineCode",{parentName:"p"},"() => T"),". Instead of writing ",(0,i.mdx)("inlineCode",{parentName:"p"},"$ObjMap<Obj, () => T>"),", you\ncan write ",(0,i.mdx)("inlineCode",{parentName:"p"},"$ObjMapConst<Obj, T>"),". For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":39,"endLine":6,"endColumn":50,"description":"Cannot resolve name `$ObjMapConst`. [cannot-resolve-name]"}]','[{"startLine":6,"startColumn":39,"endLine":6,"endColumn":50,"description":"Cannot':!0,resolve:!0,name:!0,"`$ObjMapConst`.":!0,'[cannot-resolve-name]"}]':!0},"const obj = {\n  a: true,\n  b: 'foo'\n};\n\ndeclare function run<O: {...}>(o: O): $ObjMapConst<O, number>;\n\n// newObj is of type {a: number, b: number}\nconst newObj = run(obj);\n\nnewObj.a as number; // Works\nnewObj.b as string; // Error! Property `b` is a number\n")),(0,i.mdx)("p",null,"Tip: Prefer using ",(0,i.mdx)("inlineCode",{parentName:"p"},"$ObjMapConst")," instead of ",(0,i.mdx)("inlineCode",{parentName:"p"},"$ObjMap")," (if possible) to fix certain\nkinds of ",(0,i.mdx)("inlineCode",{parentName:"p"},"[invalid-exported-annotation]")," errors."),(0,i.mdx)("h2",{id:"removed-utility-types"},"Removed utility types"),(0,i.mdx)("p",null,"These utility types used to exist, but no longer exist in latest version of Flow."),(0,i.mdx)("h3",{id:"partial-"},(0,i.mdx)("inlineCode",{parentName:"h3"},"$Partial")," ",(0,i.mdx)(o.v,{version:"0.202",mdxType:"UntilVersion"})),(0,i.mdx)("p",null,"A former alias of ",(0,i.mdx)("a",{parentName:"p",href:"#toc-partial"},"Partial"),". Support was removed in version 0.203."),(0,i.mdx)("h3",{id:"toc-shape"},(0,i.mdx)("inlineCode",{parentName:"h3"},"$Shape<T>")," ",(0,i.mdx)(o.v,{version:"0.206",mdxType:"UntilVersion"})),(0,i.mdx)("p",null,"NOTE: This utility is unsafe - please use ",(0,i.mdx)("a",{parentName:"p",href:"#toc-partial"},(0,i.mdx)("inlineCode",{parentName:"a"},"Partial"))," documented above to make all of an object's fields optional."),(0,i.mdx)("p",null,"A variable of type ",(0,i.mdx)("inlineCode",{parentName:"p"},"$Shape<T>"),", where ",(0,i.mdx)("inlineCode",{parentName:"p"},"T")," is some object type, can be assigned objects ",(0,i.mdx)("inlineCode",{parentName:"p"},"o"),"\nthat contain a subset of the properties included in ",(0,i.mdx)("inlineCode",{parentName:"p"},"T"),". For each property ",(0,i.mdx)("inlineCode",{parentName:"p"},"p: S")," of ",(0,i.mdx)("inlineCode",{parentName:"p"},"T"),",\nthe type of a potential binding of ",(0,i.mdx)("inlineCode",{parentName:"p"},"p")," in ",(0,i.mdx)("inlineCode",{parentName:"p"},"o")," must be compatible with ",(0,i.mdx)("inlineCode",{parentName:"p"},"S"),"."),(0,i.mdx)("p",null,"For example"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":8,"startColumn":25,"endLine":8,"endColumn":33,"description":"Cannot assign object literal to `person1` because property `name` is missing in object literal [1] but exists in `Person` [2]. [prop-missing]"},{"startLine":9,"startColumn":25,"endLine":9,"endColumn":35,"description":"Cannot assign object literal to `person2` because property `age` is missing in object literal [1] but exists in `Person` [2]. [prop-missing]"}]','[{"startLine":8,"startColumn":25,"endLine":8,"endColumn":33,"description":"Cannot':!0,assign:!0,object:!0,literal:!0,to:!0,"`person1`":!0,because:!0,property:!0,"`name`":!0,is:!0,missing:!0,in:!0,"[1]":!0,but:!0,exists:!0,"`Person`":!0,"[2].":!0,'[prop-missing]"},{"startLine":9,"startColumn":25,"endLine":9,"endColumn":35,"description":"Cannot':!0,"`person2`":!0,"`age`":!0,'[prop-missing]"}]':!0},"type Person = {\n  age: number,\n  name: string,\n};\n// $FlowIgnore[deprecated-utility]\ntype PersonDetails = $Shape<Person>;\n\nconst person1: Person = {age: 28};  // ERROR: missing `name`\nconst person2: Person = {name: 'a'};  // ERROR: missing `age`\nconst person3: PersonDetails = {age: 28};  // OK\nconst person4: PersonDetails = {name: 'a'};  // OK\nconst person5: PersonDetails = {age: 28, name: 'a'};  // OK\nconst person6: PersonDetails = {age: '28'};  // ERROR: string is incompatible with number\n")),(0,i.mdx)("p",null,"NOTE: ",(0,i.mdx)("inlineCode",{parentName:"p"},"$Shape<T>")," is ",(0,i.mdx)("strong",{parentName:"p"},"not")," equivalent to ",(0,i.mdx)("inlineCode",{parentName:"p"},"T")," with all its fields marked as optional.\nIn particular, Flow unsoundly allows ",(0,i.mdx)("inlineCode",{parentName:"p"},"$Shape<T>")," to be used as a ",(0,i.mdx)("inlineCode",{parentName:"p"},"T")," in several\ncontexts. For example in"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"const personShape: PersonDetails = {age: 28};\npersonShape as Person;\n")),(0,i.mdx)("p",null,"Flow will unsoundly allow this last cast to succeed."),(0,i.mdx)("p",null,"It is also not equivalent to itself in some contexts:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"function f<T>(input: $Shape<T>): $Shape<T> {\n  return input; // ERROR: `T` is incompatible with `$Shape` of `T`\n}\n")),(0,i.mdx)("p",null,"This utility type is deprecated and will be deleted in the future -\nuse ",(0,i.mdx)("a",{parentName:"p",href:"#toc-partial"},(0,i.mdx)("inlineCode",{parentName:"a"},"Partial"))," instead."))}c.isMDXComponent=!0}}]);