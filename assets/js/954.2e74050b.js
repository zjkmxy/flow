"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[954],{60954:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>p,toc:()=>s});var o=n(58168),a=(n(96540),n(15680));const r={title:"Announcing Import Type","short-title":"Import Type",author:"Jeff Morrison",hide_table_of_contents:!0},i=void 0,p={permalink:"/blog/2015/02/18/Import-Types",source:"@site/blog/2015-02-18-Import-Types.md",title:"Announcing Import Type",description:"As of Flow 0.3.0, it's now possible to import types from another module. So, for example, if you're only importing a class for purposes of referencing it in a type annotation, you can now use the new import type syntax to do this.",date:"2015-02-18T00:00:00.000Z",formattedDate:"February 18, 2015",tags:[],hasTruncateMarker:!0,authors:[{name:"Jeff Morrison"}],frontMatter:{title:"Announcing Import Type","short-title":"Import Type",author:"Jeff Morrison",hide_table_of_contents:!0},prevItem:{title:"Announcing Flow Comments",permalink:"/blog/2015/02/20/Flow-Comments"},nextItem:{title:"Announcing Typecasts",permalink:"/blog/2015/02/18/Typecasts"}},l={authorsImageUrls:[void 0]},s=[{value:"Motivation",id:"motivation",level:2},{value:"Enter Import Type",id:"enter-import-type",level:2},{value:"Transformations",id:"transformations",level:2},{value:"Anticipatory Q&amp;A",id:"anticipatory-qa",level:2},{value:"Wait, but what happens at runtime after I&#39;ve added an <code>import type</code> declaration?",id:"wait-but-what-happens-at-runtime-after-ive-added-an-import-type-declaration",level:3},{value:"Can I use <code>import type</code> to pull in type aliases from another module, too?",id:"can-i-use-import-type-to-pull-in-type-aliases-from-another-module-too",level:3}],m={toc:s};function d(e){let{components:t,...n}=e;return(0,a.mdx)("wrapper",(0,o.A)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"As of Flow 0.3.0, it's now possible to import types from another module. So, for example, if you're only importing a class for purposes of referencing it in a type annotation, you can now use the new ",(0,a.mdx)("inlineCode",{parentName:"p"},"import type")," syntax to do this."),(0,a.mdx)("h2",{id:"motivation"},"Motivation"),(0,a.mdx)("p",null,"Has this ever happened to you:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-JavaScript"},"// @flow\n\n// Post-transformation lint error: Unused variable 'URI'\nimport URI from \"URI\";\n\n// But if you delete the require you get a Flow error:\n// identifier URI - Unknown global name\nmodule.exports = function(x: URI): URI {\n  return x;\n}\n")),(0,a.mdx)("p",null,"Now you have an out! To solve this problem (and with an eye toward a near future with ES6 module syntax), we've added the new ",(0,a.mdx)("inlineCode",{parentName:"p"},"import type")," syntax.  With ",(0,a.mdx)("inlineCode",{parentName:"p"},"import type"),", you can convey what you really mean here \u2014 that you want to import the ",(0,a.mdx)("em",{parentName:"p"},"type")," of the class and not really the class itself."),(0,a.mdx)("h2",{id:"enter-import-type"},"Enter Import Type"),(0,a.mdx)("p",null,"So instead of the above code, you can now write this:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-JavaScript"},"// @flow\n\nimport type URI from 'URI';\nmodule.exports = function(x: URI): URI {\n  return x;\n};\n")),(0,a.mdx)("p",null,"If you have a module that exports multiple classes (like, say, a Crayon and a Marker class), you can import the type for each of them together or separately like this:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-JavaScript"},"// @flow\n\nimport type {Crayon, Marker} from 'WritingUtensils';\nmodule.exports = function junkDrawer(x: Crayon, y: Marker): void {}\n")),(0,a.mdx)("h2",{id:"transformations"},"Transformations"),(0,a.mdx)("p",null,"Like type annotations and other Flow features, ",(0,a.mdx)("inlineCode",{parentName:"p"},"import type")," need to be transformed away before the code can be run. The transforms will be available in react-tools ",(0,a.mdx)("inlineCode",{parentName:"p"},"0.13.0")," when it is published soon, but for now they're available in ",(0,a.mdx)("inlineCode",{parentName:"p"},"0.13.0-beta.2"),", which you can install with"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-bash"},"npm install react-tools@0.13.0-beta.2\n")),(0,a.mdx)("h2",{id:"anticipatory-qa"},"Anticipatory Q&A"),(0,a.mdx)("h3",{id:"wait-but-what-happens-at-runtime-after-ive-added-an-import-type-declaration"},"Wait, but what happens at runtime after I've added an ",(0,a.mdx)("inlineCode",{parentName:"h3"},"import type")," declaration?"),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"Nothing! All ",(0,a.mdx)("inlineCode",{parentName:"em"},"import type")," declarations get stripped away just like other flow syntax.")),(0,a.mdx)("h3",{id:"can-i-use-import-type-to-pull-in-type-aliases-from-another-module-too"},"Can I use ",(0,a.mdx)("inlineCode",{parentName:"h3"},"import type")," to pull in type aliases from another module, too?"),(0,a.mdx)("del",null,"Not quite yet...but soon! There are a few other moving parts that we need to build first, but we're working on it."),(0,a.mdx)("p",null,"EDIT: Yes! As of Flow 0.10 you can use the ",(0,a.mdx)("inlineCode",{parentName:"p"},"export type MyType = ... ;")," syntax to compliment the ",(0,a.mdx)("inlineCode",{parentName:"p"},"import type")," syntax. Here's a trivial example:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-javascript"},"// @flow\n\n// MyTypes.js\nexport type UserID = number;\nexport type User = {\n  id: UserID,\n  firstName: string,\n  lastName: string\n};\n")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-javascript"},'// @flow\n\n// User.js\nimport type {UserID, User} from "MyTypes";\n\nfunction getUserID(user: User): UserID {\n  return user.id;\n}\n')),(0,a.mdx)("p",null,"Note that we only support the explicit named-export statements for now (i.e. ",(0,a.mdx)("inlineCode",{parentName:"p"},"export type UserID = number;"),"). In a future version we can add support for latent named-export statements (i.e. ",(0,a.mdx)("inlineCode",{parentName:"p"},"type UserID = number; export {UserID};"),") and default type exports (i.e.  ",(0,a.mdx)("inlineCode",{parentName:"p"},"export default type MyType = ... ;"),")...but for now these forms aren't yet supported for type exports."))}d.isMDXComponent=!0}}]);