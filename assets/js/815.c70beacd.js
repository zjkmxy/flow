"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[815],{70815:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>r,toc:()=>u});var a=n(58168),s=(n(96540),n(15680));n(60681);const l={title:"Nominal & Structural Typing",slug:"/lang/nominal-structural"},o=void 0,r={unversionedId:"lang/nominal-structural",id:"lang/nominal-structural",title:"Nominal & Structural Typing",description:"A static type checker can use either the name (nominal typing) or the structure (structural typing)",source:"@site/docs/lang/nominal-structural.md",sourceDirName:"lang",slug:"/lang/nominal-structural",permalink:"/en/docs/lang/nominal-structural",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/lang/nominal-structural.md",tags:[],version:"current",frontMatter:{title:"Nominal & Structural Typing",slug:"/lang/nominal-structural"},sidebar:"docsSidebar",previous:{title:"Type Variance",permalink:"/en/docs/lang/variance"},next:{title:"Depth Subtyping",permalink:"/en/docs/lang/depth-subtyping"}},i={},u=[{value:"Nominal typing",id:"toc-nominal-typing",level:2},{value:"Structural typing",id:"toc-structural-typing",level:2},{value:"In Flow",id:"in-flow",level:2},{value:"Functions are structurally typed",id:"toc-functions-are-structurally-typed",level:3},{value:"Objects are structurally typed",id:"toc-objects-are-structurally-typed",level:3},{value:"Classes are nominally typed",id:"toc-classes-are-nominally-typed",level:3},{value:"Opaque types",id:"opaque-types",level:3},{value:"Flow Enums",id:"flow-enums",level:3}],p={toc:u};function m(e){let{components:t,...n}=e;return(0,s.mdx)("wrapper",(0,a.A)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,s.mdx)("p",null,"A static type checker can use either the name (nominal typing) or the structure (structural typing)\nof types when comparing them against other types (like when checking if one is a ",(0,s.mdx)("a",{parentName:"p",href:"../subtypes"},"subtype")," of another)."),(0,s.mdx)("h2",{id:"toc-nominal-typing"},"Nominal typing"),(0,s.mdx)("p",null,"Languages like C++, Java, and Swift have primarily nominal type systems."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"// Pseudo code: nominal system\nclass Foo { method(input: string) { /* ... */ } }\nclass Bar { method(input: string) { /* ... */ } }\n\nlet foo: Foo = new Bar(); // Error!\n")),(0,s.mdx)("p",null,"In this pseudo-code example, the nominal type system errors even though both classes have a method of the same name and type.\nThis is because the name (and declaration location) of the classes is different."),(0,s.mdx)("h2",{id:"toc-structural-typing"},"Structural typing"),(0,s.mdx)("p",null,"Languages like Go and Elm have primarily structural type systems."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"// Pseudo code: structural system\nclass Foo { method(input: string) { /* ... */ } }\nclass Bar { method(input: string) { /* ... */ } }\n\nlet foo: Foo = new Bar(); // Works!\n")),(0,s.mdx)("p",null,"In this pseudo-code example, the structural type system allows a ",(0,s.mdx)("inlineCode",{parentName:"p"},"Bar")," to be used as a ",(0,s.mdx)("inlineCode",{parentName:"p"},"Foo"),",\nsince both classes have methods and fields of the same name and type."),(0,s.mdx)("p",null,"If the shape of the classes differ however, then a structural system would produce an error:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"// Pseudo code\nclass Foo { method(input: string) { /* ... */ } }\nclass Bar { method(input: number) { /* ... */ } }\n\nlet foo: Foo = new Bar(); // Error!\n")),(0,s.mdx)("p",null,"We've demonstrated both nominal and structural typing of classes, but there are\nalso other complex types like objects and functions which can also be either\nnominally or structurally compared.\nAdditionally, a type system may have aspects of both structural and nominal systems."),(0,s.mdx)("h2",{id:"in-flow"},"In Flow"),(0,s.mdx)("p",null,"Flow uses structural typing for objects and functions, but nominal typing for classes."),(0,s.mdx)("h3",{id:"toc-functions-are-structurally-typed"},"Functions are structurally typed"),(0,s.mdx)("p",null,"When comparing a ",(0,s.mdx)("a",{parentName:"p",href:"../../types/functions"},"function type")," with a function it must have the same structure\nin order to be considered valid."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type FuncType = (input: string) => void;\nfunction func(input: string) { /* ... */ }\nlet test: FuncType = func; // Works!\n")),(0,s.mdx)("h3",{id:"toc-objects-are-structurally-typed"},"Objects are structurally typed"),(0,s.mdx)("p",null,"When comparing an ",(0,s.mdx)("a",{parentName:"p",href:"../../types/objects"},"object type")," with an object it must have the same structure\nin order to be considered valid."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'type ObjType = {property: string};\nlet obj = {property: "value"};\nlet test: ObjType = obj; // Works\n')),(0,s.mdx)("h3",{id:"toc-classes-are-nominally-typed"},"Classes are nominally typed"),(0,s.mdx)("p",null,"When you have two ",(0,s.mdx)("a",{parentName:"p",href:"../../types/classes"},"classes")," with the same structure, they still are not\nconsidered equivalent because Flow uses nominal typing for classes."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":17,"endLine":3,"endColumn":25,"description":"Cannot assign `new Bar()` to `test` because `Bar` [1] is incompatible with `Foo` [2]. [incompatible-type]"}]','[{"startLine":3,"startColumn":17,"endLine":3,"endColumn":25,"description":"Cannot':!0,assign:!0,"`new":!0,"Bar()`":!0,to:!0,"`test`":!0,because:!0,"`Bar`":!0,"[1]":!0,is:!0,incompatible:!0,with:!0,"`Foo`":!0,"[2].":!0,'[incompatible-type]"}]':!0},"class Foo { method(input: string) { /* ... */ } }\nclass Bar { method(input: string) { /* ... */ } }\nlet test: Foo = new Bar(); // Error!\n")),(0,s.mdx)("p",null,"If you wanted to use a class structurally you could do that using an ",(0,s.mdx)("a",{parentName:"p",href:"../../types/interfaces"},"interface"),":"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"interface Interface {\n  method(value: string): void;\n};\n\nclass Foo { method(input: string) { /* ... */ } }\nclass Bar { method(input: string) { /* ... */ } }\n\nlet test1: Interface = new Foo(); // Works\nlet test2: Interface = new Bar(); // Works\n")),(0,s.mdx)("h3",{id:"opaque-types"},"Opaque types"),(0,s.mdx)("p",null,"You can use ",(0,s.mdx)("a",{parentName:"p",href:"../../types/opaque-types"},"opaque types")," to turn a previously structurally typed alias into a nominal one (outside of the file that it is defined)."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'// A.js\nexport type MyTypeAlias = string;\nexport opaque type MyOpaqueType = string;\n\nconst x: MyTypeAlias = "hi"; // Works\nconst y: MyOpaqueType = "hi"; // Works\n')),(0,s.mdx)("p",null,"In a different file:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},'// B.js\nimport type {MyTypeAlias, MyOpaqueType} from "A.js";\n\nconst x: MyTypeAlias = "hi"; // Works\nconst y: MyOpaqueType = "hi"; // Error! `MyOpaqueType` is not interchangable with `string`\n//                      ^^^^ Cannot assign "hi" to y because string is incompatible with MyOpaqueType\n')),(0,s.mdx)("h3",{id:"flow-enums"},"Flow Enums"),(0,s.mdx)("p",null,(0,s.mdx)("a",{parentName:"p",href:"../../enums"},"Flow Enums")," do not allow enum members with the same value, but which belong to different enums, to be used interchangeably."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":8,"startColumn":14,"endLine":8,"endColumn":16,"description":"Cannot assign `B.X` to `a` because `B` [1] is incompatible with `A` [2]. [incompatible-type]"}]','[{"startLine":8,"startColumn":14,"endLine":8,"endColumn":16,"description":"Cannot':!0,assign:!0,"`B.X`":!0,to:!0,"`a`":!0,because:!0,"`B`":!0,"[1]":!0,is:!0,incompatible:!0,with:!0,"`A`":!0,"[2].":!0,'[incompatible-type]"}]':!0},'enum A {\n  X = "x",\n}\nenum B {\n  X = "x",\n}\n\nconst a: A = B.X; // Error!\n')))}m.isMDXComponent=!0}}]);