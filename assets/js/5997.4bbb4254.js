"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[5997],{15997:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=t(58168),r=(t(96540),t(15680));t(60681);const o={title:"Functions",slug:"/types/functions"},i=void 0,s={unversionedId:"types/functions",id:"types/functions",title:"Functions",description:"Functions have two places where types are applied: parameters (input) and the return value (output).",source:"@site/docs/types/functions.md",sourceDirName:"types",slug:"/types/functions",permalink:"/en/docs/types/functions",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/types/functions.md",tags:[],version:"current",frontMatter:{title:"Functions",slug:"/types/functions"},sidebar:"docsSidebar",previous:{title:"Maybe Types",permalink:"/en/docs/types/maybe"},next:{title:"Objects",permalink:"/en/docs/types/objects"}},l={},d=[{value:"Syntax of functions",id:"syntax-of-functions",level:2},{value:"Function Declarations",id:"function-declarations",level:3},{value:"Arrow Functions",id:"arrow-functions",level:3},{value:"Function Types",id:"function-types",level:3},{value:"Type arguments",id:"type-arguments",level:3},{value:"Function Parameters",id:"function-parameters",level:2},{value:"Optional Parameters",id:"optional-parameters",level:3},{value:"Rest Parameters",id:"rest-parameters",level:3},{value:"<code>this</code> parameter",id:"this-parameter",level:3},{value:"Function Returns",id:"function-returns",level:2},{value:"Predicate Functions",id:"predicate-functions",level:3},{value:"Limitations of predicate functions",id:"limitations-of-predicate-functions",level:4},{value:"Callable Objects",id:"callable-objects",level:2},{value:"Overloaded functions",id:"overloaded-functions",level:2},{value:"Any function",id:"any-function",level:2}],u={toc:d};function m(e){let{components:n,...t}=e;return(0,r.mdx)("wrapper",(0,a.A)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"Functions have two places where types are applied: parameters (input) and the return value (output)."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":8,"endLine":6,"endColumn":11,"description":"Cannot call `concat` with `true` bound to `a` because boolean [1] is incompatible with string [2]. [incompatible-call]"},{"startLine":6,"startColumn":14,"endLine":6,"endColumn":18,"description":"Cannot call `concat` with `false` bound to `b` because boolean [1] is incompatible with string [2]. [incompatible-call]"}]','[{"startLine":6,"startColumn":8,"endLine":6,"endColumn":11,"description":"Cannot':!0,call:!0,"`concat`":!0,with:!0,"`true`":!0,bound:!0,to:!0,"`a`":!0,because:!0,boolean:!0,"[1]":!0,is:!0,incompatible:!0,string:!0,"[2].":!0,'[incompatible-call]"},{"startLine":6,"startColumn":14,"endLine":6,"endColumn":18,"description":"Cannot':!0,"`false`":!0,"`b`":!0,'[incompatible-call]"}]':!0},'function concat(a: string, b: string): string {\n  return a + b;\n}\n\nconcat("foo", "bar"); // Works!\nconcat(true, false);  // Error!\n')),(0,r.mdx)("p",null,"Using inference, return types are often optional:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'function concat(a: string, b: string) {\n  return a + b;\n}\n\nconst s: string = concat("foo", "bar"); // Works!\n')),(0,r.mdx)("p",null,"If defined where we can get the type from the context of the expression, type annotations can be optional:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"[1, 2, 3].map(x => x * x); // From the context, we know parameter `x` has type `number`\n")),(0,r.mdx)("h2",{id:"syntax-of-functions"},"Syntax of functions"),(0,r.mdx)("p",null,"There are three forms of functions that each have their own slightly different syntax."),(0,r.mdx)("h3",{id:"function-declarations"},"Function Declarations"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function func(str: string, bool?: boolean, ...nums: Array<number>): void {\n  // ...\n}\n")),(0,r.mdx)("h3",{id:"arrow-functions"},"Arrow Functions"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"let func = (str: string, bool?: boolean, ...nums: Array<number>): void => {\n  // ...\n};\n")),(0,r.mdx)("h3",{id:"function-types"},"Function Types"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type T = (str: string, bool?: boolean, ...nums: Array<number>) => void;\n")),(0,r.mdx)("p",null,"You may also optionally leave out the parameter names."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type T = (string, boolean | void, Array<number>) => void;\n")),(0,r.mdx)("p",null,"You might use these functions types for something like a callback."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function func(callback: (error: Error | null, value: string | null) => void) {\n  // ...\n}\n")),(0,r.mdx)("h3",{id:"type-arguments"},"Type arguments"),(0,r.mdx)("p",null,"Functions can have type arguments:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function f<T>(x: T): Array<T> {\n  return [x];\n}\n\nconst g = <T>(x: T): Array<T> => [x];\n\ntype H = <T>(T) => Array<T>;\n")),(0,r.mdx)("h2",{id:"function-parameters"},"Function Parameters"),(0,r.mdx)("p",null,"Function parameters can have types by adding a colon ",(0,r.mdx)("inlineCode",{parentName:"p"},":")," followed by the type\nafter the name of the parameter."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function func(param1: string, param2: boolean) {\n  // ...\n}\n")),(0,r.mdx)("h3",{id:"optional-parameters"},"Optional Parameters"),(0,r.mdx)("p",null,"You can also have optional parameters by adding a question mark ",(0,r.mdx)("inlineCode",{parentName:"p"},"?")," after the\nname of the parameter and before the colon ",(0,r.mdx)("inlineCode",{parentName:"p"},":"),"."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function func(optionalValue?: string) {\n  // ...\n}\n")),(0,r.mdx)("p",null,"Optional parameters will accept missing, ",(0,r.mdx)("inlineCode",{parentName:"p"},"undefined"),", or matching types. But\nthey will not accept ",(0,r.mdx)("inlineCode",{parentName:"p"},"null"),"."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":9,"startColumn":6,"endLine":9,"endColumn":9,"description":"Cannot call `func` with `null` bound to `optionalValue` because null [1] is incompatible with string [2]. [incompatible-call]"}]','[{"startLine":9,"startColumn":6,"endLine":9,"endColumn":9,"description":"Cannot':!0,call:!0,"`func`":!0,with:!0,"`null`":!0,bound:!0,to:!0,"`optionalValue`":!0,because:!0,null:!0,"[1]":!0,is:!0,incompatible:!0,string:!0,"[2].":!0,'[incompatible-call]"}]':!0},'function func(optionalValue?: string) {\n  // ...\n}\n\nfunc();          // Works.\nfunc(undefined); // Works.\nfunc("string");  // Works.\n\nfunc(null);      // Error!\n')),(0,r.mdx)("h3",{id:"rest-parameters"},"Rest Parameters"),(0,r.mdx)("p",null,"JavaScript also supports having rest parameters or parameters that collect an\narray of arguments at the end of a list of parameters. These have an ellipsis\n",(0,r.mdx)("inlineCode",{parentName:"p"},"...")," before them."),(0,r.mdx)("p",null,"You can also add type annotations for rest parameters using the same syntax but\nwith an ",(0,r.mdx)("inlineCode",{parentName:"p"},"Array"),"."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function func(...args: Array<number>) {\n  // ...\n}\n")),(0,r.mdx)("p",null,"You can pass as many arguments as you want into a rest parameter."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function func(...args: Array<number>) {\n  // ...\n}\n\nfunc();        // Works.\nfunc(1);       // Works.\nfunc(1, 2);    // Works.\nfunc(1, 2, 3); // Works.\n")),(0,r.mdx)("blockquote",null,(0,r.mdx)("p",{parentName:"blockquote"},"Note: If you add a type annotation to a rest parameter, it must always\nexplicitly be an ",(0,r.mdx)("inlineCode",{parentName:"p"},"Array")," of ",(0,r.mdx)("inlineCode",{parentName:"p"},"$ReadOnlyArray")," type.")),(0,r.mdx)("h3",{id:"this-parameter"},(0,r.mdx)("inlineCode",{parentName:"h3"},"this")," parameter"),(0,r.mdx)("p",null,"Every function in JavaScript can be called with a special context named ",(0,r.mdx)("inlineCode",{parentName:"p"},"this"),".\nYou can call a function with any context that you want. Flow allows you to annotate\nthe type for this context by adding a special parameter at the start of the function's parameter list:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":21,"endLine":6,"endColumn":39,"description":"Cannot assign `func.call(...)` to `str` because number [1] is incompatible with string [2]. [incompatible-type]"}]','[{"startLine":6,"startColumn":21,"endLine":6,"endColumn":39,"description":"Cannot':!0,assign:!0,"`func.call(...)`":!0,to:!0,"`str`":!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,string:!0,"[2].":!0,'[incompatible-type]"}]':!0},"function func<T>(this: { x: T }) : T {\n  return this.x;\n}\n\nconst num: number = func.call({x : 42});\nconst str: string = func.call({x : 42}); // Error!\n")),(0,r.mdx)("p",null,"This parameter has no effect at runtime, and is erased along with types when Flow is transformed into JavaScript.\nWhen present, ",(0,r.mdx)("inlineCode",{parentName:"p"},"this")," parameters must always appear at the very beginning of the function's parameter list, and must\nhave an annotation. Additionally, ",(0,r.mdx)("a",{parentName:"p",href:"./#toc-arrow-functions"},"arrow functions")," may not have a ",(0,r.mdx)("inlineCode",{parentName:"p"},"this")," parameter annotation, as\nthese functions bind their ",(0,r.mdx)("inlineCode",{parentName:"p"},"this")," parameter at the definition site, rather than the call site."),(0,r.mdx)("p",null,"If an explicit ",(0,r.mdx)("inlineCode",{parentName:"p"},"this")," parameter is not provided, Flow will attempt to infer one based on usage. If ",(0,r.mdx)("inlineCode",{parentName:"p"},"this")," is not mentioned\nin the body of the function, Flow will infer ",(0,r.mdx)("inlineCode",{parentName:"p"},"mixed")," for its ",(0,r.mdx)("inlineCode",{parentName:"p"},"this")," parameter."),(0,r.mdx)("h2",{id:"function-returns"},"Function Returns"),(0,r.mdx)("p",null,"Function returns can also add a type using a colon ",(0,r.mdx)("inlineCode",{parentName:"p"},":")," followed by the type\nafter the list of parameters."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function func(): number {\n  return 1;\n}\n")),(0,r.mdx)("p",null,"Return types ensure that every branch of your function returns the same type.\nThis prevents you from accidentally not returning a value under certain\nconditions."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":18,"endLine":1,"endColumn":24,"description":"Cannot expect boolean as the return type of function because boolean [1] is incompatible with implicitly-returned undefined. [incompatible-return]"}]','[{"startLine":1,"startColumn":18,"endLine":1,"endColumn":24,"description":"Cannot':!0,expect:!0,boolean:!0,as:!0,the:!0,return:!0,type:!0,of:!0,function:!0,because:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,"implicitly-returned":!0,"undefined.":!0,'[incompatible-return]"}]':!0},"function func(): boolean {\n  if (Math.random() > 0.5) {\n    return true;\n  }\n}\n")),(0,r.mdx)("p",null,"Async functions implicitly return a promise, so the return type must always be a ",(0,r.mdx)("inlineCode",{parentName:"p"},"Promise"),"."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"async function func(): Promise<number> {\n  return 123;\n}\n")),(0,r.mdx)("h3",{id:"predicate-functions"},"Predicate Functions"),(0,r.mdx)("p",null,"Sometimes you will want to move the condition from an ",(0,r.mdx)("inlineCode",{parentName:"p"},"if")," statement into a function:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function concat(a: ?string, b: ?string): string {\n  if (a != null && b != null) {\n    return a + b;\n  }\n  return '';\n}\n")),(0,r.mdx)("p",null,"However, Flow will error in the code below:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":7,"startColumn":12,"endLine":7,"endColumn":16,"description":"Cannot use operator `+` with operands null or undefined [1] and null or undefined [2] [unsafe-addition]"},{"startLine":7,"startColumn":12,"endLine":7,"endColumn":16,"description":"Cannot use operator `+` with operands null or undefined [1] and string [2] [unsafe-addition]"},{"startLine":7,"startColumn":12,"endLine":7,"endColumn":16,"description":"Cannot use operator `+` with operands string [1] and null or undefined [2] [unsafe-addition]"}]','[{"startLine":7,"startColumn":12,"endLine":7,"endColumn":16,"description":"Cannot':!0,use:!0,operator:!0,"`+`":!0,with:!0,operands:!0,null:!0,or:!0,undefined:!0,"[1]":!0,and:!0,"[2]":!0,'[unsafe-addition]"},{"startLine":7,"startColumn":12,"endLine":7,"endColumn":16,"description":"Cannot':!0,string:!0,'[unsafe-addition]"}]':!0},"function truthy(a: ?string, b: ?string): boolean {\n  return a != null && b != null;\n}\n\nfunction concat(a: ?string, b: ?string): string {\n  if (truthy(a, b)) {\n    return a + b; // Error!\n  }\n  return '';\n}\n")),(0,r.mdx)("p",null,"This is because the refinement information of ",(0,r.mdx)("inlineCode",{parentName:"p"},"a")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"b")," as ",(0,r.mdx)("inlineCode",{parentName:"p"},"string")," instead of ",(0,r.mdx)("inlineCode",{parentName:"p"},"?string")," is lost when returning from the ",(0,r.mdx)("inlineCode",{parentName:"p"},"truthy")," function."),(0,r.mdx)("p",null,"You can fix this by making ",(0,r.mdx)("inlineCode",{parentName:"p"},"truthy")," a ",(0,r.mdx)("em",{parentName:"p"},"predicate function"),", by using the ",(0,r.mdx)("inlineCode",{parentName:"p"},"%checks")," annotation like so:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":50,"endLine":1,"endColumn":56,"description":"Deprecated type. Use type guards instead. See https://flow.org/en/docs/types/type-guards/ for more information on type guards. [deprecated-type]"}]','[{"startLine":1,"startColumn":50,"endLine":1,"endColumn":56,"description":"Deprecated':!0,"type.":!0,Use:!0,type:!0,guards:!0,"instead.":!0,See:!0,"https://flow.org/en/docs/types/type-guards/":!0,for:!0,more:!0,information:!0,on:!0,"guards.":!0,'[deprecated-type]"}]':!0},"function truthy(a: ?string, b: ?string): boolean %checks {\n  return a != null && b != null;\n}\n\nfunction concat(a: ?string, b: ?string): string {\n  if (truthy(a, b)) {\n    return a + b;\n  }\n  return '';\n}\n")),(0,r.mdx)("h4",{id:"limitations-of-predicate-functions"},"Limitations of predicate functions"),(0,r.mdx)("p",null,"The body of these predicate functions need to be expressions (i.e. local variable declarations are not supported).\nBut it's possible to call other predicate functions inside a predicate function.\nFor example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":28,"endLine":1,"endColumn":36,"description":"Deprecated type. Use type guards instead. See https://flow.org/en/docs/types/type-guards/ for more information on type guards. [deprecated-type]"},{"startLine":5,"startColumn":28,"endLine":5,"endColumn":36,"description":"Deprecated type. Use type guards instead. See https://flow.org/en/docs/types/type-guards/ for more information on type guards. [deprecated-type]"},{"startLine":9,"startColumn":36,"endLine":9,"endColumn":44,"description":"Deprecated type. Use type guards instead. See https://flow.org/en/docs/types/type-guards/ for more information on type guards. [deprecated-type]"}]','[{"startLine":1,"startColumn":28,"endLine":1,"endColumn":36,"description":"Deprecated':!0,"type.":!0,Use:!0,type:!0,guards:!0,"instead.":!0,See:!0,"https://flow.org/en/docs/types/type-guards/":!0,for:!0,more:!0,information:!0,on:!0,"guards.":!0,'[deprecated-type]"},{"startLine":5,"startColumn":28,"endLine":5,"endColumn":36,"description":"Deprecated':!0,'[deprecated-type]"},{"startLine":9,"startColumn":36,"endLine":9,"endColumn":44,"description":"Deprecated':!0,'[deprecated-type]"}]':!0},'function isString(y: mixed): %checks {\n  return typeof y === "string";\n}\n\nfunction isNumber(y: mixed): %checks {\n  return typeof y === "number";\n}\n\nfunction isNumberOrString(y: mixed): %checks {\n  return isString(y) || isNumber(y);\n}\n\nfunction foo(x: string | number | Array<mixed>): string | number {\n  if (isNumberOrString(x)) {\n    return x + x;\n  } else {\n    return x.length; // no error, because Flow infers that x can only be an array\n  }\n}\n\nfoo(\'a\');\nfoo(5);\nfoo([]);\n')),(0,r.mdx)("p",null,"Another limitation is on the range of predicates that can be encoded. The refinements\nthat are supported in a predicate function must refer directly to the value that\nis passed in as an argument to the respective call."),(0,r.mdx)("p",null,"For example, consider the ",(0,r.mdx)("em",{parentName:"p"},"inlined")," refinement"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"declare const obj: {n?: number};\n\nif (obj.n != null) {\n  const n: number = obj.n;\n}\n")),(0,r.mdx)("p",null,"Here, Flow will let you refine ",(0,r.mdx)("inlineCode",{parentName:"p"},"obj.n")," from ",(0,r.mdx)("inlineCode",{parentName:"p"},"?number")," to ",(0,r.mdx)("inlineCode",{parentName:"p"},"number"),". Note that the\nrefinement here is on the property ",(0,r.mdx)("inlineCode",{parentName:"p"},"n")," of ",(0,r.mdx)("inlineCode",{parentName:"p"},"obj"),", rather than ",(0,r.mdx)("inlineCode",{parentName:"p"},"obj")," itself."),(0,r.mdx)("p",null,"If you tried to create a ",(0,r.mdx)("em",{parentName:"p"},"predicate")," function to encode the same condition,\nthen the following refinement would fail"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":35,"endLine":1,"endColumn":43,"description":"Deprecated type. Use type guards instead. See https://flow.org/en/docs/types/type-guards/ for more information on type guards. [deprecated-type]"},{"startLine":8,"startColumn":21,"endLine":8,"endColumn":25,"description":"Cannot assign `obj.n` to `n` because undefined [1] is incompatible with number [2]. [incompatible-type]"}]','[{"startLine":1,"startColumn":35,"endLine":1,"endColumn":43,"description":"Deprecated':!0,"type.":!0,Use:!0,type:!0,guards:!0,"instead.":!0,See:!0,"https://flow.org/en/docs/types/type-guards/":!0,for:!0,more:!0,information:!0,on:!0,"guards.":!0,'[deprecated-type]"},{"startLine":8,"startColumn":21,"endLine":8,"endColumn":25,"description":"Cannot':!0,assign:!0,"`obj.n`":!0,to:!0,"`n`":!0,because:!0,undefined:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,"[2].":!0,'[incompatible-type]"}]':!0},"function bar(a: {n?: number, ...}): %checks {\n  return a.n != null;\n}\n\ndeclare const obj: {n?: number};\n\nif (bar(obj)) {\n  const n: number = obj.n; // Error\n}\n")),(0,r.mdx)("p",null,"This is because the only refinements supported through ",(0,r.mdx)("inlineCode",{parentName:"p"},"bar")," would be on ",(0,r.mdx)("inlineCode",{parentName:"p"},"obj")," itself."),(0,r.mdx)("h2",{id:"callable-objects"},"Callable Objects"),(0,r.mdx)("p",null,"Callable objects can be typed, for example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'type CallableObj = {\n  (number, number): number,\n  bar: string,\n  ...\n};\n\nfunction add(x: number, y: number) {\n  return x + y;\n}\n\nadd.bar = "hello world";\n\nadd as CallableObj;\n')),(0,r.mdx)("p",null,"In general, functions can have properties assigned to them if they are function declarations, or\nsimple variable declarations of the form ",(0,r.mdx)("inlineCode",{parentName:"p"},"const f = () => ..."),". The properties must be assigned in\nthe format ",(0,r.mdx)("inlineCode",{parentName:"p"},"f.prop = <expr>;"),", in the same statement list as the function definition (i.e. not conditionally)."),(0,r.mdx)("p",null,"Note that the object representing the static properties assigned to the function is inexact."),(0,r.mdx)("h2",{id:"overloaded-functions"},"Overloaded functions"),(0,r.mdx)("p",null,"You can use intersection types to define ",(0,r.mdx)("a",{parentName:"p",href:"../intersections/#toc-intersection-of-function-types"},"overloaded function types"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"declare const fn:\n  & ((x: 'string') => string)\n  & ((x: 'number') => number)\n\nconst s: string = fn('string');\nconst n: number = fn('number');\n")),(0,r.mdx)("h2",{id:"any-function"},"Any function"),(0,r.mdx)("p",null,"If you want to specify you want to allow any function, and do not care what it is, you can use this pattern:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function useCallback<T: (...$ReadOnlyArray<empty>) => mixed>(\n  callback: T,\n  inputs: ?$ReadOnlyArray<mixed>,\n): T {\n  return callback;\n}\nuseCallback((x: string) => true); // OK\nuseCallback((x: number) => [1]); // OK\n")),(0,r.mdx)("p",null,"You could use type arguments to capture the arguments and return type, to do more complicated transformations:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function func<TArgs: $ReadOnlyArray<mixed>, TReturn>(\n  callback: (...TArgs) => TReturn,\n): (boolean, ...TArgs) => Array<TReturn> {\n  return (b, ...args): Array<TReturn> => {\n    if (b) {\n      return [callback(...args)];\n    } else {\n      return [];\n    }\n  };\n}\n\nconst f: (boolean, string, number) => Array<string> =\n  func((x: string, y: number) => x.slice(y)); // OK\n")),(0,r.mdx)("p",null,"The type ",(0,r.mdx)("inlineCode",{parentName:"p"},"Function")," is just an alias for ",(0,r.mdx)("a",{parentName:"p",href:"../any"},(0,r.mdx)("inlineCode",{parentName:"a"},"any")),", and is unsafe.\nYou can ban its use in your code with the ",(0,r.mdx)("a",{parentName:"p",href:"../../linting/rule-reference/#toc-unclear-type"},"unclear-type lint"),"."))}m.isMDXComponent=!0}}]);