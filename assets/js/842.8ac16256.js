"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[842],{20842:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var a=t(58168),o=(t(96540),t(15680));t(60681);const i={title:"FAQ",description:"Have a question about using Flow? Check here first!",slug:"/faq"},r=void 0,s={unversionedId:"faq",id:"faq",title:"FAQ",description:"Have a question about using Flow? Check here first!",source:"@site/docs/faq.md",sourceDirName:".",slug:"/faq",permalink:"/en/docs/faq",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/faq.md",tags:[],version:"current",frontMatter:{title:"FAQ",description:"Have a question about using Flow? Check here first!",slug:"/faq"},sidebar:"docsSidebar",previous:{title:"Usage",permalink:"/en/docs/usage"},next:{title:"Type Annotations",permalink:"/en/docs/types"}},l={},d=[{value:"I checked that <code>foo.bar</code> is not <code>null</code>, but Flow still thinks it is. Why does this happen and how can I fix it?",id:"i-checked-that-foobar-is-not-null-but-flow-still-thinks-it-is-why-does-this-happen-and-how-can-i-fix-it",level:2},{value:"I checked that my value is of type A, so why does Flow still believe it&#39;s A\xa0| B?",id:"i-checked-that-my-value-is-of-type-a-so-why-does-flow-still-believe-its-a-b",level:2},{value:"I&#39;m in a closure and Flow ignores the if check that asserts that <code>foo.bar</code> is defined. Why?",id:"im-in-a-closure-and-flow-ignores-the-if-check-that-asserts-that-foobar-is-defined-why",level:2},{value:"But Flow should understand that this function cannot invalidate this refinement, right?",id:"but-flow-should-understand-that-this-function-cannot-invalidate-this-refinement-right",level:2},{value:"Why can&#39;t I use a function in my if-clause to check the type of a property?",id:"why-cant-i-use-a-function-in-my-if-clause-to-check-the-type-of-a-property",level:2},{value:"Why can&#39;t I pass an <code>Array&lt;string&gt;</code> to a function that takes an <code>Array&lt;string |\xa0number&gt;</code>",id:"why-cant-i-pass-an-arraystring-to-a-function-that-takes-an-arraystring-number",level:2},{value:"Why can&#39;t I pass <code>{a: string}</code> to a function that takes <code>{a: string |\xa0number}</code>",id:"why-cant-i-pass-a-string-to-a-function-that-takes-a-string-number",level:2},{value:"Why can&#39;t I refine a union of objects?",id:"why-cant-i-refine-a-union-of-objects",level:2},{value:"I got a &quot;Missing type annotation&quot; error. Where does it come from?",id:"i-got-a-missing-type-annotation-error-where-does-it-come-from",level:2}],c={toc:d};function u(e){let{components:n,...t}=e;return(0,o.mdx)("wrapper",(0,a.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("h2",{id:"i-checked-that-foobar-is-not-null-but-flow-still-thinks-it-is-why-does-this-happen-and-how-can-i-fix-it"},"I checked that ",(0,o.mdx)("inlineCode",{parentName:"h2"},"foo.bar")," is not ",(0,o.mdx)("inlineCode",{parentName:"h2"},"null"),", but Flow still thinks it is. Why does this happen and how can I fix it?"),(0,o.mdx)("p",null,"Flow does not keep track of side effects, so any function call may potentially nullify your check.\nThis is called ",(0,o.mdx)("a",{parentName:"p",href:"../lang/refinements/#toc-refinement-invalidations"},"refinement invalidation"),". Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":7,"startColumn":12,"endLine":7,"endColumn":18,"description":"Cannot return `foo.bar` because null or undefined [1] is incompatible with string [2]. [incompatible-return]"}]','[{"startLine":7,"startColumn":12,"endLine":7,"endColumn":18,"description":"Cannot':!0,return:!0,"`foo.bar`":!0,because:!0,null:!0,or:!0,undefined:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,string:!0,"[2].":!0,'[incompatible-return]"}]':!0},'type Param = {\n  bar: ?string,\n}\nfunction myFunc(foo: Param): string {\n  if (foo.bar) {\n    console.log("checked!");\n    return foo.bar; // Flow errors. If you remove the console.log, it works\n  }\n\n  return "default string";\n}\n')),(0,o.mdx)("p",null,"You can get around this by storing your checked values in local variables:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'type Param = {\n  bar: ?string,\n}\nfunction myFunc(foo: Param): string {\n  if (foo.bar) {\n    const bar = foo.bar;\n    console.log("checked!");\n    return bar; // Ok!\n  }\n\n  return "default string";\n}\n')),(0,o.mdx)("h2",{id:"i-checked-that-my-value-is-of-type-a-so-why-does-flow-still-believe-its-a-b"},"I checked that my value is of type A, so why does Flow still believe it's A\xa0| B?"),(0,o.mdx)("p",null,"Refinement invalidation can also occur variables are updated:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":11,"startColumn":3,"endLine":11,"endColumn":3,"description":"Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]"}]','[{"startLine":11,"startColumn":3,"endLine":11,"endColumn":3,"description":"Cannot':!0,cast:!0,"`x`":!0,to:!0,string:!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,"[2].":!0,'[incompatible-cast]"}]':!0},"type T = string | number;\n\nlet x: T = 'hi';\n\nfunction f() {\n  x = 1;\n}\n\nif (typeof x === 'string') {\n  f();\n  x as string;\n}\n")),(0,o.mdx)("p",null,"A work around would be to make the variable ",(0,o.mdx)("inlineCode",{parentName:"p"},"const")," and refactor your code to avoid the reassignment:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type T = string | number;\n\nconst x: T = 'hi';\n\nfunction f(x: T): number {\n  return 1;\n}\n\nif (typeof x === 'string') {\n  const xUpdated = f(x);\n  xUpdated as number;\n  x as string;\n}\n")),(0,o.mdx)("h2",{id:"im-in-a-closure-and-flow-ignores-the-if-check-that-asserts-that-foobar-is-defined-why"},"I'm in a closure and Flow ignores the if check that asserts that ",(0,o.mdx)("inlineCode",{parentName:"h2"},"foo.bar")," is defined. Why?"),(0,o.mdx)("p",null,"In the previous section we showed how refinements are lost after a function call. The exact same thing happens within closures, since\nFlow does not track how your value might change before the closure is called:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":5,"startColumn":67,"endLine":5,"endColumn":79,"description":"Cannot coerce `oldPerson.age` to string because null or undefined [1] should not be coerced. [incompatible-type]"}]','[{"startLine":5,"startColumn":67,"endLine":5,"endColumn":79,"description":"Cannot':!0,coerce:!0,"`oldPerson.age`":!0,to:!0,string:!0,because:!0,null:!0,or:!0,undefined:!0,"[1]":!0,should:!0,not:!0,be:!0,"coerced.":!0,'[incompatible-type]"}]':!0},"const people = [{age: 12}, {age: 18}, {age: 24}];\nconst oldPerson: {age: ?number} = {age: 70};\nif (oldPerson.age) {\n  people.forEach(person => {\n    console.log(`The person is ${person.age} and the old one is ${oldPerson.age}`);\n  })\n}\n")),(0,o.mdx)("p",null,"The solution here is to move the if check in the ",(0,o.mdx)("inlineCode",{parentName:"p"},"forEach"),", or to assign the ",(0,o.mdx)("inlineCode",{parentName:"p"},"age")," to an intermediate variable:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const people = [{age: 12}, {age: 18}, {age: 24}];\nconst oldPerson: {age: ?number} = {age: 70};\nif (oldPerson.age) {\n  const age = oldPerson.age;\n  people.forEach(person => {\n    console.log(`The person is ${person.age} and the old one is ${age}`);\n  })\n}\n")),(0,o.mdx)("h2",{id:"but-flow-should-understand-that-this-function-cannot-invalidate-this-refinement-right"},"But Flow should understand that this function cannot invalidate this refinement, right?"),(0,o.mdx)("p",null,"Flow is not ",(0,o.mdx)("a",{parentName:"p",href:"../lang/types-and-expressions/#toc-soundness-and-completeness"},"complete"),", so it cannot check all code perfectly. Instead,\nFlow will make conservative assumptions to try to be sound."),(0,o.mdx)("h2",{id:"why-cant-i-use-a-function-in-my-if-clause-to-check-the-type-of-a-property"},"Why can't I use a function in my if-clause to check the type of a property?"),(0,o.mdx)("p",null,"Flow doesn't track ",(0,o.mdx)("a",{parentName:"p",href:".././lang/refinements/"},"refinements")," made in separate function calls:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":5,"startColumn":7,"endLine":5,"endColumn":9,"description":"Cannot call `add` with `val` bound to `first` because string [1] is incompatible with number [2]. [incompatible-call]"}]','[{"startLine":5,"startColumn":7,"endLine":5,"endColumn":9,"description":"Cannot':!0,call:!0,"`add`":!0,with:!0,"`val`":!0,bound:!0,to:!0,"`first`":!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,number:!0,"[2].":!0,'[incompatible-call]"}]':!0},"const add = (first: number, second: number) => first + second;\nconst val: string | number = 1;\nconst isNumber = (x: mixed): boolean => typeof x === 'number';\nif (isNumber(val)) {\n  add(val, 2);\n}\n")),(0,o.mdx)("p",null,"However, you can annotate your function with a ",(0,o.mdx)("a",{parentName:"p",href:"../types/type-guards/"},"type guard")," to get this behavior:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const add = (first: number, second: number) => first + second;\nconst val: string | number = 1;\n// Return annotation updated:\nconst isNumber = (x: mixed): x is number => typeof x === 'number';\nif (isNumber(val)) {\n  add(val, 2);\n}\n")),(0,o.mdx)("h2",{id:"why-cant-i-pass-an-arraystring-to-a-function-that-takes-an-arraystring-number"},"Why can't I pass an ",(0,o.mdx)("inlineCode",{parentName:"h2"},"Array<string>")," to a function that takes an ",(0,o.mdx)("inlineCode",{parentName:"h2"},"Array<string |\xa0number>")),(0,o.mdx)("p",null,"The function's argument allows ",(0,o.mdx)("inlineCode",{parentName:"p"},"string")," values in its array, but in this case Flow prevents the original array from receiving a ",(0,o.mdx)("inlineCode",{parentName:"p"},"number"),".\nInside the function, you would be able to push a ",(0,o.mdx)("inlineCode",{parentName:"p"},"number")," to the argument array, causing the type of the original array to no longer be accurate."),(0,o.mdx)("p",null,"You can fix this error by changing the type of the argument to ",(0,o.mdx)("inlineCode",{parentName:"p"},"$ReadOnlyArray<string |\xa0number>"),", making it ",(0,o.mdx)("a",{parentName:"p",href:"../lang/variance/#toc-covariance"},"covariant"),".\nThis prevents the function body from pushing anything to the array, allowing it to accept narrower types."),(0,o.mdx)("p",null,"As an example, this would not work:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":8,"startColumn":4,"endLine":8,"endColumn":6,"description":"Cannot call `fn` with `arr` bound to `arr` because number [1] is incompatible with string [2] in array element. Arrays are invariantly typed. See https://flow.org/en/docs/faq/#why-cant-i-pass-an-arraystring-to-a-function-that-takes-an-arraystring-number. [incompatible-call]"}]','[{"startLine":8,"startColumn":4,"endLine":8,"endColumn":6,"description":"Cannot':!0,call:!0,"`fn`":!0,with:!0,"`arr`":!0,bound:!0,to:!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,string:!0,"[2]":!0,in:!0,array:!0,"element.":!0,Arrays:!0,are:!0,invariantly:!0,"typed.":!0,See:!0,"https://flow.org/en/docs/faq/#why-cant-i-pass-an-arraystring-to-a-function-that-takes-an-arraystring-number.":!0,'[incompatible-call]"}]':!0},"const fn = (arr: Array<string | number>) => {\n  arr.push(123); // Oops! Array<string> was passed in - now inaccurate\n  return arr;\n};\n\nconst arr: Array<string> = ['abc'];\n\nfn(arr); // Error!\n")),(0,o.mdx)("p",null,"but with ",(0,o.mdx)("inlineCode",{parentName:"p"},"$ReadOnlyArray")," you can achieve what you were looking for:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const fn = (arr: $ReadOnlyArray<string | number>) => {\n  // arr.push(321); NOTE! Since you are using $ReadOnlyArray<...> you cannot push anything to it\n  return arr;\n};\n\nconst arr: Array<string> = ['abc'];\n\nfn(arr);\n")),(0,o.mdx)("h2",{id:"why-cant-i-pass-a-string-to-a-function-that-takes-a-string-number"},"Why can't I pass ",(0,o.mdx)("inlineCode",{parentName:"h2"},"{a: string}")," to a function that takes ",(0,o.mdx)("inlineCode",{parentName:"h2"},"{a: string |\xa0number}")),(0,o.mdx)("p",null,"The function argument allows ",(0,o.mdx)("inlineCode",{parentName:"p"},"string")," values in its field, but in this case Flow prevents the original object from having a ",(0,o.mdx)("inlineCode",{parentName:"p"},"number")," written to it.\nWithin the body of the function you would be able to mutate the object so that the property ",(0,o.mdx)("inlineCode",{parentName:"p"},"a")," would receive a ",(0,o.mdx)("inlineCode",{parentName:"p"},"number"),", causing the type of the original object to no longer be accurate."),(0,o.mdx)("p",null,"You can fix this error by making the property ",(0,o.mdx)("a",{parentName:"p",href:"../lang/variance/#toc-covariance"},"covariant")," (read-only): ",(0,o.mdx)("inlineCode",{parentName:"p"},"{+a: string |\xa0number}"),".\nThis prevents the function body from writing to the property, making it safe to pass more restricted types to the function."),(0,o.mdx)("p",null,"As an example, this would not work:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":8,"startColumn":4,"endLine":8,"endColumn":9,"description":"Cannot call `fn` with `object` bound to `obj` because number [1] is incompatible with string [2] in property `a`. This property is invariantly typed. See https://flow.org/en/docs/faq/#why-cant-i-pass-a-string-to-a-function-that-takes-a-string-number. [incompatible-call]"}]','[{"startLine":8,"startColumn":4,"endLine":8,"endColumn":9,"description":"Cannot':!0,call:!0,"`fn`":!0,with:!0,"`object`":!0,bound:!0,to:!0,"`obj`":!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,string:!0,"[2]":!0,in:!0,property:!0,"`a`.":!0,This:!0,invariantly:!0,"typed.":!0,See:!0,"https://flow.org/en/docs/faq/#why-cant-i-pass-a-string-to-a-function-that-takes-a-string-number.":!0,'[incompatible-call]"}]':!0},"const fn = (obj: {a: string | number}) => {\n  obj.a = 123; // Oops! {a: string} was passed in - now inaccurate\n  return obj;\n};\n\nconst object: {a: string} = {a: 'str' };\n\nfn(object); // Error!\n")),(0,o.mdx)("p",null,"but with a covariant property you can achieve what you were looking for:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const fn = (obj: {+a: string | number}) => {\n  // obj.a = 123 NOTE! Since you are using covariant {+a: string | number}, you can't mutate it\n  return obj;\n};\n\nconst object: {a: string} = { a: 'str' };\n\nfn(object);\n")),(0,o.mdx)("h2",{id:"why-cant-i-refine-a-union-of-objects"},"Why can't I refine a union of objects?"),(0,o.mdx)("p",null,"There are two potential reasons:"),(0,o.mdx)("ol",null,(0,o.mdx)("li",{parentName:"ol"},"You are using inexact objects."),(0,o.mdx)("li",{parentName:"ol"},"You are destructuring the object. When destructuring, Flow loses track of object properties.")),(0,o.mdx)("p",null,"Broken example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":8,"startColumn":30,"endLine":8,"endColumn":35,"description":"Cannot get `payload.length` because property `length` is missing in `Number` [1]. [prop-missing]"}]','[{"startLine":8,"startColumn":30,"endLine":8,"endColumn":35,"description":"Cannot':!0,get:!0,"`payload.length`":!0,because:!0,property:!0,"`length`":!0,is:!0,missing:!0,in:!0,"`Number`":!0,"[1].":!0,'[prop-missing]"}]':!0},"type Action =\n  | {type: 'A', payload: string}\n  | {type: 'B', payload: number};\n\n// Not OK\nconst fn = ({type, payload}: Action) => {\n  switch (type) {\n    case 'A': return payload.length; // Error!\n    case 'B': return payload + 10;\n  }\n}\n")),(0,o.mdx)("p",null,"Fixed example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Action =\n  | {type: 'A', payload: string}\n  | {type: 'B', payload: number};\n\n// OK\nconst fn = (action: Action) => {\n  switch (action.type) {\n    case 'A': return action.payload.length;\n    case 'B': return action.payload + 10;\n  }\n}\n")),(0,o.mdx)("h2",{id:"i-got-a-missing-type-annotation-error-where-does-it-come-from"},'I got a "Missing type annotation" error. Where does it come from?'),(0,o.mdx)("p",null,"Flow requires type annotations at module boundaries to make sure it can scale. To read more about that, check out our ",(0,o.mdx)("a",{parentName:"p",href:"https://medium.com/flow-type/asking-for-required-annotations-64d4f9c1edf8"},"blog post")," about that."),(0,o.mdx)("p",null,"The most common case you'll encounter is when exporting a function or React component. Flow requires you to annotate inputs. For instance in this example, Flow will complain:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":20,"endLine":1,"endColumn":20,"description":"Cannot build a typed interface for this module. You should annotate the exports of this module with types. Missing type annotation at identifier: [signature-verification-failure]"},{"startLine":1,"startColumn":20,"endLine":1,"endColumn":20,"description":"Missing an annotation on `a`. [missing-local-annot]"},{"startLine":1,"startColumn":21,"endLine":1,"endColumn":20,"description":"Cannot build a typed interface for this module. You should annotate the exports of this module with types. Missing type annotation at function return: [signature-verification-failure]"}]','[{"startLine":1,"startColumn":20,"endLine":1,"endColumn":20,"description":"Cannot':!0,build:!0,a:!0,typed:!0,interface:!0,for:!0,this:!0,"module.":!0,You:!0,should:!0,annotate:!0,the:!0,exports:!0,of:!0,module:!0,with:!0,"types.":!0,Missing:!0,type:!0,annotation:!0,at:!0,"identifier:":!0,'[signature-verification-failure]"},{"startLine":1,"startColumn":20,"endLine":1,"endColumn":20,"description":"Missing':!0,an:!0,on:!0,"`a`.":!0,'[missing-local-annot]"},{"startLine":1,"startColumn":21,"endLine":1,"endColumn":20,"description":"Cannot':!0,function:!0,"return:":!0,'[signature-verification-failure]"}]':!0},"export const add = a => a + 1;\n")),(0,o.mdx)("p",null,"The fix here is to add types to the parameters of ",(0,o.mdx)("inlineCode",{parentName:"p"},"add"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"export const add = (a: number): number => a + 1;\n")),(0,o.mdx)("p",null,"To see how you can annotate exported React components, check out our docs on ",(0,o.mdx)("a",{parentName:"p",href:"../react/hoc/#toc-exporting-wrapped-components"},"HOCs"),"."),(0,o.mdx)("p",null,"There are other cases where this happens, and they might be harder to understand. You'll get an error like ",(0,o.mdx)("inlineCode",{parentName:"p"},"Missing type annotation for U")," For instance, you wrote this code:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":2,"startColumn":29,"endLine":2,"endColumn":45,"description":"Cannot build a typed interface for this module. You should annotate the exports of this module with types. Cannot determine the type of this call expression. Please provide an annotation, e.g., by adding a type cast around this expression. [signature-verification-failure]"}]','[{"startLine":2,"startColumn":29,"endLine":2,"endColumn":45,"description":"Cannot':!0,build:!0,a:!0,typed:!0,interface:!0,for:!0,this:!0,"module.":!0,You:!0,should:!0,annotate:!0,the:!0,exports:!0,of:!0,module:!0,with:!0,"types.":!0,Cannot:!0,determine:!0,type:!0,call:!0,"expression.":!0,Please:!0,provide:!0,an:!0,"annotation,":!0,"e.g.,":!0,by:!0,adding:!0,cast:!0,around:!0,'[signature-verification-failure]"}]':!0},"const array = ['a', 'b']\nexport const genericArray = array.map(a => a)\n")),(0,o.mdx)("p",null,"Here, Flow will complain on the ",(0,o.mdx)("inlineCode",{parentName:"p"},"export"),", asking for a type annotation. Flow wants you to annotate exports returned by a generic function. The type of ",(0,o.mdx)("inlineCode",{parentName:"p"},"Array.prototype.map")," is ",(0,o.mdx)("inlineCode",{parentName:"p"},"map<U>(callbackfn: (value: T, index: number, array: Array<T>) => U, thisArg?: any): Array<U>"),". The ",(0,o.mdx)("inlineCode",{parentName:"p"},"<U>")," corresponds to what is called a ",(0,o.mdx)("a",{parentName:"p",href:"../types/generics/"},"generic"),", to express the fact that the type of the function passed to map is linked to the type of the array."),(0,o.mdx)("p",null,"Understanding the logic behind generics might be useful, but what you really need to know to make your typings valid is that you need to help Flow to understand the type of ",(0,o.mdx)("inlineCode",{parentName:"p"},"genericArray"),"."),(0,o.mdx)("p",null,"You can do that by annotating the exported constant:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const array = ['a', 'b']\nexport const genericArray: Array<string> = array.map(a => a)\n")))}u.isMDXComponent=!0}}]);