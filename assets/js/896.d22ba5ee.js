"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[896],{60896:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var s=n(58168),a=(n(96540),n(15680));n(60681);const o={title:"Types & Expressions",slug:"/lang/types-and-expressions"},r=void 0,i={unversionedId:"lang/types-and-expressions",id:"lang/types-and-expressions",title:"Types & Expressions",description:"In JavaScript there are many types of values: numbers, strings, booleans,",source:"@site/docs/lang/types-and-expressions.md",sourceDirName:"lang",slug:"/lang/types-and-expressions",permalink:"/en/docs/lang/types-and-expressions",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/lang/types-and-expressions.md",tags:[],version:"current",frontMatter:{title:"Types & Expressions",slug:"/lang/types-and-expressions"},sidebar:"docsSidebar",previous:{title:"Comment Types",permalink:"/en/docs/types/comments"},next:{title:"Variable Declarations",permalink:"/en/docs/lang/variables"}},l={},p=[{value:"Figuring out types statically",id:"toc-figuring-out-types-statically",level:2},{value:"Soundness and Completeness",id:"toc-soundness-and-completeness",level:2}],u={toc:p};function m(e){let{components:t,...n}=e;return(0,a.mdx)("wrapper",(0,s.A)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"In JavaScript there are many types of values: numbers, strings, booleans,\nfunctions, objects, and more."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'1234 as number;\n"hi" as string;\ntrue as boolean;\n[1, 2] as Array<number>;\n({prop: "value"}) as {prop: string};\n(function func(s: string) {}) as string => void;\n')),(0,a.mdx)("p",null,"These values can be used in many different ways:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'1 + 2;\n"foo" + "bar";\n!true;\n[1, 2].push(3);\nconst obj = {prop: "s"};\nlet value = obj.prop;\nobj.prop = "value";\nfunction func(s: string) {}\nfunc("value");\n')),(0,a.mdx)("p",null,"All of these different expressions create a new type which is a result of the\ntypes of values and the operations run on them."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'let num: number = 1 + 2;\nlet str: string = "foo" + "bar";\n')),(0,a.mdx)("p",null,"In Flow every value and expression has a type."),(0,a.mdx)("h2",{id:"toc-figuring-out-types-statically"},"Figuring out types statically"),(0,a.mdx)("p",null,"Flow needs a way to be able to figure out the type of every expression. But it\ncan't just run your code to figure it out, if it did it would be affected by\nany issues that your code has. For example, if you created an infinite loop\nFlow would wait for it to finish forever."),(0,a.mdx)("p",null,"Instead, Flow needs to be able to figure out the type of a value by analyzing\nit without running it (static analysis). It works its way through every known\ntype and starts to figure out what all the expressions around them result in."),(0,a.mdx)("p",null,"For example, to figure out the result of the following expression, Flow needs to\nfigure out what its values are first."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"val1 + val2;\n")),(0,a.mdx)("p",null,"If the values are numbers, then the expression results in a number. If the\nvalues are strings, then the expression results in a string. There are a number\nof different possibilities here, so Flow must look up what the values are."),(0,a.mdx)("p",null,"If Flow is unable to figure out what the exact type is for each value, Flow\nmust figure out what every possible value is and check to make sure that the\ncode around it will still work with all of the possible types."),(0,a.mdx)("h2",{id:"toc-soundness-and-completeness"},"Soundness and Completeness"),(0,a.mdx)("p",null,"When you run your code, a single expression will only be run with a limited set\nof values. But still Flow checks ",(0,a.mdx)("em",{parentName:"p"},"every")," possible value. In this way Flow is\nchecking too many things or ",(0,a.mdx)("em",{parentName:"p"},"over-approximating")," what will be valid code."),(0,a.mdx)("p",null,"By checking every possible value, Flow might catch errors that will not\nactually occur when the code is run. Flow does this in order to be ",(0,a.mdx)("em",{parentName:"p"},'"sound"'),"."),(0,a.mdx)("p",null,"In type systems, ",(0,a.mdx)("strong",{parentName:"p"},(0,a.mdx)("em",{parentName:"strong"},"soundness"))," is the ability for a type checker to catch\nevery single error that ",(0,a.mdx)("em",{parentName:"p"},"might")," happen at runtime. This comes at the cost of\nsometimes catching errors that will not actually happen at runtime."),(0,a.mdx)("p",null,"On the flip-side, ",(0,a.mdx)("strong",{parentName:"p"},(0,a.mdx)("em",{parentName:"strong"},"completeness"))," is the ability for a type checker to only\never catch errors that ",(0,a.mdx)("em",{parentName:"p"},"would")," happen at runtime. This comes at the cost of\nsometimes missing errors that will happen at runtime."),(0,a.mdx)("p",null,"In an ideal world, every type checker would be both sound ",(0,a.mdx)("em",{parentName:"p"},"and")," complete so\nthat it catches ",(0,a.mdx)("em",{parentName:"p"},"every")," error that ",(0,a.mdx)("em",{parentName:"p"},"will")," happen at runtime."),(0,a.mdx)("p",null,"Flow tries to be as sound and complete as possible. But because JavaScript was\nnot designed around a type system, Flow sometimes has to make a tradeoff. When\nthis happens Flow tends to favor soundness over completeness, ensuring that\ncode doesn't have any bugs."),(0,a.mdx)("p",null,"Soundness is fine as long as Flow isn't being too noisy and preventing you from\nbeing productive. Sometimes when soundness would get in your way too much, Flow\nwill favor completeness instead. There's only a handful of cases where Flow\ndoes this."),(0,a.mdx)("p",null,"Other type systems will favor completeness instead, only reporting real errors\nin favor of possibly missing errors. Unit/Integration testing is an extreme\nform of this approach. Often this comes at the cost of missing the errors that\nare the most complicated to find, leaving that part up to the developer."))}m.isMDXComponent=!0}}]);