"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[4551],{94551:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>p});var o=n(58168),s=(n(96540),n(15680));n(60681);const a={title:"Typeof Types",slug:"/types/typeof"},i=void 0,r={unversionedId:"types/typeof",id:"types/typeof",title:"Typeof Types",description:"JavaScript has a typeof operator which returns a string describing a value.",source:"@site/docs/types/typeof.md",sourceDirName:"types",slug:"/types/typeof",permalink:"/en/docs/types/typeof",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/types/typeof.md",tags:[],version:"current",frontMatter:{title:"Typeof Types",slug:"/types/typeof"},sidebar:"docsSidebar",previous:{title:"Type Guards",permalink:"/en/docs/types/type-guards"},next:{title:"Type Casting Expressions",permalink:"/en/docs/types/casting"}},l={},p=[{value:"<code>typeof</code> type syntax",id:"toc-typeof-type-syntax",level:2},{value:"<code>typeof</code> inherits behaviors of inference",id:"toc-typeof-inherits-behaviors-of-inference",level:2},{value:"<code>typeof</code> inherits behaviors of other types",id:"toc-typeof-inherits-behaviors-of-other-types",level:2}],m={toc:p};function d(e){let{components:t,...n}=e;return(0,s.mdx)("wrapper",(0,o.A)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,s.mdx)("p",null,"JavaScript has a ",(0,s.mdx)("inlineCode",{parentName:"p"},"typeof")," operator which returns a string describing a value."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"typeof 1 === 'number'\ntypeof true === 'boolean'\ntypeof 'three' === 'string'\n")),(0,s.mdx)("p",null,"However it is limited in that this string only describes so much about the type."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"typeof {foo: true} === 'object'\ntypeof null === 'object'\ntypeof [true, false] === 'object'\n")),(0,s.mdx)("p",null,"In Flow, there is a similar ",(0,s.mdx)("inlineCode",{parentName:"p"},"typeof")," type operator, but it's much more powerful."),(0,s.mdx)("h2",{id:"toc-typeof-type-syntax"},(0,s.mdx)("inlineCode",{parentName:"h2"},"typeof")," type syntax"),(0,s.mdx)("p",null,"The ",(0,s.mdx)("inlineCode",{parentName:"p"},"typeof")," operator returns the Flow type of a given value to be used as a type."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":25,"endLine":3,"endColumn":31,"description":"Cannot assign `\'world\'` to `num3` because string [1] is incompatible with number [2]. [incompatible-type]"},{"startLine":7,"startColumn":27,"endLine":7,"endColumn":28,"description":"Cannot assign `42` to `bool3` because number [1] is incompatible with boolean [2]. [incompatible-type]"},{"startLine":11,"startColumn":25,"endLine":11,"endColumn":29,"description":"Cannot assign `false` to `str3` because boolean [1] is incompatible with string [2]. [incompatible-type]"}]','[{"startLine":3,"startColumn":25,"endLine":3,"endColumn":31,"description":"Cannot':!0,assign:!0,"`'world'`":!0,to:!0,"`num3`":!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,"[2].":!0,'[incompatible-type]"},{"startLine":7,"startColumn":27,"endLine":7,"endColumn":28,"description":"Cannot':!0,"`42`":!0,"`bool3`":!0,boolean:!0,'[incompatible-type]"},{"startLine":11,"startColumn":25,"endLine":11,"endColumn":29,"description":"Cannot':!0,"`false`":!0,"`str3`":!0,'[incompatible-type]"}]':!0},"let num1 = 42;\nlet num2: typeof num1 = 3.14;     // Works!\nlet num3: typeof num1 = 'world';  // Error!\n\nlet bool1 = true;\nlet bool2: typeof bool1 = false;  // Works!\nlet bool3: typeof bool1 = 42;     // Error!\n\nlet str1 = 'hello';\nlet str2: typeof str1 = 'world'; // Works!\nlet str3: typeof str1 = false;   // Error!\n")),(0,s.mdx)("p",null,"You can use any value with ",(0,s.mdx)("inlineCode",{parentName:"p"},"typeof"),", as long as the arugment itself is a variable or member access:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":8,"startColumn":17,"endLine":8,"endColumn":17,"description":"`typeof` can only be used to get the type of variables."}]','[{"startLine":8,"startColumn":17,"endLine":8,"endColumn":17,"description":"`typeof`':!0,can:!0,only:!0,be:!0,used:!0,to:!0,get:!0,the:!0,type:!0,of:!0,'variables."}]':!0},"let obj1 = {foo: 1, bar: true, baz: 'three'};\nlet obj2: typeof obj1 = {foo: 42, bar: false, baz: 'hello'};\nlet num: typeof obj1.bar = 1;\n\nlet arr1 = [1, 2, 3];\nlet arr2: typeof arr1 = [3, 2, 1];\n\ntype T = typeof {a: 1}; // Invalid!\n")),(0,s.mdx)("h2",{id:"toc-typeof-inherits-behaviors-of-inference"},(0,s.mdx)("inlineCode",{parentName:"h2"},"typeof")," inherits behaviors of inference"),(0,s.mdx)("p",null,"When you use ",(0,s.mdx)("inlineCode",{parentName:"p"},"typeof"),", you're taking the results of Flow's inference and\nasserting it as a type. While this can be very useful, it can also lead to some\nunexpected results."),(0,s.mdx)("p",null,"For example, when you use literal values in Flow, their inferred type is the\nprimitive that it belongs to. Thus, the number 42 has the inferred type of\n",(0,s.mdx)("inlineCode",{parentName:"p"},"number"),". You can see this when you use ",(0,s.mdx)("inlineCode",{parentName:"p"},"typeof"),"."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"let num1 = 42;\nlet num2: typeof num1 = 3.14;    // Works!\n\nlet bool1 = true;\nlet bool2: typeof bool1 = false; // Works!\n\nlet str1 = 'hello';\nlet str2: typeof str1 = 'world'; // Works!\n")),(0,s.mdx)("p",null,"However, this only happens with the inferred type. If you specify the literal\ntype, it will be used in ",(0,s.mdx)("inlineCode",{parentName:"p"},"typeof"),"."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":2,"startColumn":25,"endLine":2,"endColumn":28,"description":"Cannot assign `3.14` to `num2` because number [1] is incompatible with number literal `42` [2]. [incompatible-type]"},{"startLine":5,"startColumn":27,"endLine":5,"endColumn":31,"description":"Cannot assign `false` to `bool2` because boolean [1] is incompatible with boolean literal `true` [2]. [incompatible-type]"},{"startLine":8,"startColumn":25,"endLine":8,"endColumn":31,"description":"Cannot assign `\'world\'` to `str2` because string [1] is incompatible with string literal `hello` [2]. [incompatible-type]"}]','[{"startLine":2,"startColumn":25,"endLine":2,"endColumn":28,"description":"Cannot':!0,assign:!0,"`3.14`":!0,to:!0,"`num2`":!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,literal:!0,"`42`":!0,"[2].":!0,'[incompatible-type]"},{"startLine":5,"startColumn":27,"endLine":5,"endColumn":31,"description":"Cannot':!0,"`false`":!0,"`bool2`":!0,boolean:!0,"`true`":!0,'[incompatible-type]"},{"startLine":8,"startColumn":25,"endLine":8,"endColumn":31,"description":"Cannot':!0,"`'world'`":!0,"`str2`":!0,string:!0,"`hello`":!0,'[incompatible-type]"}]':!0},"let num1: 42 = 42;\nlet num2: typeof num1 = 3.14;    // Error!\n\nlet bool1: true = true;\nlet bool2: typeof bool1 = false; // Error!\n\nlet str1: 'hello' = 'hello';\nlet str2: typeof str1 = 'world'; // Error!\n")),(0,s.mdx)("h2",{id:"toc-typeof-inherits-behaviors-of-other-types"},(0,s.mdx)("inlineCode",{parentName:"h2"},"typeof")," inherits behaviors of other types"),(0,s.mdx)("p",null,"There are many different types in Flow, some of these types behave differently\nthan others. These differences make sense for that particular type but not for\nothers."),(0,s.mdx)("p",null,"When you use ",(0,s.mdx)("inlineCode",{parentName:"p"},"typeof"),", you're inserting another type with all of its behaviors.\nThis can make ",(0,s.mdx)("inlineCode",{parentName:"p"},"typeof")," seem inconsistent where it is not."),(0,s.mdx)("p",null,"For example, if you use ",(0,s.mdx)("inlineCode",{parentName:"p"},"typeof")," with a class you need to remember that classes\nare ",(0,s.mdx)("em",{parentName:"p"},"nominally")," typed instead of ",(0,s.mdx)("em",{parentName:"p"},"structurally")," typed. So that two classes with\nthe same exact shape are not considered equivalent."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":9,"startColumn":29,"endLine":9,"endColumn":37,"description":"Cannot assign `YourClass` to `test1` because `YourClass` [1] is incompatible with `MyClass` [2]. [incompatible-type]"}]','[{"startLine":9,"startColumn":29,"endLine":9,"endColumn":37,"description":"Cannot':!0,assign:!0,"`YourClass`":!0,to:!0,"`test1`":!0,because:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,"`MyClass`":!0,"[2].":!0,'[incompatible-type]"}]':!0},"class MyClass {\n  method(val: number) { /* ... */ }\n}\n\nclass YourClass {\n  method(val: number) { /* ... */ }\n}\n\nlet test1: typeof MyClass = YourClass; // Error!\nlet test2: typeof MyClass = MyClass;   // Works!\n")))}d.isMDXComponent=!0}}]);