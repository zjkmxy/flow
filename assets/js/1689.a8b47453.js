"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[1689],{1689:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>p});var a=t(58168),s=(t(96540),t(15680));t(60681);const o={title:"Type Casting Expressions",slug:"/types/casting"},i=void 0,r={unversionedId:"types/casting",id:"types/casting",title:"Type Casting Expressions",description:"Sometimes it is useful to assert a type without using something like a function",source:"@site/docs/types/casting.md",sourceDirName:"types",slug:"/types/casting",permalink:"/en/docs/types/casting",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/types/casting.md",tags:[],version:"current",frontMatter:{title:"Type Casting Expressions",slug:"/types/casting"},sidebar:"docsSidebar",previous:{title:"Typeof Types",permalink:"/en/docs/types/typeof"},next:{title:"Utility Types",permalink:"/en/docs/types/utilities"}},l={},p=[{value:"Type Cast Expression Syntax",id:"toc-type-cast-expression-syntax",level:2},{value:"Type Assertions",id:"toc-type-assertions",level:3},{value:"Type Casting",id:"toc-type-casting",level:3},{value:"Adoption of <code>as</code> syntax",id:"adoption-of-as-syntax",level:3},{value:"Using type cast expressions",id:"toc-using-type-cast-expressions",level:2},{value:"Type Casting through <code>any</code>",id:"toc-type-casting-through-any",level:3},{value:"Legacy casting syntax",id:"legacy-casting-syntax",level:2}],m={toc:p};function u(e){let{components:n,...t}=e;return(0,s.mdx)("wrapper",(0,a.A)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,s.mdx)("p",null,"Sometimes it is useful to assert a type without using something like a function\nor a variable to do so. For this Flow supports an inline type cast expression\nsyntax which can be used in a number of different ways."),(0,s.mdx)("h2",{id:"toc-type-cast-expression-syntax"},"Type Cast Expression Syntax"),(0,s.mdx)("p",null,"In order to create a type cast expression, use the keyword ",(0,s.mdx)("inlineCode",{parentName:"p"},"as")," to cast the value to a type:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"value as Type\n")),(0,s.mdx)("p",null,'This can also be referred to as an "as expression".'),(0,s.mdx)("blockquote",null,(0,s.mdx)("p",{parentName:"blockquote"},"Before Flow version 0.229, the ",(0,s.mdx)("a",{parentName:"p",href:"#legacy-casting-syntax"},"legacy syntax")," ",(0,s.mdx)("inlineCode",{parentName:"p"},"(value: Type)")," was used.")),(0,s.mdx)("p",null,"Type cast expressions can appear anywhere an expression can appear:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"let val = value as Type;\nlet obj = {prop: value as Type};\nlet arr = [value as Type, value as Type] as Array<Type>;\n")),(0,s.mdx)("p",null,"The value itself can also be an expression:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"2 + 2 as number;\n")),(0,s.mdx)("p",null,"Note that the ",(0,s.mdx)("inlineCode",{parentName:"p"},"as")," operator has the same ",(0,s.mdx)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_precedence#table"},"precedence")," as ",(0,s.mdx)("inlineCode",{parentName:"p"},"in")," and ",(0,s.mdx)("inlineCode",{parentName:"p"},"instanceof"),".\nBecause of this, parentheses around the expression might be required:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":7,"endLine":1,"endColumn":7,"description":"Cannot cast `1` to boolean because number [1] is incompatible with boolean [2]. [incompatible-cast]"}]','[{"startLine":1,"startColumn":7,"endLine":1,"endColumn":7,"description":"Cannot':!0,cast:!0,"`1`":!0,to:!0,boolean:!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,"[2].":!0,'[incompatible-cast]"}]':!0},"1 === 1 as boolean; // Error!\n// Above same as `1 === (1 as boolean)\n\n(1 === 1) as boolean; // Works!\n")),(0,s.mdx)("p",null,"Additionally, when in the context of an expression statement, expressions which could ambiguously parse as statements need parens:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"({a: 1}) as {a: number}; // Needs parens to disambiguate from block statement\nconst x = {a: 1} as {a: number}; // No parens needed, as not in expression statement context\n")),(0,s.mdx)("p",null,"When you strip the types all that is left is the value:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"value as Type;\n")),(0,s.mdx)("p",null,"Is transformed into:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"value;\n")),(0,s.mdx)("h3",{id:"toc-type-assertions"},"Type Assertions"),(0,s.mdx)("p",null,"Using type cast expressions you can assert that values are certain types."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":5,"startColumn":1,"endLine":5,"endColumn":5,"description":"Cannot cast `value` to string because number [1] is incompatible with string [2]. [incompatible-cast]"}]','[{"startLine":5,"startColumn":1,"endLine":5,"endColumn":5,"description":"Cannot':!0,cast:!0,"`value`":!0,to:!0,string:!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,"[2].":!0,'[incompatible-cast]"}]':!0},"let value = 42;\n\nvalue as 42;     // Works!\nvalue as number; // Works!\nvalue as string; // Error!\n")),(0,s.mdx)("p",null,"Asserting types in this way works the same as types do anywhere else."),(0,s.mdx)("h3",{id:"toc-type-casting"},"Type Casting"),(0,s.mdx)("p",null,"When you write a type cast expression, the result of that expression is the\nvalue with the provided type. If you hold onto the resulting value, it will\nhave the new type."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":8,"startColumn":1,"endLine":8,"endColumn":8,"description":"Cannot cast `newValue` to number literal `42` because number [1] is incompatible with number literal `42` [2]. [incompatible-cast]"}]','[{"startLine":8,"startColumn":1,"endLine":8,"endColumn":8,"description":"Cannot':!0,cast:!0,"`newValue`":!0,to:!0,number:!0,literal:!0,"`42`":!0,because:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,"[2].":!0,'[incompatible-cast]"}]':!0},"let value = 42;\n\nvalue as 42;     // Works!\nvalue as number; // Works!\n\nlet newValue = value as number;\n\nnewValue as 42;     // Error!\nnewValue as number; // Works!\n")),(0,s.mdx)("p",null,"Unsafe downcasts are not allowed:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":2,"startColumn":18,"endLine":2,"endColumn":23,"description":"Cannot cast `fooObj` to object type because property `bar` is missing in object literal [1] but exists in object type [2]. [prop-missing]"}]','[{"startLine":2,"startColumn":18,"endLine":2,"endColumn":23,"description":"Cannot':!0,cast:!0,"`fooObj`":!0,to:!0,object:!0,type:!0,because:!0,property:!0,"`bar`":!0,is:!0,missing:!0,in:!0,literal:!0,"[1]":!0,but:!0,exists:!0,"[2].":!0,'[prop-missing]"}]':!0},"const fooObj = {foo: 1};\nconst otherObj = fooObj as {foo: number, bar: string};  // ERROR\n")),(0,s.mdx)("h3",{id:"adoption-of-as-syntax"},"Adoption of ",(0,s.mdx)("inlineCode",{parentName:"h3"},"as")," syntax"),(0,s.mdx)("p",null,"To use the ",(0,s.mdx)("inlineCode",{parentName:"p"},"as")," keyword for type casts, you need to upgrade your infrastructure so that it supports the syntax:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},"Flow and Flow Parser: 0.229+"),(0,s.mdx)("li",{parentName:"ul"},"Prettier: 3.1+"),(0,s.mdx)("li",{parentName:"ul"},"Babel: use the ",(0,s.mdx)("a",{parentName:"li",href:"https://www.npmjs.com/package/babel-plugin-syntax-hermes-parser"},"babel-plugin-syntax-hermes-parser")," plugin version 0.19+, see our ",(0,s.mdx)("a",{parentName:"li",href:"../../tools/babel"},"Babel guide")," for more details."),(0,s.mdx)("li",{parentName:"ul"},"ESLint: use ",(0,s.mdx)("a",{parentName:"li",href:"https://www.npmjs.com/package/hermes-eslint"},"hermes-eslint")," plugin version 0.19+, see our ",(0,s.mdx)("a",{parentName:"li",href:"../../tools/eslint"},"ESLint guide")," for more details.")),(0,s.mdx)("p",null,"For more details on how to migrate to the new casting syntax (",(0,s.mdx)("inlineCode",{parentName:"p"},"as"),") check out our ",(0,s.mdx)("a",{parentName:"p",href:"https://medium.com/flow-type/new-type-casting-syntax-for-flow-as-3ef41567ff3e"},"blog post"),"."),(0,s.mdx)("h2",{id:"toc-using-type-cast-expressions"},"Using type cast expressions"),(0,s.mdx)("blockquote",null,(0,s.mdx)("p",{parentName:"blockquote"},(0,s.mdx)("strong",{parentName:"p"},"Note:")," We're going to go through a stripped down example for\ndemonstrating how to make use of type cast expressions. This example is not\nsolved well in practice.")),(0,s.mdx)("h3",{id:"toc-type-casting-through-any"},"Type Casting through ",(0,s.mdx)("inlineCode",{parentName:"h3"},"any")),(0,s.mdx)("p",null,"Because type casts work the same as all other type annotations, you can only\ncast values to less specific types. You cannot change the type or make it\nsomething more specific."),(0,s.mdx)("p",null,"But you can use ",(0,s.mdx)("a",{parentName:"p",href:"../any"},"any")," to cast to whatever type you want."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":4,"startColumn":1,"endLine":4,"endColumn":5,"description":"Cannot cast `value` to string because number [1] is incompatible with string [2]. [incompatible-cast]"},{"startLine":8,"startColumn":1,"endLine":8,"endColumn":8,"description":"Cannot cast `newValue` to number because string [1] is incompatible with number [2]. [incompatible-cast]"}]','[{"startLine":4,"startColumn":1,"endLine":4,"endColumn":5,"description":"Cannot':!0,cast:!0,"`value`":!0,to:!0,string:!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,"[2].":!0,'[incompatible-cast]"},{"startLine":8,"startColumn":1,"endLine":8,"endColumn":8,"description":"Cannot':!0,"`newValue`":!0,'[incompatible-cast]"}]':!0},"let value = 42;\n\nvalue as number; // Works!\nvalue as string; // Error!\n\nlet newValue = value as any as string;\n\nnewValue as number; // Error!\nnewValue as string; // Works!\n")),(0,s.mdx)("p",null,"By casting the value to ",(0,s.mdx)("inlineCode",{parentName:"p"},"any"),", you can then cast to whatever you want."),(0,s.mdx)("p",null,"This is unsafe and not recommended. But it's sometimes useful when you are\ndoing something with a value which is very difficult or impossible to type and\nwant to make sure that the result has the desired type."),(0,s.mdx)("p",null,"For example, the following function for cloning an object."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function cloneObject(obj: any) {\n  const clone: {[string]: mixed} = {};\n\n  Object.keys(obj).forEach(key => {\n    clone[key] = obj[key];\n  });\n\n  return clone;\n}\n")),(0,s.mdx)("p",null,"It would be hard to create a type for this because we're creating a new object\nbased on another object."),(0,s.mdx)("p",null,"If we cast through any, we can return a type which is more useful."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function cloneObject<T: {+[key: string]: mixed }>(obj: T): T {\n  const clone: {[string]: mixed} = {};\n\n  Object.keys(obj).forEach(key => {\n    clone[key] = obj[key];\n  });\n\n  return clone as any as T;\n}\n\nconst clone = cloneObject({\n  foo: 1,\n  bar: true,\n  baz: 'three'\n});\n\nclone.foo as 1;       // Works!\nclone.bar as true;    // Works!\nclone.baz as 'three'; // Works!\n")),(0,s.mdx)("h2",{id:"legacy-casting-syntax"},"Legacy casting syntax"),(0,s.mdx)("p",null,"Before version 0.229, to create a type cast expression around a ",(0,s.mdx)("inlineCode",{parentName:"p"},"value"),", you would\nadd a colon ",(0,s.mdx)("inlineCode",{parentName:"p"},":")," with the ",(0,s.mdx)("inlineCode",{parentName:"p"},"Type")," and wrap the expression with parentheses ",(0,s.mdx)("inlineCode",{parentName:"p"},"(")," ",(0,s.mdx)("inlineCode",{parentName:"p"},")"),"."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"(value: Type)\n")),(0,s.mdx)("blockquote",null,(0,s.mdx)("p",{parentName:"blockquote"},(0,s.mdx)("strong",{parentName:"p"},"Note:")," The parentheses are necessary to avoid ambiguity with other syntax.")))}u.isMDXComponent=!0}}]);