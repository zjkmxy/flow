"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[9942],{18430:(e,n,t)=>{t.d(n,{V:()=>r,v:()=>s});var i=t(96540);function r(e){let{version:n}=e;return i.createElement("span",{class:"version added",title:"Added in "+n},"\u2265",n)}function s(e){let{version:n}=e;return i.createElement("span",{class:"version removed",title:"Removed after "+n},"\u2264",n)}},9942:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>u});var i=t(58168),r=(t(96540),t(15680)),s=(t(60681),t(18430));const a={title:"Unions",slug:"/types/unions"},o=void 0,l={unversionedId:"types/unions",id:"types/unions",title:"Unions",description:"Sometimes it's useful to create a type which is one of a set of other",source:"@site/docs/types/unions.md",sourceDirName:"types",slug:"/types/unions",permalink:"/en/docs/types/unions",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/types/unions.md",tags:[],version:"current",frontMatter:{title:"Unions",slug:"/types/unions"},sidebar:"docsSidebar",previous:{title:"Generics",permalink:"/en/docs/types/generics"},next:{title:"Intersections",permalink:"/en/docs/types/intersections"}},p={},u=[{value:"Union type syntax",id:"toc-union-type-syntax",level:2},{value:"Union shorthands",id:"union-shorthands",level:2},{value:"Unions &amp; Refinements",id:"toc-unions-refinements",level:2},{value:"Union types requires one in, but all out",id:"toc-union-types-requires-one-in-but-all-out",level:2},{value:"Disjoint Object Unions",id:"toc-disjoint-object-unions",level:2},{value:"Disjoint object unions with exact types",id:"toc-disjoint-unions-with-exact-types",level:3},{value:"Disjoint tuple unions",id:"disjoint-tuple-unions",level:2}],m={toc:u};function d(e){let{components:n,...t}=e;return(0,r.mdx)("wrapper",(0,i.A)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"Sometimes it's useful to create a type which is ",(0,r.mdx)("strong",{parentName:"p"},(0,r.mdx)("em",{parentName:"strong"},"one of"))," a set of other\ntypes. For example, you might want to write a function which accepts a set of\nprimitive value types. For this Flow supports ",(0,r.mdx)("strong",{parentName:"p"},"union types"),"."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":9,"startColumn":20,"endLine":9,"endColumn":32,"description":"Cannot call `toStringPrimitives` with object literal bound to `value` because: [incompatible-call] Either object literal [1] is incompatible with number [2]. Or object literal [1] is incompatible with boolean [3]. Or object literal [1] is incompatible with string [4]."},{"startLine":10,"startColumn":20,"endLine":10,"endColumn":34,"description":"Cannot call `toStringPrimitives` with array literal bound to `value` because: [incompatible-call] Either array literal [1] is incompatible with number [2]. Or array literal [1] is incompatible with boolean [3]. Or array literal [1] is incompatible with string [4]."}]','[{"startLine":9,"startColumn":20,"endLine":9,"endColumn":32,"description":"Cannot':!0,call:!0,"`toStringPrimitives`":!0,with:!0,object:!0,literal:!0,bound:!0,to:!0,"`value`":!0,"because:":!0,"[incompatible-call]":!0,Either:!0,"[1]":!0,is:!0,incompatible:!0,number:!0,"[2].":!0,Or:!0,boolean:!0,"[3].":!0,string:!0,'[4]."},{"startLine":10,"startColumn":20,"endLine":10,"endColumn":34,"description":"Cannot':!0,array:!0,'[4]."}]':!0},"function toStringPrimitives(value: number | boolean | string): string {\n  return String(value);\n}\n\ntoStringPrimitives(1);       // Works!\ntoStringPrimitives(true);    // Works!\ntoStringPrimitives('three'); // Works!\n\ntoStringPrimitives({prop: 'val'}); // Error!\ntoStringPrimitives([1, 2, 3, 4, 5]); // Error!\n")),(0,r.mdx)("h2",{id:"toc-union-type-syntax"},"Union type syntax"),(0,r.mdx)("p",null,"Union types are any number of types which are joined by a vertical bar ",(0,r.mdx)("inlineCode",{parentName:"p"},"|"),"."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"Type1 | Type2 | ... | TypeN\n")),(0,r.mdx)("p",null,"You may also add a leading vertical bar which is useful when breaking union\ntypes onto multiple lines."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"type Foo =\n  | Type1\n  | Type2\n  | ...\n  | TypeN\n")),(0,r.mdx)("p",null,"Each of the members of a union type can be any type, even another union type."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Numbers = 1 | 2;\ntype Colors = 'red' | 'blue'\n\ntype Fish = Numbers | Colors;\n")),(0,r.mdx)("p",null,"If you have enabled ",(0,r.mdx)("a",{parentName:"p",href:"../../enums/"},"Flow Enums"),", they may be an alternative to unions of ",(0,r.mdx)("a",{parentName:"p",href:"../literals"},"literal types"),"."),(0,r.mdx)("h2",{id:"union-shorthands"},"Union shorthands"),(0,r.mdx)("p",null,"The union of some type ",(0,r.mdx)("inlineCode",{parentName:"p"},"T")," with ",(0,r.mdx)("inlineCode",{parentName:"p"},"null")," or ",(0,r.mdx)("inlineCode",{parentName:"p"},"void")," is common, so we provide a shorthand called ",(0,r.mdx)("a",{parentName:"p",href:"../maybe"},"maybe types"),", by using the ",(0,r.mdx)("inlineCode",{parentName:"p"},"?")," prefix. The type ",(0,r.mdx)("inlineCode",{parentName:"p"},"?T")," is equivalent to ",(0,r.mdx)("inlineCode",{parentName:"p"},"T | null | void"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function maybeString(x: ?string) { /* ... */ }\nmaybeString('hi'); // Works!\nmaybeString(null); // Works!\nmaybeString(undefined); // Works!\n")),(0,r.mdx)("p",null,"The union of every single type that exists is the ",(0,r.mdx)("a",{parentName:"p",href:"../mixed"},(0,r.mdx)("inlineCode",{parentName:"a"},"mixed"))," type:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function everything(x: mixed) { /* ... */ }\neverything(1); // Works!\neverything(true); // Works!\neverything(null); // Works!\neverything({foo: 1}); // Works!\neverything(new Error()); // Works!\n")),(0,r.mdx)("h2",{id:"toc-unions-refinements"},"Unions & Refinements"),(0,r.mdx)("p",null,"When you have a value which is a union type it's often useful to break it apart\nand handle each individual type separately. With union types in Flow you can\n",(0,r.mdx)("a",{parentName:"p",href:"../../lang/refinements"},"refine")," the value down to a single type."),(0,r.mdx)("p",null,"For example, if we have a value with a union type that is a ",(0,r.mdx)("inlineCode",{parentName:"p"},"number"),", a\n",(0,r.mdx)("inlineCode",{parentName:"p"},"boolean"),", or a ",(0,r.mdx)("inlineCode",{parentName:"p"},"string"),", we can treat the number case separately by using\nJavaScript's ",(0,r.mdx)("inlineCode",{parentName:"p"},"typeof")," operator."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function toStringPrimitives(value: number | boolean | string) {\n  if (typeof value === 'number') {\n    return value.toLocaleString([], {maximumSignificantDigits: 3}); // Works!\n  }\n  // ...\n}\n")),(0,r.mdx)("p",null,"By checking the ",(0,r.mdx)("inlineCode",{parentName:"p"},"typeof")," our value and testing to see if it is a ",(0,r.mdx)("inlineCode",{parentName:"p"},"number"),", Flow\nknows that inside of that block it is only a number. We can then write code\nwhich treats our value as a number inside of that block."),(0,r.mdx)("h2",{id:"toc-union-types-requires-one-in-but-all-out"},"Union types requires one in, but all out"),(0,r.mdx)("p",null,"When calling a function that accepts a union type we must pass in ",(0,r.mdx)("strong",{parentName:"p"},(0,r.mdx)("em",{parentName:"strong"},"one of\nthose types")),". But inside of the function we are required to handle ",(0,r.mdx)("strong",{parentName:"p"},(0,r.mdx)("em",{parentName:"strong"},"all of\nthe possible types")),"."),(0,r.mdx)("p",null,"Let's rewrite the function to handle each type individually using ",(0,r.mdx)("a",{parentName:"p",href:"../../lang/refinements"},"refinements"),"."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function toStringPrimitives(value: number | boolean | string): string {\n  if (typeof value === 'number') {\n    return String(value);\n  } else if (typeof value === 'boolean') {\n    return String(value);\n  }\n  return value; // If we got here, it's a `string`!\n}\n")),(0,r.mdx)("p",null,"If we do not handle each possible type of our value, Flow will give us an error:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":5,"startColumn":10,"endLine":5,"endColumn":14,"description":"Cannot return `value` because boolean [1] is incompatible with string [2]. [incompatible-return]"}]','[{"startLine":5,"startColumn":10,"endLine":5,"endColumn":14,"description":"Cannot':!0,return:!0,"`value`":!0,because:!0,boolean:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,string:!0,"[2].":!0,'[incompatible-return]"}]':!0},"function toStringPrimitives(value: number | boolean | string): string {\n  if (typeof value === 'number') {\n    return String(value);\n  }\n  return value; // Error!\n}\n")),(0,r.mdx)("h2",{id:"toc-disjoint-object-unions"},"Disjoint Object Unions"),(0,r.mdx)("p",null,'There\'s a special type of union in Flow known as a "disjoint object union" which can\nbe used with ',(0,r.mdx)("a",{parentName:"p",href:"../../lang/refinements/"},"refinements"),". These disjoint object unions are\nmade up of any number of object types which are each tagged by a single property."),(0,r.mdx)("p",null,"For example, imagine we have a function for handling a response from a server\nafter we've sent it a request. When the request is successful, we'll get back\nan object with a ",(0,r.mdx)("inlineCode",{parentName:"p"},"type")," property set to ",(0,r.mdx)("inlineCode",{parentName:"p"},"'success'")," and a ",(0,r.mdx)("inlineCode",{parentName:"p"},"value")," that we've\nupdated."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"{type: 'success', value: 23}\n")),(0,r.mdx)("p",null,"When the request fails, we'll get back an object with ",(0,r.mdx)("inlineCode",{parentName:"p"},"type")," set to ",(0,r.mdx)("inlineCode",{parentName:"p"},"'error'"),"\nand an ",(0,r.mdx)("inlineCode",{parentName:"p"},"error")," property describing the error."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"{type: 'error', error: 'Bad request'}\n")),(0,r.mdx)("p",null,"We can try to express both of these objects in a single object type. However,\nwe'll quickly run into issues where we know a property exists based on the\n",(0,r.mdx)("inlineCode",{parentName:"p"},"type")," property but Flow does not."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":9,"startColumn":27,"endLine":9,"endColumn":40,"description":"Cannot assign `response.value` to `value` because undefined [1] is incompatible with number [2]. [incompatible-type]"},{"startLine":11,"startColumn":27,"endLine":11,"endColumn":40,"description":"Cannot assign `response.error` to `error` because undefined [1] is incompatible with string [2]. [incompatible-type]"}]','[{"startLine":9,"startColumn":27,"endLine":9,"endColumn":40,"description":"Cannot':!0,assign:!0,"`response.value`":!0,to:!0,"`value`":!0,because:!0,undefined:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,"[2].":!0,'[incompatible-type]"},{"startLine":11,"startColumn":27,"endLine":11,"endColumn":40,"description":"Cannot':!0,"`response.error`":!0,"`error`":!0,string:!0,'[incompatible-type]"}]':!0},"type Response = {\n  type: 'success' | 'error',\n  value?: number,\n  error?: string\n};\n\nfunction handleResponse(response: Response) {\n  if (response.type === 'success') {\n    const value: number = response.value; // Error!\n  } else {\n    const error: string = response.error; // Error!\n  }\n}\n")),(0,r.mdx)("p",null,"Trying to combine these two separate types into a single one will only cause us\ntrouble."),(0,r.mdx)("p",null,"Instead, if we create a union type of both object types, Flow will be able to\nknow which object we're using based on the ",(0,r.mdx)("inlineCode",{parentName:"p"},"type")," property."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Response =\n  | {type: 'success', value: number}\n  | {type: 'error', error: string};\n\nfunction handleResponse(response: Response) {\n  if (response.type === 'success') {\n    const value: number = response.value; // Works!\n  } else {\n    const error: string = response.error; // Works!\n  }\n}\n")),(0,r.mdx)("p",null,"In order to use this pattern, there must be a key that is in every object in your union (in our example above, ",(0,r.mdx)("inlineCode",{parentName:"p"},"type"),"),\nand every object must set a different ",(0,r.mdx)("a",{parentName:"p",href:"../literals"},"literal type")," for that key (in our example, the string ",(0,r.mdx)("inlineCode",{parentName:"p"},"'success'"),", and the string ",(0,r.mdx)("inlineCode",{parentName:"p"},"'error'"),").\nYou can use any kind of literal type, including numbers and booleans."),(0,r.mdx)("h3",{id:"toc-disjoint-unions-with-exact-types"},"Disjoint object unions with exact types"),(0,r.mdx)("p",null,"Disjoint unions require you to use a single property to distinguish each object\ntype. You cannot distinguish two different ",(0,r.mdx)("a",{parentName:"p",href:"../objects/#exact-and-inexact-object-types"},"inexact objects")," by different properties."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":37,"endLine":6,"endColumn":41,"description":"Cannot get `response.value` because property `value` is missing in `Failed` [1]. [prop-missing]"}]','[{"startLine":6,"startColumn":37,"endLine":6,"endColumn":41,"description":"Cannot':!0,get:!0,"`response.value`":!0,because:!0,property:!0,"`value`":!0,is:!0,missing:!0,in:!0,"`Failed`":!0,"[1].":!0,'[prop-missing]"}]':!0},"type Success = {success: true, value: boolean, ...};\ntype Failed  = {error: true, message: string, ...};\n\nfunction handleResponse(response:  Success | Failed) {\n  if (response.success) {\n    const value: boolean = response.value; // Error!\n  }\n}\n")),(0,r.mdx)("p",null,"This is because in Flow it is okay to pass an object value with more properties\nthan the inexact object type expects (because of ",(0,r.mdx)("a",{parentName:"p",href:"../../lang/width-subtyping/"},"width subtyping"),")."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Success = {success: true, value: boolean, ...};\ntype Failed  = {error: true, message: string, ...};\n\nfunction handleResponse(response:  Success | Failed) {\n  // ...\n}\n\nhandleResponse({\n  success: true,\n  error: true,\n  value: true,\n  message: 'hi'\n});\n")),(0,r.mdx)("p",null,"Unless the objects somehow conflict with one another there is no way to\ndistinguish them."),(0,r.mdx)("p",null,"However, to get around this you could use ",(0,r.mdx)("strong",{parentName:"p"},"exact object types"),"."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Success = {success: true, value: boolean};\ntype Failed  = {error: true, message: string};\n\ntype Response = Success | Failed;\n\nfunction handleResponse(response: Response) {\n  if (response.success) {\n    const value: boolean = response.value;\n  } else {\n    const message: string = response.message;\n  }\n}\n")),(0,r.mdx)("p",null,"With exact object types, we cannot have additional properties, so the objects\nconflict with one another and we are able to distinguish which is which."),(0,r.mdx)("h2",{id:"disjoint-tuple-unions"},"Disjoint tuple unions"),(0,r.mdx)("p",null,"Like disjoint object unions explained above, you can also define disjoint tuple unions (support in Flow version ",(0,r.mdx)(s.V,{version:"0.240",mdxType:"SinceVersion"}),").\nThese are unions of tuple types, where each tuple is tagged by a particular element. For example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Response =\n  | ['success', number]\n  | ['error', string];\n\nfunction handleResponse(response: Response) {\n  if (response[0] === 'success') {\n    const value: number = response[1]; // Works!\n  } else {\n    const error: string = response[1]; // Works!\n  }\n}\n")),(0,r.mdx)("p",null,"This feature is particularly useful for function arguments, which are tuples.\nNote the use of ",(0,r.mdx)("a",{parentName:"p",href:"../tuples/#tuple-element-labels"},"tuple element labels")," to make the code more clear."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",2:!0,3:!0,className:"language-flow",metastring:'[{"startLine":16,"startColumn":1,"endLine":16,"endColumn":11,"description":"Cannot call `prettyPrint` because: [incompatible-call] Either string [1] is incompatible with string literal `choice` [2] in index 0. Or rest array [3] has 2 elements but tuple type [4] has 3 elements."},{"startLine":17,"startColumn":1,"endLine":17,"endColumn":11,"description":"Cannot call `prettyPrint` because: [incompatible-call] Either string [1] is incompatible with string literal `choice` [2] in index 0. Or rest array [3] has 2 elements but tuple type [4] has 3 elements."}]','[{"startLine":16,"startColumn":1,"endLine":16,"endColumn":11,"description":"Cannot':!0,call:!0,"`prettyPrint`":!0,"because:":!0,"[incompatible-call]":!0,Either:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,literal:!0,"`choice`":!0,"[2]":!0,in:!0,index:!0,"0.":!0,Or:!0,rest:!0,array:!0,"[3]":!0,has:!0,elements:!0,but:!0,tuple:!0,type:!0,"[4]":!0,'elements."},{"startLine":17,"startColumn":1,"endLine":17,"endColumn":11,"description":"Cannot':!0,'elements."}]':!0},"function prettyPrint(\n  ...args: ['currency', dollars: number, cents: number]\n         | ['choice', boolean]\n): string {\n  switch (args[0]) {\n    case 'currency':\n      return args[1] + '.' + args[2];\n    case 'choice':\n      return args[1] ? 'yes' : 'no';\n  }\n}\n// Argument types based on the first arg\nprettyPrint(\"currency\", 1, 50); // OK\nprettyPrint(\"choice\", true); // OK\n\nprettyPrint(\"currency\", 1); // ERROR - missing arg\nprettyPrint(\"currency\", true); // ERROR - wrong type arg\n")))}d.isMDXComponent=!0}}]);