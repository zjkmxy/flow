"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[9352],{49352:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>s});var a=t(58168),i=(t(96540),t(15680));t(60681);const o={title:"Conditional Types",slug:"/types/conditional"},l=void 0,r={unversionedId:"types/conditional",id:"types/conditional",title:"Conditional Types",description:"Flow's conditional type allows you to conditionally choose between two different output types by inspecting an input type. It is useful to extract parts of a type, or to describe a complex overload.",source:"@site/docs/types/conditional.md",sourceDirName:"types",slug:"/types/conditional",permalink:"/en/docs/types/conditional",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/types/conditional.md",tags:[],version:"current",frontMatter:{title:"Conditional Types",slug:"/types/conditional"},sidebar:"docsSidebar",previous:{title:"Indexed Access Types",permalink:"/en/docs/types/indexed-access"},next:{title:"Mapped Types",permalink:"/en/docs/types/mapped-types"}},p={},s=[{value:"Basic Usage",id:"toc-basic-usage",level:2},{value:"Generic Conditional Types",id:"toc-generic-conditional-types",level:2},{value:"Function return types dependent on input types",id:"toc-dependent-function-return",level:2},{value:"Inferring Within Conditional Types",id:"toc-infer-type",level:2},{value:"Distributive Conditional Types",id:"toc-distributive-conditional-type",level:2},{value:"Adoption",id:"toc-adoption",level:2}],d={toc:s};function u(e){let{components:n,...t}=e;return(0,i.mdx)("wrapper",(0,a.A)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"Flow's conditional type allows you to conditionally choose between two different output types by inspecting an input type. It is useful to extract parts of a type, or to describe a complex overload."),(0,i.mdx)("h2",{id:"toc-basic-usage"},"Basic Usage"),(0,i.mdx)("p",null,"It has a syntax that is similar to conditional expressions: ",(0,i.mdx)("inlineCode",{parentName:"p"},"CheckType extends ExtendsType ? TrueType : FalseType"),"."),(0,i.mdx)("p",null,"If ",(0,i.mdx)("inlineCode",{parentName:"p"},"CheckType")," is a subtype of ",(0,i.mdx)("inlineCode",{parentName:"p"},"ExtendsType"),", the conditional type will be evaluated to ",(0,i.mdx)("inlineCode",{parentName:"p"},"TrueType"),". Otherwise, it will be evaluated to ",(0,i.mdx)("inlineCode",{parentName:"p"},"FalseType"),"."),(0,i.mdx)("p",null,"The following example illustrates both cases."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"class Animal {}\nclass Dog extends Animal {}\n\ntype TypeofAnimal = Dog extends Animal ? 'animal' : 'unknown'; // evaluates to 'animal'\ntype TypeofString = string extends Animal ? 'animal' : 'unknown'; // evaluates to 'unknown'\n")),(0,i.mdx)("h2",{id:"toc-generic-conditional-types"},"Generic Conditional Types"),(0,i.mdx)("p",null,"This might not look very useful, since you already know what type it will evaluate to. However, combining with generics, you can perform complex computations over types. For example, you can write down a type-level ",(0,i.mdx)("inlineCode",{parentName:"p"},"typeof")," operator:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type TypeOf<T> =\n  T extends null ? 'null' :\n  T extends void ? 'undefined' :\n  T extends string ? 'string' :\n  T extends number ? 'number' :\n  T extends boolean ? 'boolean' :\n  T extends (...$ReadOnlyArray<empty>)=>mixed ? 'function' : 'object'\n\ntype T1 = TypeOf<null>; // evaluates to 'null'\ntype T2 = TypeOf<void>; // evaluates to 'undefined'\ntype T3 = TypeOf<string>; // evaluates to 'string'\ntype T4 = TypeOf<number>; // evaluates to 'number'\ntype T5 = TypeOf<boolean>; // evaluates to 'boolean'\ntype T6 = TypeOf<(string)=>boolean>; // evaluates to 'function'\ntype T7 = TypeOf<{foo: string}>; // evaluates to 'object'\n")),(0,i.mdx)("h2",{id:"toc-dependent-function-return"},"Function return types dependent on input types"),(0,i.mdx)("p",null,"Conditional types also allow you to intuitively describe the conditions for choosing different function overloads:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"declare function wrap<T>(value: T): T extends string ? { type: 'string', value: string }\n                                  : T extends number ? { type: 'number', value: number }\n                                  : { type: 'unsupported' }\n\nconst v1 = wrap(3);   // has type { type: 'number', value: number }\nconst v2 = wrap('4'); // has type { type: 'string', value: string }\nconst v3 = wrap({});  // has type { type: 'unsupported' }\n")),(0,i.mdx)("p",null,"The above example can also be written with function overload:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"declare function wrap(value: string): { type: 'string', value: string }\ndeclare function wrap(value: number): { type: 'number', value: number }\ndeclare function wrap(value: mixed): { type: 'unsupported' }\n\nconst v1 = wrap(3);   // has type { type: 'number', value: number }\nconst v2 = wrap('4'); // has type { type: 'string', value: string }\nconst v3 = wrap({});  // has type { type: 'unsupported' }\n")),(0,i.mdx)("h2",{id:"toc-infer-type"},"Inferring Within Conditional Types"),(0,i.mdx)("p",null,"You can use the power of conditional types to extract parts of a type using ",(0,i.mdx)("inlineCode",{parentName:"p"},"infer")," types. For example, the builtin ",(0,i.mdx)("inlineCode",{parentName:"p"},"ReturnType")," is powered by conditional types:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type ReturnType<T> = T extends (...args: $ReadOnlyArray<empty>) => infer Return ? Return : empty;\n\ntype N = ReturnType<(string) => number>; // evaluates to `number`\ntype S = ReturnType<(number) => string>; // evaluates to `string`\n")),(0,i.mdx)("p",null,"We used the infer type here to introduce a new generic type variable named ",(0,i.mdx)("inlineCode",{parentName:"p"},"Return"),", which can be used in the type branch of the conditional type. Infer types can only appear on the right hand side of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"extends")," clause in conditional types. Flow will perform a subtyping check between the check type and the extends type to automatically figure out its type based on the input type ",(0,i.mdx)("inlineCode",{parentName:"p"},"T"),"."),(0,i.mdx)("p",null,"In the example of ",(0,i.mdx)("inlineCode",{parentName:"p"},"type N = ReturnType<(string) => number>"),", Flow checks if ",(0,i.mdx)("inlineCode",{parentName:"p"},"(string) => number")," is a subtype of ",(0,i.mdx)("inlineCode",{parentName:"p"},"(...args: $ReadOnlyArray<empty>) => infer Return"),", and during this process ",(0,i.mdx)("inlineCode",{parentName:"p"},"Return")," is constrained to ",(0,i.mdx)("inlineCode",{parentName:"p"},"number"),"."),(0,i.mdx)("p",null,"When doing extractions like the above example, you usually want the conditional type to always choose the true branch where the type is successfully extracted. For example, silently choosing the false branch is not great:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type ExtractReturnTypeNoValidation<T> =\n  T extends (...args: $ReadOnlyArray<empty>) => infer Return ? Return : any;\n\n1 as ExtractReturnTypeNoValidation<string>; // no error :(\n")),(0,i.mdx)("p",null,"Instead, you might want Flow to error when the input is not a function type. This can be accomplished by adding constraints to the type parameter:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":5,"startColumn":17,"endLine":5,"endColumn":22,"description":"Cannot instantiate `ReturnType` because string [1] is incompatible with function type [2] in type argument `T`. [incompatible-type-arg]"}]','[{"startLine":5,"startColumn":17,"endLine":5,"endColumn":22,"description":"Cannot':!0,instantiate:!0,"`ReturnType`":!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,function:!0,type:!0,"[2]":!0,in:!0,argument:!0,"`T`.":!0,'[incompatible-type-arg]"}]':!0},"type ReturnType<T: (...args: $ReadOnlyArray<empty>) => mixed> =\n  T extends (...args: $ReadOnlyArray<empty>) => infer Return ? Return : any;\n\n1 as ReturnType<(string) => number>;\n1 as ReturnType<string>;\n")),(0,i.mdx)("h2",{id:"toc-distributive-conditional-type"},"Distributive Conditional Types"),(0,i.mdx)("p",null,"When a generic conditional type is given a union type as a type argument, the conditional ",(0,i.mdx)("em",{parentName:"p"},"distributes")," over the union's members. For example, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"TypeOf")," example above can distribute over a union:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type TypeOf<T> =\n  T extends null ? 'null' :\n  T extends void ? 'undefined' :\n  T extends string ? 'string' : 'other';\n\ntype StringOrNull = TypeOf<string | null>; // evaluates to 'string' | 'null'\n")),(0,i.mdx)("p",null,"This works by first breaking up the union type, and then passing each type to the conditional type to be evaluated separately. In the example above, this looks something like:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"TypeOf<string | null>\n--\x3e (break up the union) --\x3e TypeOf<string> | TypeOf<null>\n--\x3e (evaluate each conditional type separately) --\x3e 'string' | 'null'\n")),(0,i.mdx)("p",null,"If you want to avoid this behavior, you can wrap the check type and extends type with unary tuple type:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type NonDistributiveTypeOf<T> =\n  [T] extends [null] ? 'null' :\n  [T] extends [void] ? 'undefined' :\n  [T] extends [string] ? 'string' : 'other';\n\ntype Other = NonDistributiveTypeOf<string | null>; // evaluates to 'other'\n")),(0,i.mdx)("p",null,"This trick works because Flow will only enable the distributive behavior of conditional type if the check type is a generic type. The example above does not choose any true branch of the conditional type, because ",(0,i.mdx)("inlineCode",{parentName:"p"},"[string | null]")," is not a subtype of ",(0,i.mdx)("inlineCode",{parentName:"p"},"[null]"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"[void]"),", or ",(0,i.mdx)("inlineCode",{parentName:"p"},"[string]"),", since tuples are ",(0,i.mdx)("a",{parentName:"p",href:"../../lang/variance/#toc-invariance"},"invariantly")," typed."),(0,i.mdx)("h2",{id:"toc-adoption"},"Adoption"),(0,i.mdx)("p",null,"To use conditional types, you need to upgrade your infrastructure so that it supports the syntax:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"flow")," and ",(0,i.mdx)("inlineCode",{parentName:"li"},"flow-parser"),": 0.208.0. Between v0.208 to v0.211.1, you need to explicitly enable it in your .flowconfig, under the ",(0,i.mdx)("inlineCode",{parentName:"li"},"[options]")," heading, add ",(0,i.mdx)("inlineCode",{parentName:"li"},"conditional_type=true"),"."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"prettier"),": 3"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"babel")," with ",(0,i.mdx)("inlineCode",{parentName:"li"},"babel-plugin-syntax-hermes-parser"),". See ",(0,i.mdx)("a",{parentName:"li",href:"../../tools/babel/"},"our Babel guide")," for setup instructions."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"eslint")," with ",(0,i.mdx)("inlineCode",{parentName:"li"},"hermes-eslint"),". See ",(0,i.mdx)("a",{parentName:"li",href:"../../tools/eslint/"},"our ESLint guide")," for setup instructions.")))}u.isMDXComponent=!0}}]);