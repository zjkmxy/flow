"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[5250],{55250:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>p});var i=t(58168),o=(t(96540),t(15680));t(60681);const a={title:"Intersections",slug:"/types/intersections"},s=void 0,r={unversionedId:"types/intersections",id:"types/intersections",title:"Intersections",description:"Sometimes it is useful to create a type which is all of a set of other",source:"@site/docs/types/intersections.md",sourceDirName:"types",slug:"/types/intersections",permalink:"/en/docs/types/intersections",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/types/intersections.md",tags:[],version:"current",frontMatter:{title:"Intersections",slug:"/types/intersections"},sidebar:"docsSidebar",previous:{title:"Unions",permalink:"/en/docs/types/unions"},next:{title:"Indexed Access Types",permalink:"/en/docs/types/indexed-access"}},l={},p=[{value:"Intersection type syntax",id:"toc-intersection-type-syntax",level:2},{value:"Intersection types require all in, but one out",id:"intersection-types-require-all-in-but-one-out",level:2},{value:"Intersection of function types",id:"toc-intersection-of-function-types",level:2},{value:"Calling an overloaded function",id:"calling-an-overloaded-function",level:3},{value:"Declaring overloaded functions",id:"declaring-overloaded-functions",level:3},{value:"Intersections of object types",id:"toc-intersections-of-object-types",level:2},{value:"Impossible intersection types",id:"toc-impossible-intersection-types",level:2}],c={toc:p};function m(e){let{components:n,...t}=e;return(0,o.mdx)("wrapper",(0,i.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"Sometimes it is useful to create a type which is ",(0,o.mdx)("strong",{parentName:"p"},(0,o.mdx)("em",{parentName:"strong"},"all of"))," a set of other\ntypes. For example, you might want to write a function which accepts a value that\nimplements two different ",(0,o.mdx)("a",{parentName:"p",href:"../interfaces"},"interfaces"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":20,"startColumn":6,"endLine":20,"endColumn":16,"description":"Cannot call `func` with object literal bound to `value` because property `serialize` is missing in object literal [1] but exists in `Serializable` [2]. [prop-missing]"}]','[{"startLine":20,"startColumn":6,"endLine":20,"endColumn":16,"description":"Cannot':!0,call:!0,"`func`":!0,with:!0,object:!0,literal:!0,bound:!0,to:!0,"`value`":!0,because:!0,property:!0,"`serialize`":!0,is:!0,missing:!0,in:!0,"[1]":!0,but:!0,exists:!0,"`Serializable`":!0,"[2].":!0,'[prop-missing]"}]':!0},"interface Serializable {\n  serialize(): string;\n}\n\ninterface HasLength {\n  length: number;\n}\n\nfunction func(value: Serializable & HasLength) {\n  // ...\n}\n\nfunc({\n  length: 3,\n  serialize() {\n    return '3';\n  },\n}); // Works\n\nfunc({length: 3}); // Error! Doesn't implement both interfaces\n")),(0,o.mdx)("h2",{id:"toc-intersection-type-syntax"},"Intersection type syntax"),(0,o.mdx)("p",null,"Intersection types are any number of types which are joined by an ampersand ",(0,o.mdx)("inlineCode",{parentName:"p"},"&"),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},"Type1 & Type2 & ... & TypeN\n")),(0,o.mdx)("p",null,"You may also add a leading ampersand which is useful when breaking intersection\ntypes onto multiple lines."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},"type Foo =\n  & Type1\n  & Type2\n  & ...\n  & TypeN\n")),(0,o.mdx)("p",null,"Each of the members of a intersection type can be any type, even another\nintersection type."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},"type Foo = Type1 & Type2;\ntype Bar = Type3 & Type4;\n\ntype Baz = Foo & Bar;\n")),(0,o.mdx)("h2",{id:"intersection-types-require-all-in-but-one-out"},"Intersection types require all in, but one out"),(0,o.mdx)("p",null,"Intersection types are the opposite of union types. When calling a function\nthat accepts an intersection type, we must pass in ",(0,o.mdx)("strong",{parentName:"p"},(0,o.mdx)("em",{parentName:"strong"},"all of those types")),". But\ninside of our function we only have to treat it as ",(0,o.mdx)("strong",{parentName:"p"},(0,o.mdx)("em",{parentName:"strong"},"any one of those\ntypes")),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type A = {a: number, ...};\ntype B = {b: boolean, ...};\ntype C = {c: string, ...};\n\nfunction func(value: A & B & C) {\n  const a: A = value;\n  const b: B = value;\n  const c: C = value;\n}\n")),(0,o.mdx)("p",null,"Even as we treat our value as just one of the types, we do not get an error\nbecause it satisfies all of them."),(0,o.mdx)("h2",{id:"toc-intersection-of-function-types"},"Intersection of function types"),(0,o.mdx)("p",null,"A common use of intersection types is to express functions that return\ndifferent results based on the input we pass in. Suppose for example\nthat we want to write the type of a function that:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"returns a string, when we pass in the value ",(0,o.mdx)("inlineCode",{parentName:"li"},'"string"'),","),(0,o.mdx)("li",{parentName:"ul"},"returns a number, when we pass in the value ",(0,o.mdx)("inlineCode",{parentName:"li"},'"number"'),", and"),(0,o.mdx)("li",{parentName:"ul"},"returns any possible type (",(0,o.mdx)("inlineCode",{parentName:"li"},"mixed"),"), when we pass in any other string.")),(0,o.mdx)("p",null,"The type of this function will be"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'type Fn =\n  & ((x: "string") => string)\n  & ((x: "number") => number)\n  & ((x: string) => mixed);\n')),(0,o.mdx)("p",null,"Each line in the above definition is called an ",(0,o.mdx)("em",{parentName:"p"},"overload"),", and we say that functions\nof type ",(0,o.mdx)("inlineCode",{parentName:"p"},"Fn")," are ",(0,o.mdx)("em",{parentName:"p"},"overloaded"),"."),(0,o.mdx)("p",null,'Note the use of parentheses around the arrow types. These are necessary to override\nthe precedence of the "arrow" constructor over the intersection.'),(0,o.mdx)("h3",{id:"calling-an-overloaded-function"},"Calling an overloaded function"),(0,o.mdx)("p",null,"Using the above definition we can declare a function ",(0,o.mdx)("inlineCode",{parentName:"p"},"fn")," that has the following behavior:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":8,"startColumn":20,"endLine":8,"endColumn":32,"description":"Cannot assign `fn(...)` to `b` because mixed [1] is incompatible with boolean [2]. [incompatible-type]"}]','[{"startLine":8,"startColumn":20,"endLine":8,"endColumn":32,"description":"Cannot':!0,assign:!0,"`fn(...)`":!0,to:!0,"`b`":!0,because:!0,mixed:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,boolean:!0,"[2].":!0,'[incompatible-type]"}]':!0},'declare const fn:\n  & ((x: "string") => string)\n  & ((x: "number") => number)\n  & ((x: string) => mixed);\n\nconst s: string = fn("string"); // Works\nconst n: number = fn("number"); // Works\nconst b: boolean = fn("boolean"); // Error!\n')),(0,o.mdx)("p",null,"Flow achieves this behavior by matching the type of the argument to the ",(0,o.mdx)("em",{parentName:"p"},"first"),"\noverload with a compatible parameter type. Notice for example that the argument\n",(0,o.mdx)("inlineCode",{parentName:"p"},'"string"')," matches both the first and the last overload. Flow will\njust pick the first one. If no overload matches, Flow will raise an error at the\ncall site."),(0,o.mdx)("h3",{id:"declaring-overloaded-functions"},"Declaring overloaded functions"),(0,o.mdx)("p",null,"An equivalent way to declare the same function ",(0,o.mdx)("inlineCode",{parentName:"p"},"fn"),' would be by using consecutive\n"declare function" statements'),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'declare function fn(x: "string"): string;\ndeclare function fn(x: "number"): number;\ndeclare function fn(x: string): mixed;\n')),(0,o.mdx)("p",null,"A limitation in Flow is that it can't ",(0,o.mdx)("em",{parentName:"p"},"check")," the body of a function against\nan intersection type. In other words, if we provided the following implementation\nfor ",(0,o.mdx)("inlineCode",{parentName:"p"},"fn")," right after the above declarations"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'function fn(x: mixed) {\n  if (x === "string") { return ""; }\n  else if (x === "number") { return 0; }\n  else { return null; }\n}\n')),(0,o.mdx)("p",null,"Flow silently accepts it (and uses ",(0,o.mdx)("inlineCode",{parentName:"p"},"Fn")," as the inferred type), but does not check\nthe implementation against this signature. This makes this kind of declaration\na better suited candidate for ",(0,o.mdx)("a",{parentName:"p",href:"../../libdefs/"},"library definitions"),", where implementations are omitted."),(0,o.mdx)("h2",{id:"toc-intersections-of-object-types"},"Intersections of object types"),(0,o.mdx)("p",null,"When you create an intersection of ",(0,o.mdx)("a",{parentName:"p",href:"../objects/#exact-and-inexact-object-types"},"inexact object types"),",\nyou are saying that your object satisfies each member of the intersection."),(0,o.mdx)("p",null,"For example, when you create an intersection of two inexact objects with different sets\nof properties, it will result in an object with all of the properties."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type One = {foo: number, ...};\ntype Two = {bar: boolean, ...};\n\ntype Both = One & Two;\n\nconst value: Both = {\n  foo: 1,\n  bar: true\n};\n")),(0,o.mdx)("p",null,"When you have properties that overlap by having the same name, Flow follows the same\nstrategy as with overloaded functions: it will return the type of the first property\nthat matches this name."),(0,o.mdx)("p",null,"For example, if you merge two inexact objects with a property named ",(0,o.mdx)("inlineCode",{parentName:"p"},"prop"),", first with a\ntype of ",(0,o.mdx)("inlineCode",{parentName:"p"},"number")," and second with a type of ",(0,o.mdx)("inlineCode",{parentName:"p"},"boolean"),", accessing ",(0,o.mdx)("inlineCode",{parentName:"p"},"prop")," will return\n",(0,o.mdx)("inlineCode",{parentName:"p"},"number"),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":7,"startColumn":24,"endLine":7,"endColumn":32,"description":"Cannot assign `both.prop` to `prop2` because number [1] is incompatible with boolean [2]. [incompatible-type]"}]','[{"startLine":7,"startColumn":24,"endLine":7,"endColumn":32,"description":"Cannot':!0,assign:!0,"`both.prop`":!0,to:!0,"`prop2`":!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,boolean:!0,"[2].":!0,'[incompatible-type]"}]':!0},"type One = {prop: number, ...};\ntype Two = {prop: boolean, ...};\n\ndeclare const both: One & Two;\n\nconst prop1: number = both.prop; // Works\nconst prop2: boolean = both.prop; // Error!\n")),(0,o.mdx)("p",null,"To combine exact object types, you should use ",(0,o.mdx)("a",{parentName:"p",href:"../objects/#object-type-spread"},"object type spread")," instead:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type One = {foo: number};\ntype Two = {bar: boolean};\n\ntype Both = {\n  ...One,\n  ...Two,\n};\n\nconst value: Both = {\n  foo: 1,\n  bar: true\n};\n")),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Note:")," When it comes to objects, the order-specific way in which intersection\ntypes are implemented in Flow, may often seem counter-intuitive from a set theoretic\npoint of view. In sets, the operands of intersection can change order arbitrarily\n(commutative property). For this reason, it is a better practice to define this\nkind of operation over object types using object type spread where the ordering\nsemantics are better specified."),(0,o.mdx)("h2",{id:"toc-impossible-intersection-types"},"Impossible intersection types"),(0,o.mdx)("p",null,"Using intersection types, it is possible to create types which are impossible\nto create at runtime. Intersection types will allow you to combine any set of\ntypes, even ones that conflict with one another."),(0,o.mdx)("p",null,"For example, you can create an intersection of a number and a string."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":5,"startColumn":6,"endLine":5,"endColumn":9,"description":"Cannot call `func` with `3.14` bound to `value` because number [1] is incompatible with string [2]. [incompatible-call]"},{"startLine":6,"startColumn":6,"endLine":6,"endColumn":9,"description":"Cannot call `func` with `\'hi\'` bound to `value` because string [1] is incompatible with number [2]. [incompatible-call]"}]','[{"startLine":5,"startColumn":6,"endLine":5,"endColumn":9,"description":"Cannot':!0,call:!0,"`func`":!0,with:!0,"`3.14`":!0,bound:!0,to:!0,"`value`":!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,string:!0,"[2].":!0,'[incompatible-call]"},{"startLine":6,"startColumn":6,"endLine":6,"endColumn":9,"description":"Cannot':!0,"`'hi'`":!0,'[incompatible-call]"}]':!0},"type NumberAndString = number & string;\n\nfunction func(value: NumberAndString) { /* ... */ }\n\nfunc(3.14); // Error!\nfunc('hi'); // Error!\n")),(0,o.mdx)("p",null,"But you can't possibly create a value which is both a ",(0,o.mdx)("em",{parentName:"p"},"number and a string"),",\nbut you can create a type for it. There's no practical use for creating types\nlike this, but it's a side effect of how intersection types work."),(0,o.mdx)("p",null,"An accidental way to create an impossible type is to create an intersection of\n",(0,o.mdx)("a",{parentName:"p",href:"../objects/#exact-and-inexact-object-types"},"exact object types"),". For example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":6,"endLine":3,"endColumn":11,"description":"Cannot call `func` with object literal bound to `obj` because property `a` is missing in object type [1] but exists in object literal [2]. [prop-missing]"},{"startLine":3,"startColumn":6,"endLine":3,"endColumn":11,"description":"Cannot call `func` with object literal bound to `obj` because property `b` is missing in object literal [1] but exists in object type [2]. [prop-missing]"},{"startLine":4,"startColumn":6,"endLine":4,"endColumn":14,"description":"Cannot call `func` with object literal bound to `obj` because property `a` is missing in object literal [1] but exists in object type [2]. [prop-missing]"},{"startLine":4,"startColumn":6,"endLine":4,"endColumn":14,"description":"Cannot call `func` with object literal bound to `obj` because property `b` is missing in object type [1] but exists in object literal [2]. [prop-missing]"},{"startLine":5,"startColumn":6,"endLine":5,"endColumn":20,"description":"Cannot call `func` with object literal bound to `obj` because property `a` is missing in object type [1] but exists in object literal [2]. [prop-missing]"},{"startLine":5,"startColumn":6,"endLine":5,"endColumn":20,"description":"Cannot call `func` with object literal bound to `obj` because property `b` is missing in object type [1] but exists in object literal [2]. [prop-missing]"}]','[{"startLine":3,"startColumn":6,"endLine":3,"endColumn":11,"description":"Cannot':!0,call:!0,"`func`":!0,with:!0,object:!0,literal:!0,bound:!0,to:!0,"`obj`":!0,because:!0,property:!0,"`a`":!0,is:!0,missing:!0,in:!0,type:!0,"[1]":!0,but:!0,exists:!0,"[2].":!0,'[prop-missing]"},{"startLine":3,"startColumn":6,"endLine":3,"endColumn":11,"description":"Cannot':!0,"`b`":!0,'[prop-missing]"},{"startLine":4,"startColumn":6,"endLine":4,"endColumn":14,"description":"Cannot':!0,'[prop-missing]"},{"startLine":5,"startColumn":6,"endLine":5,"endColumn":20,"description":"Cannot':!0,'[prop-missing]"}]':!0},"function func(obj: {a: number} & {b: string}) { /* ... */ }\n\nfunc({a: 1}); // Error!\nfunc({b: 'hi'}); // Error!\nfunc({a: 1, b: 'hi'}); // Error!\n")),(0,o.mdx)("p",null,"It's not possible for an object to have exactly the property ",(0,o.mdx)("inlineCode",{parentName:"p"},"a")," and no other\nproperties, and simultaneously exactly the property ",(0,o.mdx)("inlineCode",{parentName:"p"},"b")," and no other properties."))}m.isMDXComponent=!0}}]);