"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[3393],{13393:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var o=a(58168),t=(a(96540),a(15680));a(60681);const r={title:"Flow Coverage",slug:"/cli/coverage"},i=void 0,l={unversionedId:"cli/coverage",id:"cli/coverage",title:"Flow Coverage",description:"The coverage command provides a metric of the amount of checking that Flow has",source:"@site/docs/cli/coverage.md",sourceDirName:"cli",slug:"/cli/coverage",permalink:"/en/docs/cli/coverage",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/cli/coverage.md",tags:[],version:"current",frontMatter:{title:"Flow Coverage",slug:"/cli/coverage"},sidebar:"docsSidebar",previous:{title:"Flow CLI",permalink:"/en/docs/cli"},next:{title:"Flow Annotate-Exports",permalink:"/en/docs/cli/annotate-exports"}},d={},s=[{value:"Design Space",id:"toc-design-space",level:2},{value:"Command Line Use",id:"toc-command-line-use",level:2}],m={toc:s};function p(e){let{components:n,...a}=e;return(0,t.mdx)("wrapper",(0,o.A)({},m,a,{components:n,mdxType:"MDXLayout"}),(0,t.mdx)("p",null,"The coverage command provides a metric of the amount of checking that Flow has\nperformed on each part of your code. A program with high Flow coverage should\nincrease your confidence that Flow has detected any potential runtime errors."),(0,t.mdx)("p",null,"The determining factor for this is the presence of ",(0,t.mdx)("a",{parentName:"p",href:"../../types/any/"},(0,t.mdx)("inlineCode",{parentName:"a"},"any"))," in the\ninferred type of each expression. An expression whose inferred type is ",(0,t.mdx)("inlineCode",{parentName:"p"},"any")," is\nconsidered ",(0,t.mdx)("em",{parentName:"p"},"uncovered"),", otherwise it is considered ",(0,t.mdx)("em",{parentName:"p"},"covered"),"."),(0,t.mdx)("p",null,"To see why this metric was chosen for determining Flow's effectiveness, consider\nthe example"),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const one: any = 1;\none();\n")),(0,t.mdx)("p",null,"This code leads to a runtime type error, since we are attempting to perform a call\non a number. Flow, however, does not flag an error here, because we have annotated\nvariable ",(0,t.mdx)("inlineCode",{parentName:"p"},"one")," as ",(0,t.mdx)("inlineCode",{parentName:"p"},"any"),". Flow's checking is effectively turned off whenever ",(0,t.mdx)("inlineCode",{parentName:"p"},"any"),"\nis involved, so it will silently allow the call. The use of this ",(0,t.mdx)("em",{parentName:"p"},"unsafe")," type has\nrendered the type checker ineffective, and the coverage metric is here to surface\nthis, by reporting all instances of ",(0,t.mdx)("inlineCode",{parentName:"p"},"one")," as uncovered."),(0,t.mdx)("h2",{id:"toc-design-space"},"Design Space"),(0,t.mdx)("p",null,(0,t.mdx)("strong",{parentName:"p"},'Which types should be "covered"?')),(0,t.mdx)("p",null,"What was described above is a rather coarse grained way to determine coverage. One\ncould imagine a criterion that flags expressions as uncovered if ",(0,t.mdx)("em",{parentName:"p"},"any")," part of their\ntype includes ",(0,t.mdx)("inlineCode",{parentName:"p"},"any"),", for example ",(0,t.mdx)("inlineCode",{parentName:"p"},"Array<any>"),'. While there is value in a metric like\nthis, the "uncovered" part of the type will typically be uncovered through various\noperations on values of this type. For example, in the code'),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"declare const arr: Array<any>;\narr.forEach(x => {});\n")),(0,t.mdx)("p",null,"the parameter ",(0,t.mdx)("inlineCode",{parentName:"p"},"x")," will be flagged as uncovered. Also, in practice, a strict criterion\nlike this would be too noisy and rather expensive to compute on the fly."),(0,t.mdx)("p",null,(0,t.mdx)("strong",{parentName:"p"},"Union types")),(0,t.mdx)("p",null,"An exception to this principle are union types: the type ",(0,t.mdx)("inlineCode",{parentName:"p"},"number | any")," is considered\n",(0,t.mdx)("em",{parentName:"p"},"uncovered"),", even though technically ",(0,t.mdx)("inlineCode",{parentName:"p"},"any")," is not the top-level constructor.\nUnions merely encode an option among ",(0,t.mdx)("em",{parentName:"p"},"a set of")," other types. In that sense we are\nconservatively viewing an expression as uncovered, when at least one possible type\nof that expression causes limited checking. For example, in the code"),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'let x: number | any = 1;\nx = "a";\n')),(0,t.mdx)("p",null,"Flow will let you assign anything to ",(0,t.mdx)("inlineCode",{parentName:"p"},"x"),", which reduces confidence in the use\nof ",(0,t.mdx)("inlineCode",{parentName:"p"},"x")," as a number. Thus ",(0,t.mdx)("inlineCode",{parentName:"p"},"x")," is considered uncovered."),(0,t.mdx)("p",null,(0,t.mdx)("strong",{parentName:"p"},"The empty type")),(0,t.mdx)("p",null,"An interesting type from a coverage perspective is the ",(0,t.mdx)("a",{parentName:"p",href:"../../types/empty"},(0,t.mdx)("inlineCode",{parentName:"a"},"empty"))," type.\nThis type roughly corresponds to ",(0,t.mdx)("em",{parentName:"p"},"dead code"),". As such checking around expressions with\ntype ",(0,t.mdx)("inlineCode",{parentName:"p"},"empty")," is more relaxed, but for a good reason: this code will not be executed at\nruntime. Since it is a common practice to clean up such code, Flow coverage will\nalso report code whose type is inferred to be ",(0,t.mdx)("inlineCode",{parentName:"p"},"empty"),", but distinguishes it from\nthe case of ",(0,t.mdx)("inlineCode",{parentName:"p"},"any"),"."),(0,t.mdx)("h2",{id:"toc-command-line-use"},"Command Line Use"),(0,t.mdx)("p",null,"To find out the coverage of a file foo.js with the following contents"),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function add(one: any, two: any): number {\n  return one + two;\n}\n\nadd(1, 2);\n")),(0,t.mdx)("p",null,"you can issue the following command"),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre"},"$ flow coverage file.js\nCovered: 50.00% (5 of 10 expressions)\n")),(0,t.mdx)("p",null,"This output means that 5 out of the 10 nodes of this program were inferred to have type\n",(0,t.mdx)("inlineCode",{parentName:"p"},"any"),". To see exactly which parts are uncovered you can also pass one of the following\nflags:"),(0,t.mdx)("ul",null,(0,t.mdx)("li",{parentName:"ul"},(0,t.mdx)("inlineCode",{parentName:"li"},"--color"),": This will print foo.js on the terminal with the uncovered locations in\nred color. E.g. ",(0,t.mdx)("inlineCode",{parentName:"li"},"flow coverage --color file.js")),(0,t.mdx)("li",{parentName:"ul"},(0,t.mdx)("inlineCode",{parentName:"li"},"--json"),": This will list out all location spans that are uncovered under\nthe tag ",(0,t.mdx)("inlineCode",{parentName:"li"},'"uncovered_locs"'),". E.g. ",(0,t.mdx)("inlineCode",{parentName:"li"},"flow coverage --json file.js"))),(0,t.mdx)("p",null,"Finally, as an example of dead code, consider the code:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function f(x: 'a' | 'b') {\n  if (x === 'a') {\n    // ...\n  } else if (x === 'b') {\n    // ...\n  } else {\n    x;\n  }\n}\n")),(0,t.mdx)("p",null,"The final ",(0,t.mdx)("inlineCode",{parentName:"p"},"else")," clause should never be reached, as we've already checked for both members of the union.\nBecause of this, ",(0,t.mdx)("inlineCode",{parentName:"p"},"x")," is inferred to have the type ",(0,t.mdx)("inlineCode",{parentName:"p"},"empty")," in that branch."),(0,t.mdx)("p",null,"In the colored version of this command, these parts appear in blue color,\nand in the JSON version they are under the field ",(0,t.mdx)("inlineCode",{parentName:"p"},'"empty_locs"'),"."),(0,t.mdx)("p",null,(0,t.mdx)("strong",{parentName:"p"},"Use on multiple files")),(0,t.mdx)("p",null,"If you want to check coverage of multiple files at once, Flow offers the\n",(0,t.mdx)("inlineCode",{parentName:"p"},"batch-coverage")," command:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre"},"$ flow batch-coverage dir/\n")),(0,t.mdx)("p",null,"will report coverage statistics for each file under ",(0,t.mdx)("inlineCode",{parentName:"p"},"dir/"),", as well as aggregate\nresults."),(0,t.mdx)("p",null,"Note that ",(0,t.mdx)("inlineCode",{parentName:"p"},"batch-coverage")," requires a non-lazy Flow server."))}p.isMDXComponent=!0}}]);