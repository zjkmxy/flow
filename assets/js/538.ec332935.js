"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[538],{18430:(e,n,t)=>{t.d(n,{V:()=>a,v:()=>r});var i=t(96540);function a(e){let{version:n}=e;return i.createElement("span",{class:"version added",title:"Added in "+n},"\u2265",n)}function r(e){let{version:n}=e;return i.createElement("span",{class:"version removed",title:"Removed after "+n},"\u2264",n)}},80538:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var i=t(58168),a=(t(96540),t(15680)),r=(t(60681),t(18430));const o={title:"Variable Declarations",slug:"/lang/variables"},s=void 0,l={unversionedId:"lang/variables",id:"lang/variables",title:"Variable Declarations",description:"When you are declaring a new variable, you may optionally declare its type.",source:"@site/docs/lang/variables.md",sourceDirName:"lang",slug:"/lang/variables",permalink:"/en/docs/lang/variables",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/lang/variables.md",tags:[],version:"current",frontMatter:{title:"Variable Declarations",slug:"/lang/variables"},sidebar:"docsSidebar",previous:{title:"Types & Expressions",permalink:"/en/docs/lang/types-and-expressions"},next:{title:"Subsets & Subtypes",permalink:"/en/docs/lang/subtypes"}},d={},p=[{value:"<code>const</code>",id:"toc-const",level:2},{value:'<code>var</code> and <code>let</code> <SinceVersion version="0.186" />',id:"toc-var-and-let",level:2},{value:"Variables initialized at their declarations",id:"toc-variables-initialized-at-their-declarations",level:3},{value:"Variables declared without initializers",id:"toc-variables-declared-without-initializers",level:3},{value:"Variables initialized to <code>null</code>",id:"toc-variables-initialized-to-null",level:3},{value:'Catch variables <SinceVersion version="0.197" />',id:"catch-variables-",level:2}],m={toc:p};function c(e){let{components:n,...t}=e;return(0,a.mdx)("wrapper",(0,i.A)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"When you are declaring a new variable, you may optionally declare its type."),(0,a.mdx)("p",null,"JavaScript has three ways of declaring local variables:"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("inlineCode",{parentName:"li"},"var")," - declares a variable, optionally assigning a value.\n(",(0,a.mdx)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var"},"MDN"),")"),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("inlineCode",{parentName:"li"},"let")," - declares a block-scoped variable, optionally assigning a value.\n(",(0,a.mdx)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let"},"MDN"),")"),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("inlineCode",{parentName:"li"},"const")," - declares a block-scoped variable, assigning a value that cannot be re-assigned.\n(",(0,a.mdx)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const"},"MDN"),")")),(0,a.mdx)("p",null,"In Flow these fall into two groups:"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("inlineCode",{parentName:"li"},"let")," and ",(0,a.mdx)("inlineCode",{parentName:"li"},"var")," - variables that ",(0,a.mdx)("strong",{parentName:"li"},"can")," be reassigned."),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("inlineCode",{parentName:"li"},"const")," - variables that ",(0,a.mdx)("strong",{parentName:"li"},"cannot")," be reassigned.")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":7,"startColumn":1,"endLine":7,"endColumn":13,"description":"Cannot reassign constant `constVariable` [1]. [reassign-const]"}]','[{"startLine":7,"startColumn":1,"endLine":7,"endColumn":13,"description":"Cannot':!0,reassign:!0,constant:!0,"`constVariable`":!0,"[1].":!0,'[reassign-const]"}]':!0},"var varVariable = 1;\nlet letVariable = 1;\nconst constVariable = 1;\n\nvarVariable = 2;   // Works!\nletVariable = 2;   // Works!\nconstVariable = 2; // Error!\n")),(0,a.mdx)("h2",{id:"toc-const"},(0,a.mdx)("inlineCode",{parentName:"h2"},"const")),(0,a.mdx)("p",null,"Since a ",(0,a.mdx)("inlineCode",{parentName:"p"},"const")," variable cannot be re-assigned at a later time it is fairly\nsimple."),(0,a.mdx)("p",null,"Flow can either infer the type from the value you are assigning to it or you\ncan provide it with a type."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const foo /* : number */ = 1;\nconst bar: number = 2;\n")),(0,a.mdx)("h2",{id:"toc-var-and-let"},(0,a.mdx)("inlineCode",{parentName:"h2"},"var")," and ",(0,a.mdx)("inlineCode",{parentName:"h2"},"let")," ",(0,a.mdx)(r.V,{version:"0.186",mdxType:"SinceVersion"})),(0,a.mdx)("p",null,"Since ",(0,a.mdx)("inlineCode",{parentName:"p"},"var")," and ",(0,a.mdx)("inlineCode",{parentName:"p"},"let")," can be re-assigned, there's a few more rules you'll need\nto know about."),(0,a.mdx)("p",null,"When you provide a type, you will be able to re-assign the value, but it must\nalways be of a compatible type."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":7,"endLine":3,"endColumn":9,"description":"Cannot assign `\\"3\\"` to `foo` because string [1] is incompatible with number [2]. [incompatible-type]"}]','[{"startLine":3,"startColumn":7,"endLine":3,"endColumn":9,"description":"Cannot':!0,assign:!0,'`\\"3\\"`':!0,to:!0,"`foo`":!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,"[2].":!0,'[incompatible-type]"}]':!0},'let foo: number = 1;\nfoo = 2;   // Works!\nfoo = "3"; // Error!\n')),(0,a.mdx)("p",null,"When the variable has no annotation, Flow infers a precise type based on\ntheir initializer or initial assignment. All subsequent assignments\nto that variable will be constrained by this type. This section shows some examples\nof how Flow determines what type an unannotated variable is inferred to have."),(0,a.mdx)("p",null,(0,a.mdx)("strong",{parentName:"p"},"If you want a variable to have a different type than what Flow infers for it,\nyou can always add a type annotation to the variable\u2019s declaration. That will\noverride everything discussed in this page!")),(0,a.mdx)("h3",{id:"toc-variables-initialized-at-their-declarations"},"Variables initialized at their declarations"),(0,a.mdx)("p",null,"The common case  for unannotated variables is very straightforward: when a\nvariable is declared with an initializer that is not the literal ",(0,a.mdx)("inlineCode",{parentName:"p"},"null"),", that\nvariable will from then on have the type of the initializer, and future writes\nto the variable will be constrained by that type."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":28,"startColumn":11,"endLine":28,"endColumn":33,"description":"Cannot assign `\'Our new pr...\'` to `product` because string [1] is incompatible with number [2]. All writes to `product` must be compatible with the type of its initializer [3]. Add an annotation to `product` [3] if a different type is desired. [incompatible-type]"},{"startLine":29,"startColumn":13,"endLine":29,"endColumn":65,"description":"Cannot assign function to `Component` because property `extra_prop` is missing in object type [1] but exists in object type [2] in the first parameter. All writes to `Component` must be compatible with the type of its initializer [3]. Add an annotation to `Component` [3] if a different type is desired. [prop-missing]"},{"startLine":30,"startColumn":11,"endLine":30,"endColumn":45,"description":"Cannot assign `<OtherComponent />` to `element` because property `extra_prop` is missing in object type [1] but exists in object type [2] in type argument `P` [3]. All writes to `element` must be compatible with the type of its initializer [4]. Add an annotation to `element` [4] if a different type is desired. [prop-missing]"},{"startLine":30,"startColumn":12,"endLine":30,"endColumn":25,"description":"Cannot assign `<OtherComponent />` to `element` because property `extra_prop` is missing in object type [1] but exists in object type [2] in the first parameter of type argument `ElementType` [3]. All writes to `element` must be compatible with the type of its initializer [4]. Add an annotation to `element` [4] if a different type is desired. [prop-missing]"}]','[{"startLine":28,"startColumn":11,"endLine":28,"endColumn":33,"description":"Cannot':!0,assign:!0,"`'Our":!0,new:!0,"pr...'`":!0,to:!0,"`product`":!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,"[2].":!0,All:!0,writes:!0,must:!0,be:!0,compatible:!0,the:!0,type:!0,of:!0,its:!0,initializer:!0,"[3].":!0,Add:!0,an:!0,annotation:!0,"[3]":!0,if:!0,a:!0,different:!0,"desired.":!0,'[incompatible-type]"},{"startLine":29,"startColumn":13,"endLine":29,"endColumn":65,"description":"Cannot':!0,function:!0,"`Component`":!0,property:!0,"`extra_prop`":!0,missing:!0,in:!0,object:!0,but:!0,exists:!0,"[2]":!0,first:!0,"parameter.":!0,'[prop-missing]"},{"startLine":30,"startColumn":11,"endLine":30,"endColumn":45,"description":"Cannot':!0,"`<OtherComponent":!0,"/>`":!0,"`element`":!0,argument:!0,"`P`":!0,"[4].":!0,"[4]":!0,'[prop-missing]"},{"startLine":30,"startColumn":12,"endLine":30,"endColumn":25,"description":"Cannot':!0,parameter:!0,"`ElementType`":!0,'[prop-missing]"}]':!0},"import * as React from 'react';\n\ntype Props = $ReadOnly<{ prop: string }>;\n\ndeclare var x: number;\ndeclare var y: number;\ndeclare var props: Props;\n\nlet product = Math.sqrt(x) + y;\n// `product` has type `number`\n\nlet Component = ({prop}: Props): React.Node => { return <div/> }\n// `Component` has type`React.ComponentType<Props>`\n\nlet element = <Component {...props} />\n// `element` has type `React.Element<React.ComponentType<Props>>`\n\n/* Let's define a new component */\n\ntype OtherProps = $ReadOnly<{ ...Props, extra_prop: number }>;\ndeclare var OtherComponent: (OtherProps) => React.Node;\ndeclare var other_props: OtherProps\n\n/* Any subsequent assignments to `product`, `Component`, or `element` will be\n * checked against the types that Flow infers for the initializers, and if\n * conflicting types are assigned, Flow will signal an error. */\n\nproduct = \"Our new product is...\";\nComponent = ({prop}: OtherProps): React.Node => { return <div/> };\nelement = <OtherComponent {...other_props} />;\n")),(0,a.mdx)("p",null,"If you want these examples to typecheck, and for Flow to realize that different\nkinds of values can be written to these variables, you must add a type\nannotation reflecting this more general type to their declarations:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"let product: number | string = ...\nlet Component: mixed = ... // No good type to represent this! Consider restructuring\nlet element: React.Node = ...\n")),(0,a.mdx)("h3",{id:"toc-variables-declared-without-initializers"},"Variables declared without initializers"),(0,a.mdx)("p",null,'Often variables are declared without initializers. In such cases, Flow will try\nto choose the "first" assignment or assignments to the variable to define its\ntype. "First" here means both top-to-bottom and nearer-scope to\ndeeper-scope\u2014we\u2019ll try to choose an assignment that happens in the same function\nscope as the variable\u2019s declaration, and only look inside nested functions if we\ndon\u2019t find any assignments locally:'),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":22,"endLine":3,"endColumn":23,"description":"Cannot assign `42` to `topLevelAssigned` because number [1] is incompatible with string [2]. All writes to `topLevelAssigned` must be compatible with the type of its initial assignment [3]. Add an annotation to `topLevelAssigned` [4] if a different type is desired. [incompatible-type]"},{"startLine":6,"startColumn":20,"endLine":6,"endColumn":23,"description":"Cannot assign `true` to `topLevelAssigned` because boolean [1] is incompatible with string [2]. All writes to `topLevelAssigned` must be compatible with the type of its initial assignment [3]. Add an annotation to `topLevelAssigned` [4] if a different type is desired. [incompatible-type]"}]','[{"startLine":3,"startColumn":22,"endLine":3,"endColumn":23,"description":"Cannot':!0,assign:!0,"`42`":!0,to:!0,"`topLevelAssigned`":!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,string:!0,"[2].":!0,All:!0,writes:!0,must:!0,be:!0,compatible:!0,the:!0,type:!0,of:!0,its:!0,initial:!0,assignment:!0,"[3].":!0,Add:!0,an:!0,annotation:!0,"[4]":!0,if:!0,a:!0,different:!0,"desired.":!0,'[incompatible-type]"},{"startLine":6,"startColumn":20,"endLine":6,"endColumn":23,"description":"Cannot':!0,"`true`":!0,boolean:!0,'[incompatible-type]"}]':!0},'let topLevelAssigned;\nfunction helper() {\n  topLevelAssigned = 42; // Error: `topLevelAssigned` has type `string`\n}\ntopLevelAssigned = "Hello world"; // This write determines the var\'s type\ntopLevelAssigned = true; // Error: `topLevelAssigned` has type `string`\n')),(0,a.mdx)("p",null,'If there are two or more possible "first assignments," due to an ',(0,a.mdx)("inlineCode",{parentName:"p"},"if"),"- or\n",(0,a.mdx)("inlineCode",{parentName:"p"},"switch"),"-statement, they\u2019ll both count\u2014this is one of the few ways that Flow\nwill still infer unions for variable types:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":10,"startColumn":20,"endLine":10,"endColumn":24,"description":"Cannot assign `false` to `myNumberOrString` because: [incompatible-type] Either boolean [1] is incompatible with number [2]. Or boolean [1] is incompatible with string [3]. \\nAll writes to `myNumberOrString` must be compatible with the type of one of its initial assignments [4], [5]. Add an annotation to `myNumberOrString` [6] if a different type is desired."}]','[{"startLine":10,"startColumn":20,"endLine":10,"endColumn":24,"description":"Cannot':!0,assign:!0,"`false`":!0,to:!0,"`myNumberOrString`":!0,"because:":!0,"[incompatible-type]":!0,Either:!0,boolean:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,"[2].":!0,Or:!0,string:!0,"[3].":!0,"\\nAll":!0,writes:!0,must:!0,be:!0,compatible:!0,the:!0,type:!0,of:!0,one:!0,its:!0,initial:!0,assignments:!0,"[4],":!0,"[5].":!0,Add:!0,an:!0,annotation:!0,"[6]":!0,if:!0,a:!0,different:!0,'desired."}]':!0},'let myNumberOrString;\ndeclare var condition: boolean;\nif (condition) {\n  myNumberOrString = 42; // Determines type\n} else {\n  myNumberOrString = "Hello world"; // Determines type\n}\nmyNumberOrString = 21; // fine, compatible with type\nmyNumberOrString = "Goodbye"; // fine, compatible with type\nmyNumberOrString = false; // Error: `myNumberOrString` has type `number | string`\n')),(0,a.mdx)("p",null,"This only applies when the variable is written to in both branches, however. If\nonly one branch contains a write, that write becomes the type of the variable\nafterwards (though Flow will still check to make sure that the variable is\ndefinitely initialized):"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":19,"endLine":6,"endColumn":29,"description":"Cannot call `oneBranchAssigned.toUpperCase` because property `toUpperCase` is missing in possibly uninitialized variable [1]. [incompatible-use]"},{"startLine":7,"startColumn":21,"endLine":7,"endColumn":22,"description":"Cannot assign `42` to `oneBranchAssigned` because number [1] is incompatible with string [2]. All writes to `oneBranchAssigned` must be compatible with the type of its initial assignment [3]. Add an annotation to `oneBranchAssigned` [4] if a different type is desired. [incompatible-type]"}]','[{"startLine":6,"startColumn":19,"endLine":6,"endColumn":29,"description":"Cannot':!0,call:!0,"`oneBranchAssigned.toUpperCase`":!0,because:!0,property:!0,"`toUpperCase`":!0,is:!0,missing:!0,in:!0,possibly:!0,uninitialized:!0,variable:!0,"[1].":!0,'[incompatible-use]"},{"startLine":7,"startColumn":21,"endLine":7,"endColumn":22,"description":"Cannot':!0,assign:!0,"`42`":!0,to:!0,"`oneBranchAssigned`":!0,number:!0,"[1]":!0,incompatible:!0,with:!0,string:!0,"[2].":!0,All:!0,writes:!0,must:!0,be:!0,compatible:!0,the:!0,type:!0,of:!0,its:!0,initial:!0,assignment:!0,"[3].":!0,Add:!0,an:!0,annotation:!0,"[4]":!0,if:!0,a:!0,different:!0,"desired.":!0,'[incompatible-type]"}]':!0},'let oneBranchAssigned;\ndeclare var condition: boolean;\nif (condition) {\n  oneBranchAssigned = "Hello world!";\n}\noneBranchAssigned.toUpperCase(); // Error: `oneBranchAssigned` may be uninitialized\noneBranchAssigned = 42; // Error: `oneBranchAssigned` has type `string`\n')),(0,a.mdx)("h3",{id:"toc-variables-initialized-to-null"},"Variables initialized to ",(0,a.mdx)("inlineCode",{parentName:"h3"},"null")),(0,a.mdx)("p",null,"Finally, the one exception to the general principle that variable\u2019s types are\ndetermined by their first assignment(s) is when a variable is initialized as (or\nwhose first assignment is) the literal value ",(0,a.mdx)("inlineCode",{parentName:"p"},"null"),". In such cases, the ",(0,a.mdx)("em",{parentName:"p"},"next"),"\nnon-null assignment (using the same rules as above) determines the rest of the\nvariable\u2019s type, and the overall type of the variable becomes a union of ",(0,a.mdx)("inlineCode",{parentName:"p"},"null"),"\nand the type of the subsequent assignment. This supports the common pattern\nwhere a variable starts off as ",(0,a.mdx)("inlineCode",{parentName:"p"},"null")," before getting assigned by a value of some\nother type:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function findIDValue<T>(dict: {[key: string]: T}): T {\n  let idVal = null; // initialized as `null`\n  for (const key in dict) {\n    if (key === 'ID') {\n      idVal = dict[key]; // Infer that `idVal` has type `null | T`\n    }\n  }\n  if (idVal === null) {\n    throw new Error(\"No entry for ID!\");\n  }\n  return idVal;\n}\n")),(0,a.mdx)("h2",{id:"catch-variables-"},"Catch variables ",(0,a.mdx)(r.V,{version:"0.197",mdxType:"SinceVersion"})),(0,a.mdx)("p",null,"If a ",(0,a.mdx)("inlineCode",{parentName:"p"},"catch")," variable does not have an annotation, its default type is ",(0,a.mdx)("a",{parentName:"p",href:"../../types/any"},(0,a.mdx)("inlineCode",{parentName:"a"},"any")),"."),(0,a.mdx)("p",null,"You can optionally annotate it with exactly ",(0,a.mdx)("a",{parentName:"p",href:"../../types/mixed"},(0,a.mdx)("inlineCode",{parentName:"a"},"mixed"))," or ",(0,a.mdx)("inlineCode",{parentName:"p"},"any"),". E.g."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"try {\n} catch (e: mixed) {\n  if (e instanceof TypeError) {\n    e as TypeError; // OK\n  } else if (e instanceof Error) {\n    e as Error; // OK\n  } else {\n    throw e;\n  }\n}\n")),(0,a.mdx)("p",null,"By using ",(0,a.mdx)("inlineCode",{parentName:"p"},"mixed"),", you can improve your safety and Flow ",(0,a.mdx)("a",{parentName:"p",href:"../../cli/coverage/"},"coverage"),",\nat the trade-off of increased runtime checks."),(0,a.mdx)("p",null,"You can change the default type of ",(0,a.mdx)("inlineCode",{parentName:"p"},"catch")," variables when there is no annotation by setting the ",(0,a.mdx)("a",{parentName:"p",href:"../../config/options/#toc-use-mixed-in-catch-variables"},(0,a.mdx)("inlineCode",{parentName:"a"},"use_mixed_in_catch_variables"))," option to true."))}c.isMDXComponent=!0}}]);