"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[5285],{65285:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=t(58168),l=(t(96540),t(15680));t(60681);const r={title:"Tuples",slug:"/types/tuples"},i=void 0,o={unversionedId:"types/tuples",id:"types/tuples",title:"Tuples",description:"Tuple types represent a fixed length list, where the elements can have different types.",source:"@site/docs/types/tuples.md",sourceDirName:"types",slug:"/types/tuples",permalink:"/en/docs/types/tuples",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/types/tuples.md",tags:[],version:"current",frontMatter:{title:"Tuples",slug:"/types/tuples"},sidebar:"docsSidebar",previous:{title:"Arrays",permalink:"/en/docs/types/arrays"},next:{title:"Classes",permalink:"/en/docs/types/classes"}},s={},p=[{value:"Tuple Basics",id:"tuple-basics",level:2},{value:"Strictly enforced tuple length (arity)",id:"toc-strictly-enforced-tuple-length-arity",level:2},{value:"Tuples don&#39;t match array types",id:"toc-tuples-don-t-match-array-types",level:2},{value:"Cannot use mutating array methods on tuples",id:"toc-cannot-use-mutating-array-methods-on-tuples",level:2},{value:"Length refinement",id:"length-refinement",level:2},{value:"Tuple element labels",id:"tuple-element-labels",level:2},{value:"Variance annotations and read-only tuples",id:"variance-annotations-and-read-only-tuples",level:2},{value:"Optional tuple elements",id:"optional-tuple-elements",level:2},{value:"Tuple spread",id:"tuple-spread",level:2},{value:"Inexact tuples",id:"inexact-tuples",level:2},{value:"Adoption",id:"adoption",level:2}],u={toc:p};function m(e){let{components:n,...t}=e;return(0,l.mdx)("wrapper",(0,a.A)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,l.mdx)("p",null,"Tuple types represent a ",(0,l.mdx)("strong",{parentName:"p"},"fixed length")," list, where the elements can have ",(0,l.mdx)("strong",{parentName:"p"},"different types"),".\nThis is in contrast to ",(0,l.mdx)("a",{parentName:"p",href:"../arrays"},"array types"),", which have an unknown length and all elements have the same type."),(0,l.mdx)("h2",{id:"tuple-basics"},"Tuple Basics"),(0,l.mdx)("p",null,"JavaScript array literal values can be used to create both tuple and array types:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const arr: Array<number> = [1, 2, 3]; // As an array type\nconst tup: [number, number, number] = [1, 2, 3]; // As a tuple type\n")),(0,l.mdx)("p",null,"In Flow you can create tuple types using the ",(0,l.mdx)("inlineCode",{parentName:"p"},"[type1, type2, type3]")," syntax:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'const tuple1: [number] = [1];\nconst tuple2: [number, boolean] = [1, true];\nconst tuple3: [number, boolean, string] = [1, true, "three"];\n')),(0,l.mdx)("p",null,"When you get a value from a tuple at a specific index, it will return the\ntype at that index:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'const tuple: [number, boolean, string] = [1, true, "three"];\n\nconst num: number = tuple[0]; // Works!\nconst bool: boolean = tuple[1]; // Works!\nconst str: string  = tuple[2]; // Works!\n')),(0,l.mdx)("p",null,"Trying to access an index that does not exist results in an index-out-of-bounds error:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",3:!0,className:"language-flow",metastring:'[{"startLine":3,"startColumn":14,"endLine":3,"endColumn":21,"description":"Cannot get `tuple[3]` because tuple type [1] only has 3 elements, so index 3 is out of bounds. [invalid-tuple-index]"}]','[{"startLine":3,"startColumn":14,"endLine":3,"endColumn":21,"description":"Cannot':!0,get:!0,"`tuple[3]`":!0,because:!0,tuple:!0,type:!0,"[1]":!0,only:!0,has:!0,"elements,":!0,so:!0,index:!0,is:!0,out:!0,of:!0,"bounds.":!0,'[invalid-tuple-index]"}]':!0},'const tuple: [number, boolean, string] = [1, true, "three"];\n\nconst none = tuple[3]; // Error!\n')),(0,l.mdx)("p",null,"If Flow doesn't know which index you are trying to access it will return all\npossible types:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'const tuple: [number, boolean, string] = [1, true, "three"];\n\nfunction getItem(n: number) {\n  const val: number | boolean | string = tuple[n];\n  // ...\n}\n')),(0,l.mdx)("p",null,"When setting a new value inside a tuple, the new value must match the type at\nthat index:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":7,"startColumn":12,"endLine":7,"endColumn":16,"description":"Cannot assign `\\"bar\\"` to `tuple[0]` because string [1] is incompatible with number [2]. [incompatible-type]"},{"startLine":8,"startColumn":12,"endLine":8,"endColumn":13,"description":"Cannot assign `42` to `tuple[1]` because number [1] is incompatible with boolean [2]. [incompatible-type]"},{"startLine":9,"startColumn":12,"endLine":9,"endColumn":16,"description":"Cannot assign `false` to `tuple[2]` because boolean [1] is incompatible with string [2]. [incompatible-type]"}]','[{"startLine":7,"startColumn":12,"endLine":7,"endColumn":16,"description":"Cannot':!0,assign:!0,'`\\"bar\\"`':!0,to:!0,"`tuple[0]`":!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,"[2].":!0,'[incompatible-type]"},{"startLine":8,"startColumn":12,"endLine":8,"endColumn":13,"description":"Cannot':!0,"`42`":!0,"`tuple[1]`":!0,boolean:!0,'[incompatible-type]"},{"startLine":9,"startColumn":12,"endLine":9,"endColumn":16,"description":"Cannot':!0,"`false`":!0,"`tuple[2]`":!0,'[incompatible-type]"}]':!0},'const tuple: [number, boolean, string] = [1, true, "three"];\n\ntuple[0] = 2;     // Works!\ntuple[1] = false; // Works!\ntuple[2] = "foo"; // Works!\n\ntuple[0] = "bar"; // Error!\ntuple[1] = 42;    // Error!\ntuple[2] = false; // Error!\n')),(0,l.mdx)("h2",{id:"toc-strictly-enforced-tuple-length-arity"},"Strictly enforced tuple length (arity)"),(0,l.mdx)("p",null,'The length of the tuple is known as the "arity". The length of a tuple is\nstrictly enforced in Flow.'),(0,l.mdx)("p",null,"This means that a shorter tuple can't be used in place of a longer one:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",2:!0,3:!0,className:"language-flow",metastring:'[{"startLine":3,"startColumn":41,"endLine":3,"endColumn":46,"description":"Cannot assign `tuple1` to `tuple2` because tuple type [1] has 2 elements but tuple type [2] has 3 elements. [invalid-tuple-arity]"}]','[{"startLine":3,"startColumn":41,"endLine":3,"endColumn":46,"description":"Cannot':!0,assign:!0,"`tuple1`":!0,to:!0,"`tuple2`":!0,because:!0,tuple:!0,type:!0,"[1]":!0,has:!0,elements:!0,but:!0,"[2]":!0,"elements.":!0,'[invalid-tuple-arity]"}]':!0},"const tuple1: [number, boolean] = [1, true];\n\nconst tuple2: [number, boolean, void] = tuple1; // Error!\n")),(0,l.mdx)("p",null,"Also, a longer tuple can't be used in place of a shorter one:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",2:!0,3:!0,className:"language-flow",metastring:'[{"startLine":3,"startColumn":35,"endLine":3,"endColumn":40,"description":"Cannot assign `tuple1` to `tuple2` because tuple type [1] has 3 elements but tuple type [2] has 2 elements. [invalid-tuple-arity]"}]','[{"startLine":3,"startColumn":35,"endLine":3,"endColumn":40,"description":"Cannot':!0,assign:!0,"`tuple1`":!0,to:!0,"`tuple2`":!0,because:!0,tuple:!0,type:!0,"[1]":!0,has:!0,elements:!0,but:!0,"[2]":!0,"elements.":!0,'[invalid-tuple-arity]"}]':!0},"const tuple1: [number, boolean, void] = [1, true, undefined];\n\nconst tuple2: [number, boolean] = tuple1; // Error!\n")),(0,l.mdx)("p",null,(0,l.mdx)("a",{parentName:"p",href:"#optional-tuple-elements"},"Optional elements")," make the arity into a range."),(0,l.mdx)("h2",{id:"toc-tuples-don-t-match-array-types"},"Tuples don't match array types"),(0,l.mdx)("p",null,"Since Flow does not know the length of an array, an ",(0,l.mdx)("inlineCode",{parentName:"p"},"Array<T>")," type cannot be\npassed into a tuple:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":33,"endLine":3,"endColumn":37,"description":"Cannot assign `array` to `tuple` because array type [1] has an unknown number of elements, so is incompatible with tuple type [2]. [invalid-tuple-arity]"}]','[{"startLine":3,"startColumn":33,"endLine":3,"endColumn":37,"description":"Cannot':!0,assign:!0,"`array`":!0,to:!0,"`tuple`":!0,because:!0,array:!0,type:!0,"[1]":!0,has:!0,an:!0,unknown:!0,number:!0,of:!0,"elements,":!0,so:!0,is:!0,incompatible:!0,with:!0,tuple:!0,"[2].":!0,'[invalid-tuple-arity]"}]':!0},"const array: Array<number> = [1, 2];\n\nconst tuple: [number, number] = array; // Error!\n")),(0,l.mdx)("p",null,"Also a tuple type cannot be passed into to an ",(0,l.mdx)("inlineCode",{parentName:"p"},"Array<T>")," type, since then you\ncould mutate the tuple in an unsafe way (for example, ",(0,l.mdx)("inlineCode",{parentName:"p"},"push"),"ing a third item onto it):"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":30,"endLine":3,"endColumn":34,"description":"Cannot assign `tuple` to `array` because tuple type [1] is incompatible with array type [2]. [incompatible-type]"}]','[{"startLine":3,"startColumn":30,"endLine":3,"endColumn":34,"description":"Cannot':!0,assign:!0,"`tuple`":!0,to:!0,"`array`":!0,because:!0,tuple:!0,type:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,array:!0,"[2].":!0,'[incompatible-type]"}]':!0},"const tuple: [number, number] = [1, 2];\n\nconst array: Array<number> = tuple; // Error!\n")),(0,l.mdx)("p",null,"However, you can pass it to a ",(0,l.mdx)("a",{parentName:"p",href:"../arrays/#toc-readonlyarray"},(0,l.mdx)("inlineCode",{parentName:"a"},"$ReadOnlyArray"))," type, since mutation is disallowed:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const tuple: [number, number] = [1, 2];\n\nconst array: $ReadOnlyArray<number> = tuple; // Works!\n")),(0,l.mdx)("h2",{id:"toc-cannot-use-mutating-array-methods-on-tuples"},"Cannot use mutating array methods on tuples"),(0,l.mdx)("p",null,"You cannot use ",(0,l.mdx)("inlineCode",{parentName:"p"},"Array.prototype")," methods that mutate the tuple, only ones that do not:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":4,"startColumn":7,"endLine":4,"endColumn":10,"description":"Cannot call `tuple.push` because property `push` is missing in `$ReadOnlyArray` [1]. [prop-missing]"}]','[{"startLine":4,"startColumn":7,"endLine":4,"endColumn":10,"description":"Cannot':!0,call:!0,"`tuple.push`":!0,because:!0,property:!0,"`push`":!0,is:!0,missing:!0,in:!0,"`$ReadOnlyArray`":!0,"[1].":!0,'[prop-missing]"}]':!0},"const tuple: [number, number] = [1, 2];\ntuple.join(', '); // Works!\n\ntuple.push(3); // Error!\n")),(0,l.mdx)("h2",{id:"length-refinement"},"Length refinement"),(0,l.mdx)("p",null,"You can refine a ",(0,l.mdx)("a",{parentName:"p",href:"../unions"},"union")," of tuples by their length:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Union = [number, string] | [boolean];\nfunction f(x: Union) {\n  if (x.length === 2) {\n    // `x` is `[number, string]`\n    const n: number = x[0]; // OK\n    const s: string = x[1]; // OK\n  } else {\n    // `x` is `[boolean]`\n    const b: boolean = x[0];\n  }\n}\n")),(0,l.mdx)("h2",{id:"tuple-element-labels"},"Tuple element labels"),(0,l.mdx)("blockquote",null,(0,l.mdx)("p",{parentName:"blockquote"},'NOTE: This and the following sections require your tooling to be updated as described in the "Adoption" section at the end of this page.')),(0,l.mdx)("p",null,"You can add a label to tuple elements. This label does not affect the type of the tuple element,\nbut is useful in self-documenting the purpose of the tuple elements, especially when multiple elements have the same type."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Range = [x: number, y: number];\n")),(0,l.mdx)("p",null,"The label is also necessary to add a variance annotation or optionality modifier to an element (as without the label we would have parsing ambiguities)."),(0,l.mdx)("h2",{id:"variance-annotations-and-read-only-tuples"},"Variance annotations and read-only tuples"),(0,l.mdx)("p",null,"You can add ",(0,l.mdx)("a",{parentName:"p",href:"../../lang/variance"},"variance"),"  annotations (to denote read-only/write-only) on labeled tuple elements, just like on object properties:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type T = [+foo: number, -bar: string];\n")),(0,l.mdx)("p",null,"This allows you to mark elements as read-only or write-only. For example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":3,"endLine":3,"endColumn":18,"description":"Cannot assign `1` to `readOnlyTuple[1]` because tuple element at index `1` [1] labeled `bar` is not writable. [cannot-write]"},{"startLine":3,"startColumn":22,"endLine":3,"endColumn":22,"description":"Cannot assign `1` to `readOnlyTuple[1]` because number [1] is incompatible with string [2]. [incompatible-type]"}]','[{"startLine":3,"startColumn":3,"endLine":3,"endColumn":18,"description":"Cannot':!0,assign:!0,"`1`":!0,to:!0,"`readOnlyTuple[1]`":!0,because:!0,tuple:!0,element:!0,at:!0,index:!0,"[1]":!0,labeled:!0,"`bar`":!0,is:!0,not:!0,"writable.":!0,'[cannot-write]"},{"startLine":3,"startColumn":22,"endLine":3,"endColumn":22,"description":"Cannot':!0,number:!0,incompatible:!0,with:!0,string:!0,"[2].":!0,'[incompatible-type]"}]':!0},"function f(readOnlyTuple: [+foo: number, +bar: string]) {\n  const n: number = readOnlyTuple[0]; // OK to read\n  readOnlyTuple[1] = 1; // ERROR! Cannot write\n}\n")),(0,l.mdx)("p",null,"You can also use the ",(0,l.mdx)("a",{parentName:"p",href:"../utilities/#toc-readonly"},(0,l.mdx)("inlineCode",{parentName:"a"},"$ReadOnly")),"  on tuple types as a shorthand for marking each property as read-only:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type T = $ReadOnly<[number, string]>; // Same as `[+a: number, +b: string]`\n")),(0,l.mdx)("h2",{id:"optional-tuple-elements"},"Optional tuple elements"),(0,l.mdx)("p",null,"You can mark tuple elements as optional with ",(0,l.mdx)("inlineCode",{parentName:"p"},"?")," after an element\u2019s label. This allows you to omit the optional elements.\nOptional elements must be at the end of the tuple type, after all required elements."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'type T = [foo: number, bar?: string];\n[1, "s"] as T; // OK: has all elements\n[1] as T; // OK: skipping optional element\n')),(0,l.mdx)("p",null,"You cannot write ",(0,l.mdx)("inlineCode",{parentName:"p"},"undefined")," to the optional element - add ",(0,l.mdx)("inlineCode",{parentName:"p"},"| void")," to the element type if you want to do so:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":8,"endLine":3,"endColumn":16,"description":"Cannot assign `undefined` to `x[0]` because you cannot assign undefined [1] to optional tuple element [2] (to do so, add `| void` to the tuple element type). [incompatible-type]"},{"startLine":4,"startColumn":2,"endLine":4,"endColumn":10,"description":"Cannot cast array literal to `T` because you cannot assign undefined [1] to optional tuple element [2] (to do so, add `| void` to the tuple element type) in index 0. [incompatible-cast]"}]','[{"startLine":3,"startColumn":8,"endLine":3,"endColumn":16,"description":"Cannot':!0,assign:!0,"`undefined`":!0,to:!0,"`x[0]`":!0,because:!0,you:!0,cannot:!0,undefined:!0,"[1]":!0,optional:!0,tuple:!0,element:!0,"[2]":!0,"(to":!0,do:!0,"so,":!0,add:!0,"`|":!0,"void`":!0,the:!0,"type).":!0,'[incompatible-type]"},{"startLine":4,"startColumn":2,"endLine":4,"endColumn":10,"description":"Cannot':!0,cast:!0,array:!0,literal:!0,"`T`":!0,"type)":!0,in:!0,index:!0,"0.":!0,'[incompatible-cast]"}]':!0},"type T = [foo?: number, bar?: number | void];\ndeclare const x: T;\nx[0] = undefined; // ERROR\n[undefined] as T; // ERROR\n\nx[1] = undefined; // OK: we've added `| void` to the element type\n")),(0,l.mdx)("p",null,"You can also use the ",(0,l.mdx)("a",{parentName:"p",href:"../utilities/#toc-partial"},(0,l.mdx)("inlineCode",{parentName:"a"},"Partial"))," and ",(0,l.mdx)("a",{parentName:"p",href:"../utilities/#toc-required"},(0,l.mdx)("inlineCode",{parentName:"a"},"Required"))," utility types to make all elements optional or required respectively:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",0:!0,2:!0,className:"language-flow",metastring:'[{"startLine":5,"startColumn":1,"endLine":5,"endColumn":2,"description":"Cannot cast array literal to required of `AllOptional` because empty array literal [1] has 0 elements but `AllOptional` [2] has 2 elements. [invalid-tuple-arity]"}]','[{"startLine":5,"startColumn":1,"endLine":5,"endColumn":2,"description":"Cannot':!0,cast:!0,array:!0,literal:!0,to:!0,required:!0,of:!0,"`AllOptional`":!0,because:!0,empty:!0,"[1]":!0,has:!0,elements:!0,but:!0,"[2]":!0,"elements.":!0,'[invalid-tuple-arity]"}]':!0},"type AllRequired = [number, string];\n[] as Partial<AllRequired>; // OK: like `[a?: number, b?: string]` now\n\ntype AllOptional = [a?: number, b?: string];\n[] as Required<AllOptional>; // ERROR: like `[a: number, b: string]` now\n")),(0,l.mdx)("p",null,"Tuples with optional elements have an arity (length) that is a range rather than a single number. For example, ",(0,l.mdx)("inlineCode",{parentName:"p"},"[number, b?: string]")," has an length of 1-2."),(0,l.mdx)("h2",{id:"tuple-spread"},"Tuple spread"),(0,l.mdx)("p",null,"You can spread a tuple type into another tuple type to make a longer tuple type:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'type A = [number, string];\ntype T = [...A, boolean]; // Same as `[number, string, boolean]`\n[1, "s", true] as T; // OK\n')),(0,l.mdx)("p",null,"Tuple spreads preserve labels, variance, and optionality. You cannot spread arrays into tuples, only other tuples."),(0,l.mdx)("p",null,"At the value level, if you spread a tuple with optional elements into an array literal, then you cannot have anything after that spread and retain the tuple view of the array value.\nThat is because a tuple with optional elements has a length that's a range, so we don't know at what index any subsequent values would be at.\nYou can still type this value as the appropriate ",(0,l.mdx)("inlineCode",{parentName:"p"},"Array<T>")," type - only the tuple view of the value is affected."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":1,"endLine":3,"endColumn":1,"description":"Cannot cast `b` to tuple type because array literal [1] has an unknown number of elements, so is incompatible with tuple type [2]. [invalid-tuple-arity]"},{"startLine":9,"startColumn":1,"endLine":9,"endColumn":1,"description":"Cannot cast `e` to tuple type because array literal [1] has an unknown number of elements, so is incompatible with tuple type [2]. [invalid-tuple-arity]"}]','[{"startLine":3,"startColumn":1,"endLine":3,"endColumn":1,"description":"Cannot':!0,cast:!0,"`b`":!0,to:!0,tuple:!0,type:!0,because:!0,array:!0,literal:!0,"[1]":!0,has:!0,an:!0,unknown:!0,number:!0,of:!0,"elements,":!0,so:!0,is:!0,incompatible:!0,with:!0,"[2].":!0,'[invalid-tuple-arity]"},{"startLine":9,"startColumn":1,"endLine":9,"endColumn":1,"description":"Cannot':!0,"`e`":!0,'[invalid-tuple-arity]"}]':!0},"const a: [foo?: 1] = [];\nconst b = [0, ...a, 2]; // At runtime this is `[0, 2]`\nb as [0, 1 | void, 2]; // ERROR\nb as Array<number | void>; // OK\n\nconst c: [0, foo?: 1] = [0];\nconst d: [bar?: 2] = [2];\nconst e = [...c, ...d]; // At runtime this is `[0, 2]`\ne as [0, foo?: 1, bar?: 2]; // ERROR\ne as Array<number | void>; // OK\n")),(0,l.mdx)("h2",{id:"inexact-tuples"},"Inexact tuples"),(0,l.mdx)("p",null,"Inexact tuple types work like ",(0,l.mdx)("a",{parentName:"p",href:"../objects#exact-and-inexact-object-types"},"inexact objects"),": they allow for unknown members at the end of the tuple."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"[] as [...]; // OK\n[1] as [...]; // OK\n[1] as [number, ...]; // OK\n")),(0,l.mdx)("p",null,"All tuples are subtypes of the inexact empty tuple ",(0,l.mdx)("inlineCode",{parentName:"p"},"[...]"),"."),(0,l.mdx)("p",null,"If you spread an inexact tuple, the result is also inexact.\nYou cannot define elements after the spread of an inexact tuple, since we wouldn't know at what index they should be."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",2:!0,className:"language-flow",metastring:'[{"startLine":3,"startColumn":1,"endLine":3,"endColumn":1,"description":"Cannot cast `y` to tuple type because array literal [1] has 2 or more elements (inexact tuple) but tuple type [2] has 2 elements. [invalid-tuple-arity]"},{"startLine":6,"startColumn":8,"endLine":6,"endColumn":8,"description":"Cannot have element after spread of inexact tuple. [element-after-inexact-tuple-spread]"}]','[{"startLine":3,"startColumn":1,"endLine":3,"endColumn":1,"description":"Cannot':!0,cast:!0,"`y`":!0,to:!0,tuple:!0,type:!0,because:!0,array:!0,literal:!0,"[1]":!0,has:!0,or:!0,more:!0,elements:!0,"(inexact":!0,"tuple)":!0,but:!0,"[2]":!0,"elements.":!0,'[invalid-tuple-arity]"},{"startLine":6,"startColumn":8,"endLine":6,"endColumn":8,"description":"Cannot':!0,have:!0,element:!0,after:!0,spread:!0,of:!0,inexact:!0,"tuple.":!0,'[element-after-inexact-tuple-spread]"}]':!0},"declare const x: [1, ...];\nconst y = [0, ...x];\ny as [0, 1]; // ERROR: it's inexact\ny as [0, 1, ...]; // OK\n\n[...x, 2]; // ERROR: can't have element after inexact spread\n")),(0,l.mdx)("p",null,"Inexact tuples allow you to require that a generic is a tuple, e.g."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":13,"startColumn":1,"endLine":13,"endColumn":13,"description":"Cannot call `mapTupleArray` because array type [1] has an unknown number of elements, so is incompatible with tuple type [2] in type argument `T`. [invalid-tuple-arity]"}]','[{"startLine":13,"startColumn":1,"endLine":13,"endColumn":13,"description":"Cannot':!0,call:!0,"`mapTupleArray`":!0,because:!0,array:!0,type:!0,"[1]":!0,has:!0,an:!0,unknown:!0,number:!0,of:!0,"elements,":!0,so:!0,is:!0,incompatible:!0,with:!0,tuple:!0,"[2]":!0,in:!0,argument:!0,"`T`.":!0,'[invalid-tuple-arity]"}]':!0},"function mapTupleArray<T: [...], R>(\n  tuples: Array<T>, // An array of tuples\n  f: (...T) => R, // Function args match the tuple's types\n): Array<R> {\n  return tuples.map(args => f(...args));\n}\nmapTupleArray(\n  [[1, 'hi'], [3, 'bye']],\n  (x: number, y: string) => y.length === x,\n); // OK\n\ndeclare const arrays: Array<Array<number>>;\nmapTupleArray(arrays, (x: number, y: number) => x + y); // ERROR: array is not a tuple\n")),(0,l.mdx)("h2",{id:"adoption"},"Adoption"),(0,l.mdx)("p",null,"To use labeled tuple elements (including optional elements and variance annotations on elements) and tuple spread elements,\nyou need to upgrade your infrastructure so that it supports the syntax:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"flow")," and ",(0,l.mdx)("inlineCode",{parentName:"li"},"flow-parser"),": 0.212"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"prettier"),": 3"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"babel")," with ",(0,l.mdx)("inlineCode",{parentName:"li"},"babel-plugin-syntax-hermes-parser")," (v0.15). See ",(0,l.mdx)("a",{parentName:"li",href:"../../tools/babel/"},"our Babel guide")," for setup instructions."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"eslint")," with ",(0,l.mdx)("inlineCode",{parentName:"li"},"hermes-eslint")," (v0.15). See ",(0,l.mdx)("a",{parentName:"li",href:"../../tools/eslint/"},"our ESLint guide")," for setup instructions.")),(0,l.mdx)("p",null,"To use inexact tuples, upgrade to:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"flow")," and ",(0,l.mdx)("inlineCode",{parentName:"li"},"flow-parser"),": 0.243"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"prettier"),": 3.3"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"babel")," with ",(0,l.mdx)("inlineCode",{parentName:"li"},"babel-plugin-syntax-hermes-parser")," (v0.23). See ",(0,l.mdx)("a",{parentName:"li",href:"../../tools/babel/"},"our Babel guide")," for setup instructions."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"eslint")," with ",(0,l.mdx)("inlineCode",{parentName:"li"},"hermes-eslint")," (v0.23). See ",(0,l.mdx)("a",{parentName:"li",href:"../../tools/eslint/"},"our ESLint guide")," for setup instructions.")))}m.isMDXComponent=!0}}]);