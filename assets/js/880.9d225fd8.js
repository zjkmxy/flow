"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[880],{20880:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>d});var t=s(58168),a=(s(96540),s(15680));s(60681);const r={title:"Classes",slug:"/types/classes"},o=void 0,i={unversionedId:"types/classes",id:"types/classes",title:"Classes",description:"JavaScript classes",source:"@site/docs/types/classes.md",sourceDirName:"types",slug:"/types/classes",permalink:"/en/docs/types/classes",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/types/classes.md",tags:[],version:"current",frontMatter:{title:"Classes",slug:"/types/classes"},sidebar:"docsSidebar",previous:{title:"Tuples",permalink:"/en/docs/types/tuples"},next:{title:"Type Aliases",permalink:"/en/docs/types/aliases"}},l={},d=[{value:"Class Syntax",id:"toc-class-syntax",level:2},{value:"Class Methods",id:"toc-class-methods",level:3},{value:"Class Fields (Properties)",id:"toc-class-fields-properties",level:3},{value:"Extending classes and implementing interfaces",id:"extending-classes-and-implementing-interfaces",level:3},{value:"Class Constructors",id:"toc-class-fields-constructors",level:3},{value:"Class Generics",id:"toc-class-generics",level:3},{value:"Classes in annotations",id:"toc-classes-in-annotations",level:2}],m={toc:d};function c(e){let{components:n,...s}=e;return(0,a.mdx)("wrapper",(0,t.A)({},m,s,{components:n,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"JavaScript ",(0,a.mdx)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes"},"classes"),"\nin Flow operate both as a value and a type. You can use the name of the class as the type of its instances:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"class MyClass {\n  // ...\n}\n\nconst myInstance: MyClass = new MyClass(); // Works!\n")),(0,a.mdx)("p",null,"This is because classes in Flow are ",(0,a.mdx)("a",{parentName:"p",href:"../../lang/nominal-structural"},"nominally typed"),"."),(0,a.mdx)("p",null,"This means two classes with identical shapes are not compatible:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":7,"startColumn":16,"endLine":7,"endColumn":22,"description":"Cannot assign `new A()` to `foo` because `A` [1] is incompatible with `B` [2]. [incompatible-type]"},{"startLine":8,"startColumn":16,"endLine":8,"endColumn":22,"description":"Cannot assign `new B()` to `bar` because `B` [1] is incompatible with `A` [2]. [incompatible-type]"}]','[{"startLine":7,"startColumn":16,"endLine":7,"endColumn":22,"description":"Cannot':!0,assign:!0,"`new":!0,"A()`":!0,to:!0,"`foo`":!0,because:!0,"`A`":!0,"[1]":!0,is:!0,incompatible:!0,with:!0,"`B`":!0,"[2].":!0,'[incompatible-type]"},{"startLine":8,"startColumn":16,"endLine":8,"endColumn":22,"description":"Cannot':!0,"B()`":!0,"`bar`":!0,'[incompatible-type]"}]':!0},"class A {\n  x: number;\n}\nclass B {\n  x: number;\n}\nconst foo: B = new A(); // Error!\nconst bar: A = new B(); // Error!\n")),(0,a.mdx)("p",null,"You also cannot use an ",(0,a.mdx)("a",{parentName:"p",href:"../objects"},"object type")," to describe an instance of a class:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":4,"startColumn":31,"endLine":4,"endColumn":43,"description":"Cannot assign `new MyClass()` to `foo` because `MyClass` [1] is not a subtype of object type [2]. Class instances are not subtypes of object types; consider rewriting object type [2] as an interface. [class-object-subtyping]"}]','[{"startLine":4,"startColumn":31,"endLine":4,"endColumn":43,"description":"Cannot':!0,assign:!0,"`new":!0,"MyClass()`":!0,to:!0,"`foo`":!0,because:!0,"`MyClass`":!0,"[1]":!0,is:!0,not:!0,a:!0,subtype:!0,of:!0,object:!0,type:!0,"[2].":!0,Class:!0,instances:!0,are:!0,subtypes:!0,"types;":!0,consider:!0,rewriting:!0,"[2]":!0,as:!0,an:!0,"interface.":!0,'[class-object-subtyping]"}]':!0},"class MyClass {\n  x: number;\n}\nconst foo: {x: number, ...} = new MyClass(); // Error!\n")),(0,a.mdx)("p",null,"You can use ",(0,a.mdx)("a",{parentName:"p",href:"../interfaces"},"interfaces")," to accomplish this instead:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"class A {\n  x: number;\n}\nclass B {\n  x: number;\n}\n\ninterface WithXNum {\n  x: number;\n}\n\nconst foo: WithXNum = new A(); // Works!\nconst bar: WithXNum = new B(); // Works!\n\nconst n: number = foo.x; // Works!\n")),(0,a.mdx)("h2",{id:"toc-class-syntax"},"Class Syntax"),(0,a.mdx)("p",null,"Classes in Flow are just like normal JavaScript classes, but with added types."),(0,a.mdx)("h3",{id:"toc-class-methods"},"Class Methods"),(0,a.mdx)("p",null,"Just like in ",(0,a.mdx)("a",{parentName:"p",href:"../functions"},"functions"),", class methods can have annotations for both parameters\n(input) and returns (output):"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"class MyClass {\n  method(value: string): number {\n    return 0;\n  }\n}\n")),(0,a.mdx)("p",null,"Also just like regular functions, class methods may have ",(0,a.mdx)("inlineCode",{parentName:"p"},"this")," annotations as well.\nHowever, if one is not provided, Flow will infer the class instance type (or the class type for static methods)\ninstead of ",(0,a.mdx)("inlineCode",{parentName:"p"},"mixed"),". When an explicit ",(0,a.mdx)("inlineCode",{parentName:"p"},"this")," parameter is provided, it must be a ",(0,a.mdx)("a",{parentName:"p",href:"../../lang/subtypes/"},"supertype")," of\nthe class instance type (or class type for static methods)."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":2,"startColumn":3,"endLine":2,"endColumn":8,"description":"Cannot define method `method` [1] on `MyClass` because property `x` is missing in `MyClass` [2] but exists in interface type [3]. [prop-missing]"}]','[{"startLine":2,"startColumn":3,"endLine":2,"endColumn":8,"description":"Cannot':!0,define:!0,method:!0,"`method`":!0,"[1]":!0,on:!0,"`MyClass`":!0,because:!0,property:!0,"`x`":!0,is:!0,missing:!0,in:!0,"[2]":!0,but:!0,exists:!0,interface:!0,type:!0,"[3].":!0,'[prop-missing]"}]':!0},"class MyClass {\n  method(this: interface {x: string}) { /* ... */ } // Error!\n}\n")),(0,a.mdx)("p",null,"Unlike class properties, however, class methods cannot be unbound or rebound from\nthe class on which you defined them. So all of the following are errors in Flow:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":3,"endLine":3,"endColumn":8,"description":"Cannot get `a.method` because property `method` [1] cannot be unbound from the context [2] where it was defined. [method-unbinding]"},{"startLine":4,"startColumn":8,"endLine":4,"endColumn":13,"description":"property `method` [1] cannot be unbound from the context [2] where it was defined. [method-unbinding]"},{"startLine":5,"startColumn":3,"endLine":5,"endColumn":8,"description":"Cannot get `a.method` because property `method` [1] cannot be unbound from the context [2] where it was defined. [method-unbinding]"}]','[{"startLine":3,"startColumn":3,"endLine":3,"endColumn":8,"description":"Cannot':!0,get:!0,"`a.method`":!0,because:!0,property:!0,"`method`":!0,"[1]":!0,cannot:!0,be:!0,unbound:!0,from:!0,the:!0,context:!0,"[2]":!0,where:!0,it:!0,was:!0,"defined.":!0,'[method-unbinding]"},{"startLine":4,"startColumn":8,"endLine":4,"endColumn":13,"description":"property':!0,'[method-unbinding]"},{"startLine":5,"startColumn":3,"endLine":5,"endColumn":8,"description":"Cannot':!0,'[method-unbinding]"}]':!0},"class MyClass { method() {} }\nconst a = new MyClass();\na.method; // Error!\nconst {method} = a; // Error!\na.method.bind({}); // Error!\n")),(0,a.mdx)("p",null,"Methods are considered ",(0,a.mdx)("a",{parentName:"p",href:"../../lang/variance"},"read-only"),":"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":3,"endLine":6,"endColumn":8,"description":"Cannot assign function to `a.method` because property `method` is not writable. [cannot-write]"}]','[{"startLine":6,"startColumn":3,"endLine":6,"endColumn":8,"description":"Cannot':!0,assign:!0,function:!0,to:!0,"`a.method`":!0,because:!0,property:!0,"`method`":!0,is:!0,not:!0,"writable.":!0,'[cannot-write]"}]':!0},"class MyClass {\n  method() {}\n}\n\nconst a = new MyClass();\na.method = function() {}; // Error!\n")),(0,a.mdx)("p",null,"Flow supports ",(0,a.mdx)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields"},"private methods"),",\na feature of ES2022. Private methods start with a hash symbol ",(0,a.mdx)("inlineCode",{parentName:"p"},"#"),":"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":11,"startColumn":3,"endLine":11,"endColumn":17,"description":"Private fields can only be referenced from within a class."}]','[{"startLine":11,"startColumn":3,"endLine":11,"endColumn":17,"description":"Private':!0,fields:!0,can:!0,only:!0,be:!0,referenced:!0,from:!0,within:!0,a:!0,'class."}]':!0},"class MyClass {\n  #internalMethod() {\n    return 1;\n  }\n  publicApi() {\n    return this.#internalMethod();\n  }\n}\n\nconst a = new MyClass();\na.#internalMethod(); // Error!\na.publicApi(); // Works!\n")),(0,a.mdx)("p",null,"Flow requires return type annotations on methods in most cases.\nThis is because it is common to reference ",(0,a.mdx)("inlineCode",{parentName:"p"},"this")," inside of a method, and ",(0,a.mdx)("inlineCode",{parentName:"p"},"this")," is typed as the instance of the class -\nbut to know the type of the class we need to know the return type of its methods!"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":2,"startColumn":8,"endLine":2,"endColumn":7,"description":"Missing an annotation on return. [missing-local-annot]"},{"startLine":5,"startColumn":8,"endLine":5,"endColumn":7,"description":"Missing an annotation on return. [missing-local-annot]"}]','[{"startLine":2,"startColumn":8,"endLine":2,"endColumn":7,"description":"Missing':!0,an:!0,annotation:!0,on:!0,"return.":!0,'[missing-local-annot]"},{"startLine":5,"startColumn":8,"endLine":5,"endColumn":7,"description":"Missing':!0,'[missing-local-annot]"}]':!0},"class MyClass {\n  foo() { // Error!\n    return this.bar();\n  }\n  bar() { // Error!\n    return 1;\n  }\n}\n")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"class MyClassFixed {\n  foo(): number { // Works!\n    return this.bar();\n  }\n  bar(): number { // Works!\n    return 1;\n  }\n}\n")),(0,a.mdx)("h3",{id:"toc-class-fields-properties"},"Class Fields (Properties)"),(0,a.mdx)("p",null,"Whenever you want to use a class field in Flow you must first give it an\nannotation:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":10,"endLine":3,"endColumn":13,"description":"Cannot assign `42` to `this.prop` because property `prop` is missing in `MyClass` [1]. [prop-missing]"}]','[{"startLine":3,"startColumn":10,"endLine":3,"endColumn":13,"description":"Cannot':!0,assign:!0,"`42`":!0,to:!0,"`this.prop`":!0,because:!0,property:!0,"`prop`":!0,is:!0,missing:!0,in:!0,"`MyClass`":!0,"[1].":!0,'[prop-missing]"}]':!0},"class MyClass {\n  method() {\n    this.prop = 42; // Error!\n  }\n}\n")),(0,a.mdx)("p",null,"Fields are annotated within the body of the class with the field name followed\nby a colon ",(0,a.mdx)("inlineCode",{parentName:"p"},":")," and the type:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"class MyClass {\n  prop: number;\n  method() {\n    this.prop = 42;\n  }\n}\n")),(0,a.mdx)("p",null,"Fields added outside of the class definition need to be annotated within the body\nof the class:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function func(x: number): number {\n  return x + 1;\n}\n\nclass MyClass {\n  static constant: number;\n  static helper: (number) => number;\n  prop: number => number;\n}\nMyClass.helper = func\nMyClass.constant = 42\nMyClass.prototype.prop = func\n")),(0,a.mdx)("p",null,"Flow also supports using the ",(0,a.mdx)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#field_declarations"},"class properties syntax"),":"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"class MyClass {\n  prop = 42;\n}\n")),(0,a.mdx)("p",null,"When using this syntax, you are not required to give it a type annotation. But\nyou still can if you need to:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"class MyClass {\n  prop: number = 42;\n}\n")),(0,a.mdx)("p",null,"You can mark a class field as read-only (or write-only) using ",(0,a.mdx)("a",{parentName:"p",href:"../../lang/variance"},"variance")," annotations.\nThese can only be written to in the constructor:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":9,"startColumn":10,"endLine":9,"endColumn":13,"description":"Cannot assign `1` to `this.prop` because property `prop` is not writable. [cannot-write]"},{"startLine":15,"startColumn":3,"endLine":15,"endColumn":6,"description":"Cannot assign `1` to `a.prop` because property `prop` is not writable. [cannot-write]"}]','[{"startLine":9,"startColumn":10,"endLine":9,"endColumn":13,"description":"Cannot':!0,assign:!0,"`1`":!0,to:!0,"`this.prop`":!0,because:!0,property:!0,"`prop`":!0,is:!0,not:!0,"writable.":!0,'[cannot-write]"},{"startLine":15,"startColumn":3,"endLine":15,"endColumn":6,"description":"Cannot':!0,"`a.prop`":!0,'[cannot-write]"}]':!0},"class MyClass {\n  +prop: number;\n\n  constructor() {\n    this.prop = 1; // Works!\n  }\n\n  method() {\n    this.prop = 1; // Error!\n  }\n}\n\nconst a = new MyClass();\nconst n: number = a.prop; // Works!\na.prop = 1; // Error!\n")),(0,a.mdx)("p",null,"Flow supports ",(0,a.mdx)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields"},"private fields"),",\na feature of ES2022. Private fields start with a hash symbol ",(0,a.mdx)("inlineCode",{parentName:"p"},"#"),":"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":14,"startColumn":21,"endLine":14,"endColumn":34,"description":"Private fields can only be referenced from within a class."}]','[{"startLine":14,"startColumn":21,"endLine":14,"endColumn":34,"description":"Private':!0,fields:!0,can:!0,only:!0,be:!0,referenced:!0,from:!0,within:!0,a:!0,'class."}]':!0},"class MyClass {\n  #internalValue: number;\n\n  constructor() {\n    this.#internalValue = 1;\n  }\n\n  publicApi() {\n    return this.#internalValue;\n  }\n}\n\nconst a = new MyClass();\nconst x: number = a.#internalValue; // Error!\nconst y: number = a.publicApi(); // Works!\n")),(0,a.mdx)("h3",{id:"extending-classes-and-implementing-interfaces"},"Extending classes and implementing interfaces"),(0,a.mdx)("p",null,"You can optionally ",(0,a.mdx)("inlineCode",{parentName:"p"},"extend")," one other class:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"class Base {\n  x: number;\n}\n\nclass MyClass extends Base {\n  y: string;\n}\n")),(0,a.mdx)("p",null,"And also implement multiple ",(0,a.mdx)("a",{parentName:"p",href:"../interfaces"},"interfaces"),":"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"interface WithXNum {\n  x: number;\n}\ninterface Readable {\n  read(): string;\n}\n\nclass MyClass implements WithXNum, Readable {\n  x: number;\n  read(): string {\n    return String(this.x);\n  }\n}\n")),(0,a.mdx)("p",null,"You don't need to ",(0,a.mdx)("inlineCode",{parentName:"p"},"implement")," an interface to be a subtype of it, but doing so enforces that your class meets the requirements:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":5,"startColumn":7,"endLine":5,"endColumn":13,"description":"Cannot implement `WithXNum` [1] with `MyClass` because property `x` is missing in `MyClass` [2] but exists in `WithXNum` [1]. [prop-missing]"}]','[{"startLine":5,"startColumn":7,"endLine":5,"endColumn":13,"description":"Cannot':!0,implement:!0,"`WithXNum`":!0,"[1]":!0,with:!0,"`MyClass`":!0,because:!0,property:!0,"`x`":!0,is:!0,missing:!0,in:!0,"[2]":!0,but:!0,exists:!0,"[1].":!0,'[prop-missing]"}]':!0},"interface WithXNum {\n  x: number;\n}\n\nclass MyClass implements WithXNum { // Error!\n}\n")),(0,a.mdx)("h3",{id:"toc-class-fields-constructors"},"Class Constructors"),(0,a.mdx)("p",null,"You can initialize your class properties in class constructors:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"class MyClass {\n  foo: number;\n\n  constructor() {\n    this.foo = 1;\n  }\n}\n")),(0,a.mdx)("p",null,"You must first call ",(0,a.mdx)("inlineCode",{parentName:"p"},"super(...)")," in a derived class before you can access ",(0,a.mdx)("inlineCode",{parentName:"p"},"this")," and ",(0,a.mdx)("inlineCode",{parentName:"p"},"super"),":"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":9,"startColumn":5,"endLine":9,"endColumn":8,"description":"Must call `super` before accessing this [1] in a derived constructor. [reference-before-declaration]"},{"startLine":10,"startColumn":5,"endLine":10,"endColumn":8,"description":"Must call `super` before accessing this [1] in a derived constructor. [reference-before-declaration]"},{"startLine":11,"startColumn":5,"endLine":11,"endColumn":9,"description":"Must call `super` before accessing super [1] in a derived constructor. [reference-before-declaration]"}]','[{"startLine":9,"startColumn":5,"endLine":9,"endColumn":8,"description":"Must':!0,call:!0,"`super`":!0,before:!0,accessing:!0,this:!0,"[1]":!0,in:!0,a:!0,derived:!0,"constructor.":!0,'[reference-before-declaration]"},{"startLine":10,"startColumn":5,"endLine":10,"endColumn":8,"description":"Must':!0,'[reference-before-declaration]"},{"startLine":11,"startColumn":5,"endLine":11,"endColumn":9,"description":"Must':!0,super:!0,'[reference-before-declaration]"}]':!0},"class Base {\n  bar: number;\n}\n\nclass MyClass extends Base {\n  foo: number;\n\n  constructor() {\n    this.foo; // Error\n    this.bar; // Error\n    super.bar; // Error\n    super();\n    this.foo; // OK\n    this.bar; // OK\n    super.bar; // OK\n  }\n}\n")),(0,a.mdx)("p",null,"However, Flow will not enforce that all class properties are initialized in constructors:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"class MyClass {\n  foo: number;\n  bar: number;\n\n  constructor() {\n    this.foo = 1;\n  }\n\n  useBar() {\n    (this.bar: number); // No errors.\n  }\n}\n")),(0,a.mdx)("h3",{id:"toc-class-generics"},"Class Generics"),(0,a.mdx)("p",null,"Classes can also have their own ",(0,a.mdx)("a",{parentName:"p",href:"../generics"},"generics"),":"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"class MyClass<A, B, C> {\n  property: A;\n  method(val: B): C {\n    throw new Error();\n  }\n}\n")),(0,a.mdx)("p",null,"Class generics are ",(0,a.mdx)("a",{parentName:"p",href:"../generics#toc-parameterized-generics"},"parameterized"),".\nWhen you use a class as a type you need to pass parameters for each of its\ngenerics:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"class MyClass<A, B, C> {\n  constructor(arg1: A, arg2: B, arg3: C) {\n    // ...\n  }\n}\n\nconst val: MyClass<number, boolean, string> = new MyClass(1, true, 'three');\n")),(0,a.mdx)("h2",{id:"toc-classes-in-annotations"},"Classes in annotations"),(0,a.mdx)("p",null,"When you use the name of your class in an annotation, it means an ",(0,a.mdx)("em",{parentName:"p"},"instance")," of your class:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"class MyClass {}\n\nconst b: MyClass = new MyClass(); // Works!\nconst a: MyClass = MyClass; // Error!\n")),(0,a.mdx)("p",null,"See ",(0,a.mdx)("a",{parentName:"p",href:"../utilities#toc-class"},"here")," for details on ",(0,a.mdx)("inlineCode",{parentName:"p"},"Class<T>"),", which allows you\nto refer to the type of the class in an annotation."))}c.isMDXComponent=!0}}]);