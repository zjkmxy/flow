"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[337],{60337:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>p,default:()=>m,frontMatter:()=>s,metadata:()=>r,toc:()=>o});var t=a(58168),i=(a(96540),a(15680));a(60681);const s={title:"Opaque Type Aliases",slug:"/types/opaque-types"},p=void 0,r={unversionedId:"types/opaque-types",id:"types/opaque-types",title:"Opaque Type Aliases",description:"Opaque type aliases are type aliases that do not allow access to their",source:"@site/docs/types/opaque-types.md",sourceDirName:"types",slug:"/types/opaque-types",permalink:"/en/docs/types/opaque-types",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/types/opaque-types.md",tags:[],version:"current",frontMatter:{title:"Opaque Type Aliases",slug:"/types/opaque-types"},sidebar:"docsSidebar",previous:{title:"Type Aliases",permalink:"/en/docs/types/aliases"},next:{title:"Interfaces",permalink:"/en/docs/types/interfaces"}},l={},o=[{value:"Opaque Type Alias Syntax",id:"toc-opaque-type-alias-syntax",level:2},{value:"Opaque Type Alias Type Checking",id:"toc-opaque-type-alias-type-checking",level:2},{value:"Within the Defining File",id:"toc-within-the-defining-file",level:3},{value:"Outside the Defining File",id:"toc-outside-the-defining-file",level:3},{value:"Subtyping Constraints",id:"toc-subtyping-constraints",level:3},{value:"Generics",id:"toc-generics",level:3},{value:"Library Definitions",id:"toc-library-definitions",level:3}],u={toc:o};function m(e){let{components:n,...a}=e;return(0,i.mdx)("wrapper",(0,t.A)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"Opaque type aliases are type aliases that do not allow access to their\nunderlying type outside of the file in which they are defined."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"opaque type ID = string;\n")),(0,i.mdx)("p",null,"Opaque type aliases, like regular type aliases, may be used anywhere a type can\nbe used."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"opaque type ID = string;\n\nfunction identity(x: ID): ID {\n  return x;\n}\nexport type {ID};\n")),(0,i.mdx)("h2",{id:"toc-opaque-type-alias-syntax"},"Opaque Type Alias Syntax"),(0,i.mdx)("p",null,"Opaque type aliases are created using the words ",(0,i.mdx)("inlineCode",{parentName:"p"},"opaque type")," followed by its\nname, an equals sign ",(0,i.mdx)("inlineCode",{parentName:"p"},"="),", and a type definition."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"opaque type Alias = Type;\n")),(0,i.mdx)("p",null,"You can optionally add a subtyping constraint to an opaque type alias by adding\na colon ",(0,i.mdx)("inlineCode",{parentName:"p"},":")," and a type after the name."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"opaque type Alias: SuperType = Type;\n")),(0,i.mdx)("p",null,"Any type can appear as the super type or type of an opaque type alias."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"opaque type StringAlias = string;\nopaque type ObjectAlias = {\n  property: string,\n  method(): number,\n};\nopaque type UnionAlias = 1 | 2 | 3;\nopaque type AliasAlias: ObjectAlias = ObjectAlias;\nopaque type VeryOpaque: AliasAlias = ObjectAlias;\n")),(0,i.mdx)("h2",{id:"toc-opaque-type-alias-type-checking"},"Opaque Type Alias Type Checking"),(0,i.mdx)("h3",{id:"toc-within-the-defining-file"},"Within the Defining File"),(0,i.mdx)("p",null,"When in the same file the alias is defined, opaque type aliases behave exactly\nas regular ",(0,i.mdx)("a",{parentName:"p",href:"../aliases/"},"type aliases")," do."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"opaque type NumberAlias = number;\n\n0 as NumberAlias;\n\nfunction add(x: NumberAlias, y: NumberAlias): NumberAlias {\n    return x + y;\n}\nfunction toNumberAlias(x: number): NumberAlias { return x; }\nfunction toNumber(x: NumberAlias): number { return x; }\n")),(0,i.mdx)("h3",{id:"toc-outside-the-defining-file"},"Outside the Defining File"),(0,i.mdx)("p",null,"When importing an opaque type alias, it behaves like a\n",(0,i.mdx)("a",{parentName:"p",href:"../../lang/nominal-structural/#toc-nominal-typing"},"nominal type"),", hiding its\nunderlying type."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},(0,i.mdx)("inlineCode",{parentName:"strong"},"exports.js"))),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"export opaque type NumberAlias = number;\n")),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},(0,i.mdx)("inlineCode",{parentName:"strong"},"imports.js"))),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"import type {NumberAlias} from './exports';\n\n0 as NumberAlias; // Error: 0 is not a NumberAlias!\n\nfunction convert(x: NumberAlias): number {\n  return x; // Error: x is not a number!\n}\n")),(0,i.mdx)("h3",{id:"toc-subtyping-constraints"},"Subtyping Constraints"),(0,i.mdx)("p",null,"When you add a subtyping constraint to an opaque type alias, we allow the opaque\ntype to be used as the super type when outside of the defining file."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},(0,i.mdx)("inlineCode",{parentName:"strong"},"exports.js"))),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"export opaque type ID: string = string;\n")),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},(0,i.mdx)("inlineCode",{parentName:"strong"},"imports.js"))),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"import type {ID} from './exports';\n\nfunction formatID(x: ID): string {\n    return \"ID: \" + x; // Ok! IDs are strings.\n}\n\nfunction toID(x: string): ID {\n    return x; // Error: strings are not IDs.\n}\n")),(0,i.mdx)("p",null,"When you create an opaque type alias with a subtyping constraint, the type in\nthe type position must be a subtype of the type in the super type position."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":27,"endLine":1,"endColumn":32,"description":"number [1] is incompatible with string [2]. [incompatible-type]"}]','[{"startLine":1,"startColumn":27,"endLine":1,"endColumn":32,"description":"number':!0,"[1]":!0,is:!0,incompatible:!0,with:!0,string:!0,"[2].":!0,'[incompatible-type]"}]':!0},"opaque type Bad: string = number; // Error: number is not a subtype of string\nopaque type Good: {x: string, ...} = {x: string, y: number};\n")),(0,i.mdx)("h3",{id:"toc-generics"},"Generics"),(0,i.mdx)("p",null,"Opaque type aliases can also have their own ",(0,i.mdx)("a",{parentName:"p",href:"../generics/"},"generics"),",\nand they work exactly as generics do in regular ",(0,i.mdx)("a",{parentName:"p",href:"../aliases#toc-type-alias-generics"},"type aliases")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"opaque type MyObject<A, B, C>: {foo: A, bar: B, ...} = {\n  foo: A,\n  bar: B,\n  baz: C,\n};\n\nvar val: MyObject<number, boolean, string> = {\n  foo: 1,\n  bar: true,\n  baz: 'three',\n};\n")),(0,i.mdx)("h3",{id:"toc-library-definitions"},"Library Definitions"),(0,i.mdx)("p",null,"You can also declare opaque type aliases in\n",(0,i.mdx)("a",{parentName:"p",href:"../../libdefs"},"libdefs"),". There, you omit the underlying\ntype, but may still optionally include a super type."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"declare opaque type Foo;\ndeclare opaque type PositiveNumber: number;\n")))}m.isMDXComponent=!0}}]);