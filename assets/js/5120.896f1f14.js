"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[5120],{35120:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=t(58168),o=(t(96540),t(15680));t(60681);const r={title:"Objects",slug:"/types/objects"},i=void 0,s={unversionedId:"types/objects",id:"types/objects",title:"Objects",description:"Objects can be used in many different ways in JavaScript.",source:"@site/docs/types/objects.md",sourceDirName:"types",slug:"/types/objects",permalink:"/en/docs/types/objects",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/types/objects.md",tags:[],version:"current",frontMatter:{title:"Objects",slug:"/types/objects"},sidebar:"docsSidebar",previous:{title:"Functions",permalink:"/en/docs/types/functions"},next:{title:"Arrays",permalink:"/en/docs/types/arrays"}},l={},p=[{value:"Optional object type properties",id:"toc-optional-object-type-properties",level:2},{value:"Read-only object properties",id:"read-only-object-properties",level:2},{value:"Object methods",id:"toc-object-methods",level:2},{value:"Object type inference",id:"toc-object-type-inference",level:2},{value:"Exact and inexact object types",id:"exact-and-inexact-object-types",level:2},{value:"Object type spread",id:"object-type-spread",level:2},{value:"Objects as maps",id:"toc-objects-as-maps",level:2},{value:"Keys, values, and indexed access",id:"keys-values-and-indexed-access",level:2},{value:"Arbitrary objects",id:"arbitrary-objects",level:2}],c={toc:p};function m(e){let{components:n,...t}=e;return(0,o.mdx)("wrapper",(0,a.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"Objects can be used in many different ways in JavaScript.\nThere are a number of ways to type them in order to support the different use cases."),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Exact object types: An object which has exactly a set of properties, e.g. ",(0,o.mdx)("inlineCode",{parentName:"li"},"{a: number}"),". We recommend using exact object types rather than inexact ones, as they are more precise and interact better with other type system features, like ",(0,o.mdx)("a",{parentName:"li",href:"#object-type-spread"},"spreads"),"."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"#exact-and-inexact-object-types"},"Inexact object types"),": An object with at least a set of properties, but potentially other, unknown ones, e.g. ",(0,o.mdx)("inlineCode",{parentName:"li"},"{a: number, ...}"),"."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"#toc-objects-as-maps"},"Objects with indexers"),": An object that can used as a map from a key type to a value type, e.g. ",(0,o.mdx)("inlineCode",{parentName:"li"},"{[string]: boolean}"),"."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"../interfaces"},"Interfaces"),": Interfaces are separate from object types. Only they can describe instances of classes. E.g. ",(0,o.mdx)("inlineCode",{parentName:"li"},"interfaces {a: number}"),".")),(0,o.mdx)("p",null,"Object types try to match the syntax for objects in JavaScript as much as\npossible. Using curly braces ",(0,o.mdx)("inlineCode",{parentName:"p"},"{}")," and name-value pairs using a colon ",(0,o.mdx)("inlineCode",{parentName:"p"},":")," split\nby commas ",(0,o.mdx)("inlineCode",{parentName:"p"},","),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const obj1: {foo: boolean} = {foo: true};\nconst obj2: {\n  foo: number,\n  bar: boolean,\n  baz: string,\n} = {\n  foo: 1,\n  bar: true,\n  baz: 'three',\n};\n")),(0,o.mdx)("h2",{id:"toc-optional-object-type-properties"},"Optional object type properties"),(0,o.mdx)("p",null,"In JavaScript, accessing a property that doesn't exist evaluates to\n",(0,o.mdx)("inlineCode",{parentName:"p"},"undefined"),". This is a common source of errors in JavaScript programs, so Flow\nturns these into type errors."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":2,"startColumn":5,"endLine":2,"endColumn":7,"description":"Cannot get `obj.bar` because property `bar` is missing in object literal [1]. [prop-missing]"}]','[{"startLine":2,"startColumn":5,"endLine":2,"endColumn":7,"description":"Cannot':!0,get:!0,"`obj.bar`":!0,because:!0,property:!0,"`bar`":!0,is:!0,missing:!0,in:!0,object:!0,literal:!0,"[1].":!0,'[prop-missing]"}]':!0},'const obj = {foo: "bar"};\nobj.bar; // Error!\n')),(0,o.mdx)("p",null,"If you have an object that sometimes does not have a property you can make it\nan ",(0,o.mdx)("em",{parentName:"p"},"optional property")," by adding a question mark ",(0,o.mdx)("inlineCode",{parentName:"p"},"?")," after the property name in\nthe object type."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":4,"startColumn":11,"endLine":4,"endColumn":17,"description":"Cannot assign `\'hello\'` to `obj.foo` because string [1] is incompatible with boolean [2]. [incompatible-type]"}]','[{"startLine":4,"startColumn":11,"endLine":4,"endColumn":17,"description":"Cannot':!0,assign:!0,"`'hello'`":!0,to:!0,"`obj.foo`":!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,boolean:!0,"[2].":!0,'[incompatible-type]"}]':!0},"const obj: {foo?: boolean} = {};\n\nobj.foo = true;    // Works!\nobj.foo = 'hello'; // Error!\n")),(0,o.mdx)("p",null,"In addition to their set value type, these optional properties can either be\n",(0,o.mdx)("inlineCode",{parentName:"p"},"void")," or omitted altogether. However, they cannot be ",(0,o.mdx)("inlineCode",{parentName:"p"},"null"),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":7,"startColumn":21,"endLine":7,"endColumn":24,"description":"Cannot call `acceptsObject` with object literal bound to `value` because null [1] is incompatible with string [2] in property `foo`. [incompatible-call]"}]','[{"startLine":7,"startColumn":21,"endLine":7,"endColumn":24,"description":"Cannot':!0,call:!0,"`acceptsObject`":!0,with:!0,object:!0,literal:!0,bound:!0,to:!0,"`value`":!0,because:!0,null:!0,"[1]":!0,is:!0,incompatible:!0,string:!0,"[2]":!0,in:!0,property:!0,"`foo`.":!0,'[incompatible-call]"}]':!0},'function acceptsObject(value: {foo?: string}) { /* ... */ }\n\nacceptsObject({foo: "bar"});     // Works!\nacceptsObject({foo: undefined}); // Works!\nacceptsObject({});               // Works!\n\nacceptsObject({foo: null});      // Error!\n')),(0,o.mdx)("p",null,"To make all properties in an object type optional, you can use the ",(0,o.mdx)("a",{parentName:"p",href:"../utilities/#toc-partial"},(0,o.mdx)("inlineCode",{parentName:"a"},"Partial"))," utility type:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Obj = {\n  foo: string,\n};\n\ntype PartialObj = Partial<Obj>; // Same as `{foo?: string}`\n")),(0,o.mdx)("p",null,"To make all properties in an object type required, you can use the ",(0,o.mdx)("a",{parentName:"p",href:"../utilities/#toc-required"},(0,o.mdx)("inlineCode",{parentName:"a"},"Required"))," utility type:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type PartialObj = {\n  foo?: string,\n};\n\ntype Obj = Required<PartialObj>; // Same as `{foo: string}`\n")),(0,o.mdx)("h2",{id:"read-only-object-properties"},"Read-only object properties"),(0,o.mdx)("p",null,"You can add ",(0,o.mdx)("a",{parentName:"p",href:"../../lang/variance"},"variance")," annotations to your object properties."),(0,o.mdx)("p",null,"To mark a property as read-only, you can use the ",(0,o.mdx)("inlineCode",{parentName:"p"},"+"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":7,"startColumn":5,"endLine":7,"endColumn":7,"description":"Cannot assign `\'hi\'` to `o.foo` because property `foo` is not writable. [cannot-write]"}]','[{"startLine":7,"startColumn":5,"endLine":7,"endColumn":7,"description":"Cannot':!0,assign:!0,"`'hi'`":!0,to:!0,"`o.foo`":!0,because:!0,property:!0,"`foo`":!0,is:!0,not:!0,"writable.":!0,'[cannot-write]"}]':!0},"type Obj = {\n  +foo: string,\n};\n\nfunction func(o: Obj) {\n  const x: string = o.foo; // Works!\n  o.foo = 'hi'; // Error!\n}\n")),(0,o.mdx)("p",null,"To make all object properties in an object type read-only, you can use the ",(0,o.mdx)("a",{parentName:"p",href:"../utilities/#toc-readonly"},(0,o.mdx)("inlineCode",{parentName:"a"},"$ReadOnly"))," utility type:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Obj = {\n  foo: string,\n};\n\ntype ReadOnlyObj = $ReadOnly<Obj>; // Same as `{+foo: string}`\n")),(0,o.mdx)("p",null,"You can also mark your properties as write-only with ",(0,o.mdx)("inlineCode",{parentName:"p"},"-"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":23,"endLine":6,"endColumn":25,"description":"Cannot get `o.foo` because property `foo` is not readable. [cannot-read]"}]','[{"startLine":6,"startColumn":23,"endLine":6,"endColumn":25,"description":"Cannot':!0,get:!0,"`o.foo`":!0,because:!0,property:!0,"`foo`":!0,is:!0,not:!0,"readable.":!0,'[cannot-read]"}]':!0},"type Obj = {\n  -foo: string,\n};\n\nfunction func(o: Obj) {\n  const x: string = o.foo; // Error!\n  o.foo = 'hi'; // Works!\n}\n")),(0,o.mdx)("h2",{id:"toc-object-methods"},"Object methods"),(0,o.mdx)("p",null,"Method syntax in objects has the same runtime behavior as a function property. These two objects are equivalent at runtime:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const a = {\n  foo: function () { return 3; }\n};\nconst b = {\n  foo() { return 3; }\n}\n")),(0,o.mdx)("p",null,"However, despite their equivalent runtime behavior, Flow checks them slightly differently. In particular, object\nproperties written with method syntax are ",(0,o.mdx)("a",{parentName:"p",href:"../../lang/variance"},"read-only"),"; Flow will not allow you to write a new value to them."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":4,"startColumn":3,"endLine":4,"endColumn":5,"description":"Cannot assign function to `b.foo` because property `foo` is not writable. [cannot-write]"}]','[{"startLine":4,"startColumn":3,"endLine":4,"endColumn":5,"description":"Cannot':!0,assign:!0,function:!0,to:!0,"`b.foo`":!0,because:!0,property:!0,"`foo`":!0,is:!0,not:!0,"writable.":!0,'[cannot-write]"}]':!0},"const b = {\n  foo() { return 3; }\n}\nb.foo = () => { return 2; } // Error!\n")),(0,o.mdx)("p",null,"Additionally, object methods do not allow the use of ",(0,o.mdx)("inlineCode",{parentName:"p"},"this")," in their bodies, in order to guarantee simple behavior\nfor their ",(0,o.mdx)("inlineCode",{parentName:"p"},"this")," parameters. Prefer to reference the object by name instead of using ",(0,o.mdx)("inlineCode",{parentName:"p"},"this"),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":18,"endLine":3,"endColumn":21,"description":"Cannot reference `this` from within method `foo` [1]. For safety, Flow restricts access to `this` inside object methods since these methods may be unbound and rebound. Consider replacing the reference to `this` with the name of the object, or rewriting the object as a class. [object-this-reference]"}]','[{"startLine":3,"startColumn":18,"endLine":3,"endColumn":21,"description":"Cannot':!0,reference:!0,"`this`":!0,from:!0,within:!0,method:!0,"`foo`":!0,"[1].":!0,For:!0,"safety,":!0,Flow:!0,restricts:!0,access:!0,to:!0,inside:!0,object:!0,methods:!0,since:!0,these:!0,may:!0,be:!0,unbound:!0,and:!0,"rebound.":!0,Consider:!0,replacing:!0,the:!0,with:!0,name:!0,of:!0,"object,":!0,or:!0,rewriting:!0,as:!0,a:!0,"class.":!0,'[object-this-reference]"}]':!0},"const a = {\n  x: 3,\n  foo() { return this.x; } // Error!\n}\nconst b = {\n  x: 3,\n  foo(): number { return b.x; } // Works!\n}\n")),(0,o.mdx)("h2",{id:"toc-object-type-inference"},"Object type inference"),(0,o.mdx)("blockquote",null,(0,o.mdx)("p",{parentName:"blockquote"},"NOTE: The behavior of empty object literals has changed in version 0.191 -\nsee this ",(0,o.mdx)("a",{parentName:"p",href:"https://medium.com/flow-type/improved-handling-of-the-empty-object-in-flow-ead91887e40c"},"blog post")," for more details.")),(0,o.mdx)("p",null,"When you create an object value, its type is set at the creation point. You cannot add new properties,\nor modify the type of existing properties."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":9,"startColumn":5,"endLine":9,"endColumn":11,"description":"Cannot get `obj.UNKNOWN` because property `UNKNOWN` is missing in object literal [1]. [prop-missing]"},{"startLine":10,"startColumn":11,"endLine":10,"endColumn":14,"description":"Cannot assign `true` to `obj.foo` because boolean [1] is incompatible with number [2]. [incompatible-type]"}]','[{"startLine":9,"startColumn":5,"endLine":9,"endColumn":11,"description":"Cannot':!0,get:!0,"`obj.UNKNOWN`":!0,because:!0,property:!0,"`UNKNOWN`":!0,is:!0,missing:!0,in:!0,object:!0,literal:!0,"[1].":!0,'[prop-missing]"},{"startLine":10,"startColumn":11,"endLine":10,"endColumn":14,"description":"Cannot':!0,assign:!0,"`true`":!0,to:!0,"`obj.foo`":!0,boolean:!0,"[1]":!0,incompatible:!0,with:!0,number:!0,"[2].":!0,'[incompatible-type]"}]':!0},"const obj = {\n  foo: 1,\n  bar: true,\n};\n\nconst n: number  = obj.foo; // Works!\nconst b: boolean = obj.bar; // Works!\n\nobj.UNKNOWN; // Error - prop `UNKNOWN` is not in the object value\nobj.foo = true; // Error - `foo` is of type `number`\n")),(0,o.mdx)("p",null,"If you supply a type annotation, you can add properties missing in the object value as optional properties:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const obj: {\n  foo?: number,\n  bar: boolean,\n} = {\n  // `foo` is not set here\n  bar: true,\n};\n\nconst n: number | void = obj.foo; // Works!\nconst b: boolean = obj.bar; // Works!\n\nif (b) {\n  obj.foo = 3; // Works!\n}\n")),(0,o.mdx)("p",null,"You can also give a wider type for a particular property:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'const obj: {\n  foo: number | string,\n} = {\n  foo: 1,\n};\n\nconst foo: number | string = obj.foo; // Works!\nobj.foo = "hi"; // Works!\n')),(0,o.mdx)("p",null,"The empty object can be interpreted as a ",(0,o.mdx)("a",{parentName:"p",href:"#toc-objects-as-maps"},"dictionary"),", if you supply the appropriate type annotation:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const dict: {[string]: number} = {}; // Works!\n")),(0,o.mdx)("p",null,"You may need to add type annotations to an object literal, if it references itself recursively (beyond simple cases):"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":7,"endLine":1,"endColumn":11,"description":"Cannot compute a type for `Utils` because its definition includes references to itself [1]. Please add an annotation to these definitions [2] [3] [recursive-definition]"}]','[{"startLine":1,"startColumn":7,"endLine":1,"endColumn":11,"description":"Cannot':!0,compute:!0,a:!0,type:!0,for:!0,"`Utils`":!0,because:!0,its:!0,definition:!0,includes:!0,references:!0,to:!0,itself:!0,"[1].":!0,Please:!0,add:!0,an:!0,annotation:!0,these:!0,definitions:!0,"[2]":!0,"[3]":!0,'[recursive-definition]"}]':!0},"const Utils = { // Error\n  foo() {\n    return Utils.bar();\n  },\n  bar() {\n    return 1;\n  }\n};\n\nconst FixedUtils = { // Works!\n  foo(): number {\n    return FixedUtils.bar();\n  },\n  bar(): number {\n    return 1;\n  }\n};\n")),(0,o.mdx)("h2",{id:"exact-and-inexact-object-types"},"Exact and inexact object types"),(0,o.mdx)("p",null,"Exact object types are the default (as of version 0.202), unless you have set ",(0,o.mdx)("a",{parentName:"p",href:"../../config/options#toc-exact-by-default"},(0,o.mdx)("inlineCode",{parentName:"a"},"exact_by_default=false"))," in your ",(0,o.mdx)("inlineCode",{parentName:"p"},".flowconfig"),"."),(0,o.mdx)("p",null,"Inexact objects (denoted with the ",(0,o.mdx)("inlineCode",{parentName:"p"},"..."),") allow extra properties to be passed in:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'function method(obj: {foo: string, ...}) { /* ... */ }\n\nmethod({foo: "test", bar: 42}); // Works!\n')),(0,o.mdx)("blockquote",null,(0,o.mdx)("p",{parentName:"blockquote"},(0,o.mdx)("strong",{parentName:"p"},"Note:")," This is because of ",(0,o.mdx)("a",{parentName:"p",href:"../../lang/width-subtyping"},'"width subtyping"'),".")),(0,o.mdx)("p",null,"But exact object types do not:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":8,"endLine":3,"endColumn":29,"description":"Cannot call `method` with object literal bound to `obj` because property `bar` is missing in object type [1] but exists in object literal [2]. [prop-missing]"}]','[{"startLine":3,"startColumn":8,"endLine":3,"endColumn":29,"description":"Cannot':!0,call:!0,"`method`":!0,with:!0,object:!0,literal:!0,bound:!0,to:!0,"`obj`":!0,because:!0,property:!0,"`bar`":!0,is:!0,missing:!0,in:!0,type:!0,"[1]":!0,but:!0,exists:!0,"[2].":!0,'[prop-missing]"}]':!0},'function method(obj: {foo: string}) { /* ... */ }\n\nmethod({foo: "test", bar: 42}); // Error!\n')),(0,o.mdx)("p",null,"If you have set ",(0,o.mdx)("inlineCode",{parentName:"p"},"exact_by_default=false"),', you can denote exact object types by adding a pair of "vertical bars" or "pipes" to the inside of the curly braces:'),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":28,"endLine":1,"endColumn":56,"description":"Cannot assign object literal to `x` because property `bar` is missing in object type [1] but exists in object literal [2]. [prop-missing]"}]','[{"startLine":1,"startColumn":28,"endLine":1,"endColumn":56,"description":"Cannot':!0,assign:!0,object:!0,literal:!0,to:!0,"`x`":!0,because:!0,property:!0,"`bar`":!0,is:!0,missing:!0,in:!0,type:!0,"[1]":!0,but:!0,exists:!0,"[2].":!0,'[prop-missing]"}]':!0},'const x: {|foo: string|} = {foo: "Hello", bar: "World!"}; // Error!\n')),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"../intersections"},"Intersections")," of exact object types may not work as you expect. If you need to combine exact object types, use ",(0,o.mdx)("a",{parentName:"p",href:"#object-type-spread"},"object type spread"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":8,"startColumn":33,"endLine":8,"endColumn":53,"description":"Cannot assign object literal to `fooBarFail` because property `bar` is missing in `FooT` [1] but exists in object literal [2]. [prop-missing]"},{"startLine":8,"startColumn":33,"endLine":8,"endColumn":53,"description":"Cannot assign object literal to `fooBarFail` because property `foo` is missing in `BarT` [1] but exists in object literal [2]. [prop-missing]"}]','[{"startLine":8,"startColumn":33,"endLine":8,"endColumn":53,"description":"Cannot':!0,assign:!0,object:!0,literal:!0,to:!0,"`fooBarFail`":!0,because:!0,property:!0,"`bar`":!0,is:!0,missing:!0,in:!0,"`FooT`":!0,"[1]":!0,but:!0,exists:!0,"[2].":!0,'[prop-missing]"},{"startLine":8,"startColumn":33,"endLine":8,"endColumn":53,"description":"Cannot':!0,"`foo`":!0,"`BarT`":!0,'[prop-missing]"}]':!0},"type FooT = {foo: string};\ntype BarT = {bar: number};\n\ntype FooBarT = {...FooT, ...BarT};\nconst fooBar: FooBarT = {foo: '123', bar: 12}; // Works!\n\ntype FooBarFailT = FooT & BarT;\nconst fooBarFail: FooBarFailT = {foo: '123', bar: 12}; // Error!\n")),(0,o.mdx)("h2",{id:"object-type-spread"},"Object type spread"),(0,o.mdx)("p",null,"Just like you can spread object values, you can also spread object types:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type ObjA = {\n  a: number,\n  b: string,\n};\n\nconst x: ObjA = {a: 1, b: \"hi\"};\n\ntype ObjB = {\n  ...ObjA,\n  c: boolean,\n};\n\nconst y: ObjB = {a: 1, b: 'hi', c: true}; // Works!\nconst z: ObjB = {...x, c: true}; // Works!\n")),(0,o.mdx)("p",null,"You have to be careful spreading inexact objects.\nThe resulting object must also be inexact,\nand the spread inexact object may have unknown properties that can override previous properties in unknown ways:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":7,"startColumn":13,"endLine":10,"endColumn":1,"description":"Flow cannot determine a type for object type [1]. `Inexact` [2] is inexact, so it may contain `c` with a type that conflicts with `c`\'s definition in object type [1]. Try making `Inexact` [2] exact. [cannot-spread-inexact]"},{"startLine":9,"startColumn":6,"endLine":9,"endColumn":12,"description":"inexact `Inexact` [1] is incompatible with exact object type [2]. [incompatible-exact]"}]','[{"startLine":7,"startColumn":13,"endLine":10,"endColumn":1,"description":"Flow':!0,cannot:!0,determine:!0,a:!0,type:!0,for:!0,object:!0,"[1].":!0,"`Inexact`":!0,"[2]":!0,is:!0,"inexact,":!0,so:!0,it:!0,may:!0,contain:!0,"`c`":!0,with:!0,that:!0,conflicts:!0,"`c`'s":!0,definition:!0,in:!0,Try:!0,making:!0,"exact.":!0,'[cannot-spread-inexact]"},{"startLine":9,"startColumn":6,"endLine":9,"endColumn":12,"description":"inexact':!0,"[1]":!0,incompatible:!0,exact:!0,"[2].":!0,'[incompatible-exact]"}]':!0},"type Inexact = {\n  a: number,\n  b: string,\n  ...\n};\n\ntype ObjB = { // Error!\n  c: boolean,\n  ...Inexact,\n};\n\nconst x: ObjB = {a:1, b: 'hi', c: true};\n")),(0,o.mdx)("p",null,"The same issue exists with objects with ",(0,o.mdx)("a",{parentName:"p",href:"#toc-objects-as-maps"},"indexers"),", as they also have unknown keys:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":5,"startColumn":13,"endLine":8,"endColumn":1,"description":"Flow cannot determine a type for object type [1]. `Dict` [2] cannot be spread because the indexer string [3] may overwrite properties with explicit keys in a way that Flow cannot track. Try spreading `Dict` [2] first or remove the indexer. [cannot-spread-indexer]"}]','[{"startLine":5,"startColumn":13,"endLine":8,"endColumn":1,"description":"Flow':!0,cannot:!0,determine:!0,a:!0,type:!0,for:!0,object:!0,"[1].":!0,"`Dict`":!0,"[2]":!0,be:!0,spread:!0,because:!0,the:!0,indexer:!0,string:!0,"[3]":!0,may:!0,overwrite:!0,properties:!0,with:!0,explicit:!0,keys:!0,in:!0,way:!0,that:!0,Flow:!0,"track.":!0,Try:!0,spreading:!0,first:!0,or:!0,remove:!0,"indexer.":!0,'[cannot-spread-indexer]"}]':!0},"type Dict = {\n  [string]: number,\n};\n\ntype ObjB = { // Error!\n  c: boolean,\n  ...Dict,\n};\n\nconst x: ObjB = {a: 1, b: 2, c: true};\n")),(0,o.mdx)("p",null,'Spreading an object value at runtime only spreads "own" properties, that is properties that are on the object directly, not the prototype chain.\nObject type spread works in the same way.\nBecause of this, you can\'t spread ',(0,o.mdx)("a",{parentName:"p",href:"../interfaces"},"interfaces"),', as they don\'t track whether a property is "own" or not:'),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":13,"endLine":9,"endColumn":1,"description":"Flow cannot determine a type for object type [1]. `Iface` [2] cannot be spread because interfaces do not track the own-ness of their properties. Try using an object type instead. [cannot-spread-interface]"}]','[{"startLine":6,"startColumn":13,"endLine":9,"endColumn":1,"description":"Flow':!0,cannot:!0,determine:!0,a:!0,type:!0,for:!0,object:!0,"[1].":!0,"`Iface`":!0,"[2]":!0,be:!0,spread:!0,because:!0,interfaces:!0,do:!0,not:!0,track:!0,the:!0,"own-ness":!0,of:!0,their:!0,"properties.":!0,Try:!0,using:!0,an:!0,"instead.":!0,'[cannot-spread-interface]"}]':!0},"interface Iface {\n  a: number;\n  b: string;\n}\n\ntype ObjB = { // Error!\n  c: boolean,\n  ...Iface,\n};\n\nconst x: ObjB = {a: 1, b: 'hi', c: true};\n")),(0,o.mdx)("h2",{id:"toc-objects-as-maps"},"Objects as maps"),(0,o.mdx)("p",null,"JavaScript includes a ",(0,o.mdx)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"},(0,o.mdx)("inlineCode",{parentName:"a"},"Map"))," class,\nbut it is still very common to use objects as maps as well. In this use case, an object\nwill likely have properties added to it and retrieved throughout its lifecycle.\nFurthermore, the property keys may not even be known statically, so writing out\na type annotation would not be possible."),(0,o.mdx)("p",null,'For objects like these, Flow provides a special kind of property, called an\n"indexer property." An indexer property allows reads and writes using any key\nthat matches the indexer key type.'),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'const o: {[string]: number} = {};\no["foo"] = 0;\no["bar"] = 1;\nconst foo: number = o["foo"];\n')),(0,o.mdx)("p",null,"An indexer can be optionally named, for documentation purposes:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'const obj: {[user_id: number]: string} = {};\nobj[1] = "Julia";\nobj[2] = "Camille";\nobj[3] = "Justin";\nobj[4] = "Mark";\n')),(0,o.mdx)("p",null,"When an object type has an indexer property, property accesses are assumed to\nhave the annotated type, even if the object does not have a value in that slot\nat runtime. It is the programmer's responsibility to ensure the access is safe,\nas with arrays."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const obj: {[number]: string} = {};\nobj[42].length; // No type error, but will throw at runtime\n")),(0,o.mdx)("p",null,"Indexer properties can be mixed with named properties:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const obj: {\n  size: number,\n  [id: number]: string\n} = {\n  size: 0\n};\n\nfunction add(id: number, name: string) {\n  obj[id] = name;\n  obj.size++;\n}\n")),(0,o.mdx)("p",null,"You can mark an indexer property as read-only (or write-only) using ",(0,o.mdx)("a",{parentName:"p",href:"../../lang/variance"},"variance")," annotations:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type ReadOnly = {+[string]: number};\ntype WriteOnly = {-[string]: number};\n")),(0,o.mdx)("h2",{id:"keys-values-and-indexed-access"},"Keys, values, and indexed access"),(0,o.mdx)("p",null,"You can extract the keys of an object type using the ",(0,o.mdx)("a",{parentName:"p",href:"../utilities/#toc-keys"},(0,o.mdx)("inlineCode",{parentName:"a"},"$Keys"))," utility type:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":12,"startColumn":13,"endLine":12,"endColumn":16,"description":"Cannot call `acceptsKeys` with `\'hi\'` bound to `k` because property `hi` is missing in `Obj` [1]. [prop-missing]"}]','[{"startLine":12,"startColumn":13,"endLine":12,"endColumn":16,"description":"Cannot':!0,call:!0,"`acceptsKeys`":!0,with:!0,"`'hi'`":!0,bound:!0,to:!0,"`k`":!0,because:!0,property:!0,"`hi`":!0,is:!0,missing:!0,in:!0,"`Obj`":!0,"[1].":!0,'[prop-missing]"}]':!0},"type Obj = {\n  foo: string,\n  bar: number,\n};\n\ntype T = $Keys<Obj>;\n\nfunction acceptsKeys(k: T) { /* ... */ }\n\nacceptsKeys('foo'); // Works!\nacceptsKeys('bar'); // Works!\nacceptsKeys('hi'); // Error!\n")),(0,o.mdx)("p",null,"You can extract the values of an object type using the ",(0,o.mdx)("a",{parentName:"p",href:"../utilities/#toc-values"},(0,o.mdx)("inlineCode",{parentName:"a"},"$Values"))," utility type:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":12,"startColumn":15,"endLine":12,"endColumn":18,"description":"Cannot call `acceptsValues` with `true` bound to `v` because: [incompatible-call] Either boolean [1] is incompatible with string [2]. Or boolean [1] is incompatible with number [3]."}]','[{"startLine":12,"startColumn":15,"endLine":12,"endColumn":18,"description":"Cannot':!0,call:!0,"`acceptsValues`":!0,with:!0,"`true`":!0,bound:!0,to:!0,"`v`":!0,"because:":!0,"[incompatible-call]":!0,Either:!0,boolean:!0,"[1]":!0,is:!0,incompatible:!0,string:!0,"[2].":!0,Or:!0,number:!0,'[3]."}]':!0},"type Obj = {\n  foo: string,\n  bar: number,\n};\n\ntype T = $Values<Obj>;\n\nfunction acceptsValues(v: T) { /* ... */ }\n\nacceptsValues(2); // Works!\nacceptsValues('hi'); // Works!\nacceptsValues(true); // Error!\n")),(0,o.mdx)("p",null,"You can get the type of an object type's specific property using ",(0,o.mdx)("a",{parentName:"p",href:"../indexed-access"},"indexed access types"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":11,"startColumn":12,"endLine":11,"endColumn":12,"description":"Cannot call `acceptsStr` with `1` bound to `x` because number [1] is incompatible with string [2]. [incompatible-call]"}]','[{"startLine":11,"startColumn":12,"endLine":11,"endColumn":12,"description":"Cannot':!0,call:!0,"`acceptsStr`":!0,with:!0,"`1`":!0,bound:!0,to:!0,"`x`":!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,string:!0,"[2].":!0,'[incompatible-call]"}]':!0},"type Obj = {\n  foo: string,\n  bar: number,\n};\n\ntype T = Obj['foo'];\n\nfunction acceptsStr(x: T) { /* ... */ }\n\nacceptsStr('hi'); // Works!\nacceptsStr(1); // Error!\n")),(0,o.mdx)("h2",{id:"arbitrary-objects"},"Arbitrary objects"),(0,o.mdx)("p",null,"If you want to accept an arbitrary object safely, there are a couple of patterns you could use."),(0,o.mdx)("p",null,"An empty inexact object ",(0,o.mdx)("inlineCode",{parentName:"p"},"{...}")," accepts any object:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'function func(obj: {...}) {\n  // ...\n}\n\nfunc({}); // Works!\nfunc({a: 1, b: "foo"}); // Works!\n')),(0,o.mdx)("p",null,"It's often the right choice for a ",(0,o.mdx)("a",{parentName:"p",href:"../generics"},"generic")," bounded to accept any object:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'function func<T: {...}>(obj: T) {\n  // ...\n}\n\nfunc({}); // Works!\nfunc({a: 1, b: "foo"}); // Works!\n')),(0,o.mdx)("p",null,"However, you can't access any properties off of ",(0,o.mdx)("inlineCode",{parentName:"p"},"{...}"),"."),(0,o.mdx)("p",null,"You can also try using a ",(0,o.mdx)("a",{parentName:"p",href:"#toc-objects-as-maps"},"dictionary")," with ",(0,o.mdx)("a",{parentName:"p",href:"../mixed"},(0,o.mdx)("inlineCode",{parentName:"a"},"mixed"))," values, which would allow you to access any property (with a resulting ",(0,o.mdx)("inlineCode",{parentName:"p"},"mixed")," type):"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function func(obj: {+[string]: mixed}) {\n  const x: mixed = obj['bar'];\n}\n\nfunc({}); // Works!\nfunc({a: 1, b: \"foo\"}); // Works!\n")),(0,o.mdx)("p",null,"The type ",(0,o.mdx)("inlineCode",{parentName:"p"},"Object")," is just an alias for ",(0,o.mdx)("a",{parentName:"p",href:"../any"},(0,o.mdx)("inlineCode",{parentName:"a"},"any")),", and is unsafe.\nYou can ban its use in your code with the ",(0,o.mdx)("a",{parentName:"p",href:"../../linting/rule-reference/#toc-unclear-type"},"unclear-type lint"),"."))}m.isMDXComponent=!0}}]);