"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[9624],{18430:(e,n,t)=>{t.d(n,{V:()=>s,v:()=>i});var a=t(96540);function s(e){let{version:n}=e;return a.createElement("span",{class:"version added",title:"Added in "+n},"\u2265",n)}function i(e){let{version:n}=e;return a.createElement("span",{class:"version removed",title:"Removed after "+n},"\u2264",n)}},19624:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>m,default:()=>c,frontMatter:()=>u,metadata:()=>o,toc:()=>r});var a=t(58168),s=(t(96540),t(15680)),i=(t(60681),t(18430));const u={title:"Using enums",slug:"/enums/using-enums"},m=void 0,o={unversionedId:"enums/using-enums",id:"enums/using-enums",title:"Using enums",description:"Flow Enums are not a syntax for union types. They are their own type, and each member of a Flow Enum has the same type.",source:"@site/docs/enums/using-enums.md",sourceDirName:"enums",slug:"/enums/using-enums",permalink:"/en/docs/enums/using-enums",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/enums/using-enums.md",tags:[],version:"current",frontMatter:{title:"Using enums",slug:"/enums/using-enums"},sidebar:"docsSidebar",previous:{title:"Defining enums",permalink:"/en/docs/enums/defining-enums"},next:{title:"Migrating from legacy patterns",permalink:"/en/docs/enums/migrating-legacy-patterns"}},l={},r=[{value:"Accessing enum members",id:"toc-accessing-enum-members",level:3},{value:"Using as a type annotation",id:"toc-using-as-a-type-annotation",level:3},{value:"Casting to representation type",id:"toc-casting-to-representation-type",level:3},{value:"Methods",id:"toc-methods",level:3},{value:".cast",id:"toc-cast",level:4},{value:".isValid",id:"toc-isvalid",level:4},{value:".members",id:"toc-members",level:4},{value:".getName",id:"toc-getname",level:4},{value:"Exhaustively checking enums with a <code>switch</code>",id:"toc-exhaustively-checking-enums-with-a-switch",level:3},{value:"Exhaustive checking with unknown members",id:"toc-exhaustive-checking-with-unknown-members",level:3},{value:"Mapping enums to other values",id:"toc-mapping-enums-to-other-values",level:3},{value:"Enums in a union",id:"toc-enums-in-a-union",level:3},{value:"Exporting enums",id:"toc-exporting-enums",level:3},{value:"Importing enums",id:"toc-importing-enums",level:3},{value:'Abstract enums <SinceVersion version="0.234" />',id:"toc-abstract-enums",level:3},{value:"EnumValue&lt;&gt;",id:"enumvalue",level:4},{value:"Enum&lt;&gt;",id:"enum",level:4},{value:"Usage",id:"usage",level:5},{value:"Definition",id:"definition",level:5},{value:"When to not use enums",id:"toc-when-to-not-use-enums",level:3},{value:"Distinct object keys",id:"toc-distinct-object-keys",level:4},{value:"Disjoint object unions",id:"toc-disjoint-object-unions",level:4},{value:"Guaranteed inlining",id:"toc-guaranteed-inlining",level:4}],d={toc:r};function c(e){let{components:n,...t}=e;return(0,s.mdx)("wrapper",(0,a.A)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,s.mdx)("p",null,"Flow Enums are not a syntax for ",(0,s.mdx)("a",{parentName:"p",href:"../../types/unions/"},"union types"),". They are their own type, and each member of a Flow Enum has the same type.\nLarge union types can cause performance issues, as Flow has to consider each member as a separate type. With Flow Enums, no matter how large your enum is,\nFlow will always exhibit good performance as it only has one type to keep track of."),(0,s.mdx)("p",null,"We use the following enum in the examples below:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"enum Status {\n  Active,\n  Paused,\n  Off,\n}\n")),(0,s.mdx)("h3",{id:"toc-accessing-enum-members"},"Accessing enum members"),(0,s.mdx)("p",null,"Access members with the dot syntax:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"const status = Status.Active;\n")),(0,s.mdx)("p",null,"You can\u2019t use computed access:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":7,"startColumn":8,"endLine":7,"endColumn":8,"description":"Cannot access `x` on enum `Status` [1] because computed access is not allowed on enums. [invalid-enum-access]"}]','[{"startLine":7,"startColumn":8,"endLine":7,"endColumn":8,"description":"Cannot':!0,access:!0,"`x`":!0,on:!0,enum:!0,"`Status`":!0,"[1]":!0,because:!0,computed:!0,is:!0,not:!0,allowed:!0,"enums.":!0,'[invalid-enum-access]"}]':!0},'enum Status {\n  Active,\n  Paused,\n  Off,\n}\nconst x = "Active";\nStatus[x]; // Error: computed access on enums is not allowed\n')),(0,s.mdx)("h3",{id:"toc-using-as-a-type-annotation"},"Using as a type annotation"),(0,s.mdx)("p",null,"The enum declaration defines both a value (from which you can access the enum members and methods) and a type of the same name, which is the type of the enum members."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"function calculateStatus(): Status {\n  ...\n}\n\nconst status: Status = calculateStatus();\n")),(0,s.mdx)("h3",{id:"toc-casting-to-representation-type"},"Casting to representation type"),(0,s.mdx)("p",null,"Enums do not implicitly coerce to their representation type or vice-versa.\nIf you want to convert from the enum type to the representation type, you can use an explicit cast ",(0,s.mdx)("inlineCode",{parentName:"p"},"x as string"),":"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":19,"endLine":3,"endColumn":31,"description":"Cannot assign `Status.Active` to `s` because `Status` [1] is incompatible with string [2]. You can explicitly cast your enum value to a string using `<expr> as string`. [incompatible-type]"}]','[{"startLine":3,"startColumn":19,"endLine":3,"endColumn":31,"description":"Cannot':!0,assign:!0,"`Status.Active`":!0,to:!0,"`s`":!0,because:!0,"`Status`":!0,"[1]":!0,is:!0,incompatible:!0,with:!0,string:!0,"[2].":!0,You:!0,can:!0,explicitly:!0,cast:!0,your:!0,enum:!0,value:!0,a:!0,using:!0,"`<expr>":!0,as:!0,"string`.":!0,'[incompatible-type]"}]':!0},"enum Status {Active, Paused, Off}\n\nconst s: string = Status.Active; // Error: 'Status' is not compatible with 'string'\n\ndeclare const status: Status;\nconst statusString: string = status as string;\n")),(0,s.mdx)("p",null,"You can also call ",(0,s.mdx)("inlineCode",{parentName:"p"},".valueOf()")," on the enum value ",(0,s.mdx)(i.V,{version:"0.234",mdxType:"SinceVersion"}),".\nThis is particularly useful if you are dealing with ",(0,s.mdx)("a",{parentName:"p",href:"#toc-abstract-enums"},"abstract enums")," and don't know the representation type."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"enum Status {Active, Paused, Off}\n\ndeclare const status: Status;\nconst statusString: string = status.valueOf();\n")),(0,s.mdx)("p",null,"To convert from a nullable enum type to nullable representation type, you can do:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"enum Status {Active, Paused, Off}\ndeclare const maybeStatus: ?Status;\n\n// Using `as` cast and `&&`:\nconst maybeStatusString1: ?string = maybeStatus && (maybeStatus as string);\n\n// Using `.valueOf()` and optional chaining:\nconst maybeStatusString2: ?string = maybeStatus?.valueOf();\n")),(0,s.mdx)("p",null,"If you want to convert from the representation type (e.g. ",(0,s.mdx)("inlineCode",{parentName:"p"},"string"),") to an enum type (if valid), check out the ",(0,s.mdx)("a",{parentName:"p",href:"#toc-cast"},"cast method"),"."),(0,s.mdx)("h3",{id:"toc-methods"},"Methods"),(0,s.mdx)("p",null,"Enum declarations also define some helpful methods."),(0,s.mdx)("p",null,"Below, ",(0,s.mdx)("inlineCode",{parentName:"p"},"TEnum")," is the type of the enum (e.g. ",(0,s.mdx)("inlineCode",{parentName:"p"},"Status"),"), and ",(0,s.mdx)("inlineCode",{parentName:"p"},"TRepresentationType")," is the type of the representation type for that enum (e.g. ",(0,s.mdx)("inlineCode",{parentName:"p"},"string"),")."),(0,s.mdx)("h4",{id:"toc-cast"},".cast"),(0,s.mdx)("p",null,"Type: ",(0,s.mdx)("inlineCode",{parentName:"p"},"cast(input: ?TRepresentationType): TEnum | void")),(0,s.mdx)("p",null,"The ",(0,s.mdx)("inlineCode",{parentName:"p"},"cast")," method allows you to safely convert a primitive value, like a ",(0,s.mdx)("inlineCode",{parentName:"p"},"string"),", to the enum type (if it is a valid value of the enum), and ",(0,s.mdx)("inlineCode",{parentName:"p"},"undefined")," otherwise."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"const data: string = getData();\nconst maybeStatus: Status | void = Status.cast(data);\nif (maybeStatus != null) {\n  const status: Status = maybeStatus;\n  // do stuff with status\n}\n")),(0,s.mdx)("p",null,"Set a default value in one line with the ",(0,s.mdx)("inlineCode",{parentName:"p"},"??")," operator:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"const status: Status = Status.cast(data) ?? Status.Off;\n")),(0,s.mdx)("p",null,"The type of the argument of ",(0,s.mdx)("inlineCode",{parentName:"p"},"cast")," depends on the type of enum. If it is a ",(0,s.mdx)("a",{parentName:"p",href:"../defining-enums/#toc-string-enums"},"string enum"),", the type of the argument will be ",(0,s.mdx)("inlineCode",{parentName:"p"},"string"),".\nIf it is a ",(0,s.mdx)("a",{parentName:"p",href:"../defining-enums/#toc-number-enums"},"number enum"),", the type of the argument will be ",(0,s.mdx)("inlineCode",{parentName:"p"},"number"),", and so on.\nIf you wish to cast a ",(0,s.mdx)("inlineCode",{parentName:"p"},"mixed")," value, first use a ",(0,s.mdx)("inlineCode",{parentName:"p"},"typeof")," refinement:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"const data: mixed = ...;\nif (typeof data === 'string') {\n  const maybeStatus: Status | void = Status.cast(data);\n}\n")),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"cast")," uses ",(0,s.mdx)("inlineCode",{parentName:"p"},"this")," (representing the object of enum members), so if you want to pass the function itself as a value, you should use an arrow function. For example:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"const strings: Array<string> = ...;\n// WRONG: const statuses: Array<?Status> = strings.map(Status.cast);\nconst statuses: Array<?Status> = strings.map((input) => Status.cast(input)); // Correct\n")),(0,s.mdx)("p",null,"Runtime cost: For ",(0,s.mdx)("a",{parentName:"p",href:"../defining-enums/#toc-string-enums"},"mirrored string enums")," (e.g ",(0,s.mdx)("inlineCode",{parentName:"p"},"enum E {A, B}"),"), as the member names are the same as the values, the runtime cost is constant -\nequivalent to calling ",(0,s.mdx)("inlineCode",{parentName:"p"},".hasOwnProperty"),". For other enums, a ",(0,s.mdx)("inlineCode",{parentName:"p"},"Map")," is created on the first call, and subsequent calls simply call ",(0,s.mdx)("inlineCode",{parentName:"p"},".has")," on the cached map.\nThus the cost is amoritzed constant."),(0,s.mdx)("h4",{id:"toc-isvalid"},".isValid"),(0,s.mdx)("p",null,"Type: ",(0,s.mdx)("inlineCode",{parentName:"p"},"isValid(input: ?TRepresentationType): boolean")),(0,s.mdx)("p",null,"The ",(0,s.mdx)("inlineCode",{parentName:"p"},"isValid")," method is like ",(0,s.mdx)("inlineCode",{parentName:"p"},"cast"),", but simply returns a boolean: ",(0,s.mdx)("inlineCode",{parentName:"p"},"true")," if the input supplied is a valid enum value, and ",(0,s.mdx)("inlineCode",{parentName:"p"},"false")," if it is not."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"const data: string = getData();\nconst isStatus: boolean = Status.isValid(data);\n")),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"isValid")," uses ",(0,s.mdx)("inlineCode",{parentName:"p"},"this")," (representing the object of enum members), so if you want to pass the function itself as a value, you should use an arrow function. For example:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"const strings: Array<string> = ...;\n// WRONG: const statusStrings = strings.filter(Status.isValid);\nconst statusStrings = strings.filter((input) => Status.isValid(input)); // Correct\n")),(0,s.mdx)("p",null,"Runtime cost: The same as described under ",(0,s.mdx)("inlineCode",{parentName:"p"},".cast")," above."),(0,s.mdx)("h4",{id:"toc-members"},".members"),(0,s.mdx)("p",null,"Type: ",(0,s.mdx)("inlineCode",{parentName:"p"},"members(): Iterator<TEnum>")),(0,s.mdx)("p",null,"The ",(0,s.mdx)("inlineCode",{parentName:"p"},"members")," method returns an ",(0,s.mdx)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#iterators"},"iterator")," (that is iterable) of all the enum members."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"const buttons = [];\nfunction getButtonForStatus(status: Status) { ...  }\n\nfor (const status of Status.members()) {\n  buttons.push(getButtonForStatus(status));\n}\n")),(0,s.mdx)("p",null,"The iteration order is guaranteed to be the same as the order of the members in the declaration."),(0,s.mdx)("p",null,"The enum is not enumerable or iterable itself (e.g. a for-in/for-of loop over the enum will not iterate over its members), you have to use the ",(0,s.mdx)("inlineCode",{parentName:"p"},".members()")," method for that purpose."),(0,s.mdx)("p",null,"You can convert the iterable into an ",(0,s.mdx)("inlineCode",{parentName:"p"},"Array")," using: ",(0,s.mdx)("inlineCode",{parentName:"p"},"Array.from(Status.members())"),".\nYou can make use of ",(0,s.mdx)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from"},(0,s.mdx)("inlineCode",{parentName:"a"},"Array.from")),"'s second argument to map over the values at\nthe same time you construct the array: e.g. "),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"const buttonArray = Array.from(\n  Status.members(),\n  status => getButtonForStatus(status),\n);\n")),(0,s.mdx)("h4",{id:"toc-getname"},".getName"),(0,s.mdx)("p",null,"Type: ",(0,s.mdx)("inlineCode",{parentName:"p"},"getName(value: TEnum): string")),(0,s.mdx)("p",null,"The ",(0,s.mdx)("inlineCode",{parentName:"p"},"getName")," method maps enum values to the string name of that value's enum member. When using ",(0,s.mdx)("inlineCode",{parentName:"p"},"number"),"/",(0,s.mdx)("inlineCode",{parentName:"p"},"boolean"),"/",(0,s.mdx)("inlineCode",{parentName:"p"},"symbol")," enums,\nthis can be useful for debugging and for generating internal CRUD UIs. For example:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},'enum Status {\n  Active = 1,\n  Paused = 2,\n  Off = 3,\n}\nconst status: Status = ...;\n\nconsole.log(Status.getName(status));\n// Will print a string, either "Active", "Paused", or "Off" depending on the value.\n')),(0,s.mdx)("p",null,"Runtime cost: The same as described under ",(0,s.mdx)("inlineCode",{parentName:"p"},".cast")," above. A single cached reverse map from enum value to enum name is used for ",(0,s.mdx)("inlineCode",{parentName:"p"},".cast"),", ",(0,s.mdx)("inlineCode",{parentName:"p"},".isValid"),", and ",(0,s.mdx)("inlineCode",{parentName:"p"},".getName"),".\nThe first call of any of those methods will create this cached map."),(0,s.mdx)("h3",{id:"toc-exhaustively-checking-enums-with-a-switch"},"Exhaustively checking enums with a ",(0,s.mdx)("inlineCode",{parentName:"h3"},"switch")),(0,s.mdx)("p",null,"When checking an enum value in a ",(0,s.mdx)("inlineCode",{parentName:"p"},"switch")," statement, we enforce that you check against all possible enum members, and don\u2019t include redundant cases.\nThis helps ensure you consider all possibilities when writing code that uses enums. It especially helps with refactoring when adding or removing members,\nby pointing out the different places you need to update."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"const status: Status = ...;\n\nswitch (status) { // Good, all members checked\n  case Status.Active:\n    break;\n  case Status.Paused:\n    break;\n  case Status.Off:\n    break;\n}\n")),(0,s.mdx)("p",null,"You can use ",(0,s.mdx)("inlineCode",{parentName:"p"},"default")," to match all members not checked so far:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"switch (status) {\n  case Status.Active:\n    break;\n  default: // When `Status.Paused` or `Status.Off`\n    break;\n}\n")),(0,s.mdx)("p",null,"You can check multiple enum members in one switch case:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"switch (status) {\n  case Status.Active:\n  case Status.Paused:\n    break;\n  case Status.Off:\n    break;\n}\n")),(0,s.mdx)("p",null,"You must match against all of the members of the enum (or supply a ",(0,s.mdx)("inlineCode",{parentName:"p"},"default")," case):"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":9,"startColumn":9,"endLine":9,"endColumn":14,"description":"Incomplete exhaustive check: the member `Off` of enum `Status` [1] has not been considered in check of `status`. [invalid-exhaustive-check]"}]','[{"startLine":9,"startColumn":9,"endLine":9,"endColumn":14,"description":"Incomplete':!0,exhaustive:!0,"check:":!0,the:!0,member:!0,"`Off`":!0,of:!0,enum:!0,"`Status`":!0,"[1]":!0,has:!0,not:!0,been:!0,considered:!0,in:!0,check:!0,"`status`.":!0,'[invalid-exhaustive-check]"}]':!0},"enum Status {\n  Active = 1,\n  Paused = 2,\n  Off = 3,\n}\nconst status: Status = Status.Active;\n\n// Error: you haven't checked 'Status.Off' in the switch\nswitch (status) {\n  case Status.Active:\n    break;\n  case Status.Paused:\n    break;\n}\n")),(0,s.mdx)("p",null,"You can\u2019t repeat cases (as this would be dead code!):"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":15,"startColumn":8,"endLine":15,"endColumn":20,"description":"Invalid exhaustive check: case checks for enum member `Paused` of `Status` [1], but member `Paused` was already checked at case [2]. [invalid-exhaustive-check]"}]','[{"startLine":15,"startColumn":8,"endLine":15,"endColumn":20,"description":"Invalid':!0,exhaustive:!0,"check:":!0,case:!0,checks:!0,for:!0,enum:!0,member:!0,"`Paused`":!0,of:!0,"`Status`":!0,"[1],":!0,but:!0,was:!0,already:!0,checked:!0,at:!0,"[2].":!0,'[invalid-exhaustive-check]"}]':!0},"enum Status {\n  Active = 1,\n  Paused = 2,\n  Off = 3,\n}\nconst status: Status = Status.Active;\n\nswitch (status) {\n  case Status.Active:\n    break;\n  case Status.Paused:\n    break;\n  case Status.Off:\n    break;\n  case Status.Paused: // Error: you already checked for 'Status.Paused'\n    break;\n}\n")),(0,s.mdx)("p",null,"A ",(0,s.mdx)("inlineCode",{parentName:"p"},"default")," case is redundant if you\u2019ve already matched all cases:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":15,"startColumn":3,"endLine":16,"endColumn":10,"description":"Invalid exhaustive check: default case checks for additional enum members of `Status` [1], but all of its members have already been checked. [invalid-exhaustive-check]"}]','[{"startLine":15,"startColumn":3,"endLine":16,"endColumn":10,"description":"Invalid':!0,exhaustive:!0,"check:":!0,default:!0,case:!0,checks:!0,for:!0,additional:!0,enum:!0,members:!0,of:!0,"`Status`":!0,"[1],":!0,but:!0,all:!0,its:!0,have:!0,already:!0,been:!0,"checked.":!0,'[invalid-exhaustive-check]"}]':!0},"enum Status {\n  Active = 1,\n  Paused = 2,\n  Off = 3,\n}\nconst status: Status = Status.Active;\n\nswitch (status) {\n  case Status.Active:\n    break;\n  case Status.Paused:\n    break;\n  case Status.Off:\n    break;\n  default: // Error: you've already checked all cases, the 'default' is redundant\n    break;\n}\n// The following is OK because the `default` covers the `Status.Off` case:\nswitch (status) {\n  case Status.Active:\n    break;\n  case Status.Paused:\n    break;\n  default:\n    break;\n}\n")),(0,s.mdx)("p",null,"Except if you are switching over an enum with ",(0,s.mdx)("a",{parentName:"p",href:"../defining-enums/#toc-flow-enums-with-unknown-members"},"unknown members"),"."),(0,s.mdx)("p",null,"If you nest exhaustively checked switches inside exhaustively checked switches, and are returning from each branch, you must add a ",(0,s.mdx)("inlineCode",{parentName:"p"},"break;")," after the nested switch:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"switch (status) {\n  case Status.Active:\n    return 1;\n  case Status.Paused:\n    return 2;\n  case Status.Off:\n    switch (otherStatus) {\n      case Status.Active:\n        return 1;\n      case Status.Paused:\n        return 2;\n      case Status.Off:\n        return 3;\n    }\n    break;\n}\n")),(0,s.mdx)("p",null,"Remember, you can add blocks to your switch cases. They are useful if you want to use local variables:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"switch (status) {\n  case Status.Active: {\n    const x = f();\n    ...\n    break;\n  }\n  case Status.Paused: {\n    const x = g();\n    ...\n    break;\n  }\n  case Status.Off: {\n    const y = ...;\n    ...\n    break;\n  }\n}\n")),(0,s.mdx)("p",null,"If you didn't add blocks in this example, the two declarations of ",(0,s.mdx)("inlineCode",{parentName:"p"},"const x")," would conflict and result in an error."),(0,s.mdx)("p",null,"Enums are not checked exhaustively in ",(0,s.mdx)("inlineCode",{parentName:"p"},"if")," statements or other contexts other than ",(0,s.mdx)("inlineCode",{parentName:"p"},"switch")," statements."),(0,s.mdx)("h3",{id:"toc-exhaustive-checking-with-unknown-members"},"Exhaustive checking with unknown members"),(0,s.mdx)("p",null,"If your enum has ",(0,s.mdx)("a",{parentName:"p",href:"../defining-enums/#toc-flow-enums-with-unknown-members"},"unknown members")," (specified with the ",(0,s.mdx)("inlineCode",{parentName:"p"},"..."),"), e.g."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"enum Status {\n  Active,\n  Paused,\n  Off,\n  ...\n}\n")),(0,s.mdx)("p",null,"Then a ",(0,s.mdx)("inlineCode",{parentName:"p"},"default")," is always required when switching over the enum. The ",(0,s.mdx)("inlineCode",{parentName:"p"},"default"),' checks for "unknown" members you haven\'t explicitly listed.'),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"switch (status) {\n  case Status.Active:\n    break;\n  case Status.Paused:\n    break;\n  case Status.Off:\n    break;\n  default:\n    // Checks for members not explicitly listed\n}\n")),(0,s.mdx)("p",null,"You can use the ",(0,s.mdx)("inlineCode",{parentName:"p"},"require-explicit-enum-switch-cases")," ",(0,s.mdx)("a",{parentName:"p",href:"../../linting/flowlint-comments/"},"Flow Lint")," to require that all known members are explicitly listed as cases. For example:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":9,"startColumn":9,"endLine":9,"endColumn":14,"description":"Incomplete exhaustive check: the member `Off` of enum `Status` [1] has not been considered in check of `status`. The default case [2] does not check for the missing members as the `require-explicit-enum-switch-cases` lint has been enabled. [require-explicit-enum-switch-cases]"}]','[{"startLine":9,"startColumn":9,"endLine":9,"endColumn":14,"description":"Incomplete':!0,exhaustive:!0,"check:":!0,the:!0,member:!0,"`Off`":!0,of:!0,enum:!0,"`Status`":!0,"[1]":!0,has:!0,not:!0,been:!0,considered:!0,in:!0,check:!0,"`status`.":!0,The:!0,default:!0,case:!0,"[2]":!0,does:!0,for:!0,missing:!0,members:!0,as:!0,"`require-explicit-enum-switch-cases`":!0,lint:!0,"enabled.":!0,'[require-explicit-enum-switch-cases]"}]':!0},"enum Status {\n  Active = 1,\n  Paused = 2,\n  Off = 3,\n}\nconst status: Status = Status.Active;\n\n// flowlint-next-line require-explicit-enum-switch-cases:error\nswitch (status) {\n  case Status.Active:\n    break;\n  case Status.Paused:\n    break;\n  default:\n    break;\n}\n")),(0,s.mdx)("p",null,"You can fix if by doing:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"// flowlint-next-line require-explicit-enum-switch-cases:error\nswitch (status) {\n  case Status.Active:\n    break;\n  case Status.Paused:\n    break;\n  case Status.Off: // Added the missing `Status.Off` case\n    break;\n  default:\n    break;\n}\n")),(0,s.mdx)("p",null,"The ",(0,s.mdx)("inlineCode",{parentName:"p"},"require-explicit-enum-switch-cases")," lint is not one to enable globally, but rather on a per-",(0,s.mdx)("inlineCode",{parentName:"p"},"switch")," basis when you want the behavior.\nWith normal enums, for each ",(0,s.mdx)("inlineCode",{parentName:"p"},"switch")," statement on it, you can either provide a ",(0,s.mdx)("inlineCode",{parentName:"p"},"default")," or not, and thus decide if you want to require each case explicitly listed or not.\nSimilarly for Flow Enums with unknown members, you can also enable this lint on a per-switch basis."),(0,s.mdx)("p",null,"The lint works for switches of regular Flow Enum types as well.\nIt in effect bans the usage of ",(0,s.mdx)("inlineCode",{parentName:"p"},"default")," in that ",(0,s.mdx)("inlineCode",{parentName:"p"},"switch")," statement, by requiring the explicit listing of all enum members as cases."),(0,s.mdx)("h3",{id:"toc-mapping-enums-to-other-values"},"Mapping enums to other values"),(0,s.mdx)("p",null,"There are a variety of reasons you may want to map an enum value to another value, e.g. a label, icon, element, and so on."),(0,s.mdx)("p",null,"With previous patterns, it was common to use object literals for this purpose, however with Flow Enums we prefer functions which contain a switch, which we can exhaustively check."),(0,s.mdx)("p",null,"Instead of:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"const STATUS_ICON: {[Status]: string} = {\n  [Status.Active]: 'green-checkmark',\n  [Status.Paused]: 'grey-pause',\n  [Status.Off]: 'red-x',\n};\nconst icon = STATUS_ICON[status];\n")),(0,s.mdx)("p",null,"Which doesn't actually guarantee that we are mapping each ",(0,s.mdx)("inlineCode",{parentName:"p"},"Status")," to some value, use:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"function getStatusIcon(status: Status): string {\n  switch (status) {\n    case Status.Active:\n      return 'green-checkmark';\n    case Status.Paused:\n      return 'grey-pause';\n    case Status.Off:\n      return 'red-x';\n  }\n}\nconst icon = getStatusIcon(status);\n")),(0,s.mdx)("p",null,"In the future if you add or remove an enum member, Flow will tell you to update the switch as well so it's always accurate."),(0,s.mdx)("p",null,"If you actually want a dictionary which is not exhaustive, you can use a ",(0,s.mdx)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"},(0,s.mdx)("inlineCode",{parentName:"a"},"Map")),":"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"const counts = new Map<Status, number>([\n  [Status.Active, 2],\n  [Status.Off, 5],\n]);\nconst activeCount: Status | void = counts.get(Status.Active);\n")),(0,s.mdx)("p",null,"Flow Enums cannot be used as keys in object literals, as ",(0,s.mdx)("a",{parentName:"p",href:"#toc-distinct-object-keys"},"explained later on this page"),"."),(0,s.mdx)("h3",{id:"toc-enums-in-a-union"},"Enums in a union"),(0,s.mdx)("p",null,"If your enum value is in a union (e.g. ",(0,s.mdx)("inlineCode",{parentName:"p"},"?Status"),"), first refine to only the enum type:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"const status: ?Status = ...;\n\nif (status != null) {\n  status as Status; // 'status' is refined to 'Status' at this point\n  switch (status) {\n    case Status.Active: break;\n    case Status.Paused: break;\n    case Status.Off: break;\n  }\n}\n")),(0,s.mdx)("p",null,"If you want to refine ",(0,s.mdx)("em",{parentName:"p"},"to")," the enum value, you can use ",(0,s.mdx)("inlineCode",{parentName:"p"},"typeof")," with the representation type, for example:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"const val: Status | number = ...;\n\n// 'Status' is a string enum\nif (typeof val === 'string') {\n  val as Status; // 'val' is refined to 'Status' at this point\n  switch (val) {\n    case Status.Active: break;\n    case Status.Paused: break;\n    case Status.Off: break;\n  }\n}\n")),(0,s.mdx)("h3",{id:"toc-exporting-enums"},"Exporting enums"),(0,s.mdx)("p",null,"An enum is a type and a value (like a class is). To export both the type and the value, export it like a you would a value:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"export enum Status {}\n")),(0,s.mdx)("p",null,"Or, as the default export (note: you must always specify an enum name, ",(0,s.mdx)("inlineCode",{parentName:"p"},"export default enum {}")," is not allowed):"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"export default enum Status {}\n")),(0,s.mdx)("p",null,"Using CommonJS:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"enum Status {}\nmodule.exports = Status;\n")),(0,s.mdx)("p",null,"To export ",(0,s.mdx)("strong",{parentName:"p"},"only")," its type, but not the value, you can do:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"enum Status {}\nexport type {Status};\n")),(0,s.mdx)("p",null,"Other functions within the file will still have access to the enum implementation."),(0,s.mdx)("h3",{id:"toc-importing-enums"},"Importing enums"),(0,s.mdx)("p",null,"If you have exported an enum like this:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"// status.js\nexport default enum Status {\n  Active,\n  Paused,\n  Off,\n}\n")),(0,s.mdx)("p",null,"You can import it as both a value and a type like this:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"import Status from 'status';\n\nconst x: Status /* used as type */ = Status.Active /* used as value */;\n")),(0,s.mdx)("p",null,"If you only need to use the type, you can import it as a type:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"import type Status from 'status';\n\nfunction printStatus(status: Status) {\n  ...\n}\n")),(0,s.mdx)("p",null,"Using CommonJS:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"const Status = require('status');\n")),(0,s.mdx)("h3",{id:"toc-abstract-enums"},"Abstract enums ",(0,s.mdx)(i.V,{version:"0.234",mdxType:"SinceVersion"})),(0,s.mdx)("p",null,"You can write code that operates on Flow Enums in a generic way using two types: ",(0,s.mdx)("inlineCode",{parentName:"p"},"Enum<>")," and ",(0,s.mdx)("inlineCode",{parentName:"p"},"EnumValue<>"),", which accept any Flow Enum and its values."),(0,s.mdx)("h4",{id:"enumvalue"},"EnumValue","<",">"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"EnumValue<>")," accepts any Flow Enum value. Want to narrow it down to enum values with a specific representation type? Just add a type argument:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":5,"startColumn":1,"endLine":5,"endColumn":13,"description":"Cannot cast `Status.Active` to `EnumValue` because string [1] is incompatible with number [2] in the enum\'s representation type. [incompatible-cast]"}]','[{"startLine":5,"startColumn":1,"endLine":5,"endColumn":13,"description":"Cannot':!0,cast:!0,"`Status.Active`":!0,to:!0,"`EnumValue`":!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,"[2]":!0,in:!0,the:!0,"enum's":!0,representation:!0,"type.":!0,'[incompatible-cast]"}]':!0},"enum Status {Active, Paused, Off}\n\nStatus.Active as EnumValue<>; // OK\nStatus.Active as EnumValue<string>; // OK - its a string enum\nStatus.Active as EnumValue<number>; // ERROR - not a number enum\n")),(0,s.mdx)("p",null,"The new ",(0,s.mdx)("inlineCode",{parentName:"p"},"EnumRepresentationTypes")," type represents all the valid representation types: ",(0,s.mdx)("inlineCode",{parentName:"p"},"string"),", ",(0,s.mdx)("inlineCode",{parentName:"p"},"number"),", etc."),(0,s.mdx)("p",null,"Flow Enum values don\u2019t implicitly coerce to their representation type, so we allow ",(0,s.mdx)("a",{parentName:"p",href:"#toc-casting-to-representation-type"},"explicit conversion"),"\nwith casts like ",(0,s.mdx)("inlineCode",{parentName:"p"},"Status.Active as string"),". With ",(0,s.mdx)("inlineCode",{parentName:"p"},"EnumValue<>")," you might not know the specific representation type,\nso we now allow casts using ",(0,s.mdx)("inlineCode",{parentName:"p"},".valueOf()")," directly on the enum value. For example:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function f(e: EnumValue<>) {\n  const x: EnumRepresentationTypes = e.valueOf(); // OK\n}\n")),(0,s.mdx)("h4",{id:"enum"},"Enum","<",">"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"Enum<>")," accepts any Flow Enum - the enum itself, rather than its value. You can optionally supply a type argument to\nrestrict it to enums with a certain enum value, which you can pair with the ",(0,s.mdx)("inlineCode",{parentName:"p"},"EnumValue")," type above:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"enum Status {Active, Paused, Off}\n\nStatus as Enum<>; // OK\nStatus as Enum<Status>; // OK\nStatus as Enum<EnumValue<string>>; // OK\n")),(0,s.mdx)("p",null,"With the ",(0,s.mdx)("inlineCode",{parentName:"p"},"Enum<>")," type you can use all the Flow Enum ",(0,s.mdx)("a",{parentName:"p",href:"#toc-methods"},"methods")," like ",(0,s.mdx)("inlineCode",{parentName:"p"},".cast")," and ",(0,s.mdx)("inlineCode",{parentName:"p"},".members"),".\nThis lets you craft code that generically handles Flow Enums, for example creating a full React selector component from only a Flow Enum:"),(0,s.mdx)("h5",{id:"usage"},"Usage"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},"enum Status {\n  Active,\n  Paused,\n  Off,\n}\n<Selector items={Status} callback={doStuff} />\n")),(0,s.mdx)("h5",{id:"definition"},"Definition"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"import * as React from 'react';\nimport {useCallback, useMemo, useState} from 'react';\n\ncomponent Selector<\n  TEnumValue: EnumValue<string>,\n>(\n  items: Enum<TEnumValue>,\n  callback: (TEnumValue) => void,\n) {\n  // Typing the `useState` selector with the enum value generic\n  const [value, setValue] = useState<?TEnumValue>(null);\n\n  const handleChange = useCallback((e: SyntheticInputEvent<>) => {\n    // Using the `.cast` method\n    const value = items.cast(e.target.value);\n    if (value == null) { throw new Error(\"Invalid value\"); }\n    setValue(value);\n    callback(value);\n  }, [items, callback]);\n\n  return <ul>\n    {Array.from(items.members(), item => // Using the `.members()` method\n      <li>\n        <label>\n          {// Using the `.getName` method:\n            items.getName(item)\n          }:\n          <input\n            type=\"radio\"\n            // Casting to the representation type using `.valueOf()`\n            value={item.valueOf()}\n            checked={item === value}\n            onChange={handleChange} />\n         </label>\n      </li>\n    )}\n  </ul>;\n}\n")),(0,s.mdx)("h3",{id:"toc-when-to-not-use-enums"},"When to not use enums"),(0,s.mdx)("p",null,"Enums are designed to cover many use cases and exhibit certain benefits. The design makes a variety of trade-offs to make this happen, and in certain situations,\nthese trade-offs might not be right for you. In these cases, you can continue to use existing patterns to satisfy your use cases."),(0,s.mdx)("h4",{id:"toc-distinct-object-keys"},"Distinct object keys"),(0,s.mdx)("p",null,"You can\u2019t use enum members as distinct object keys."),(0,s.mdx)("p",null,"The following pattern works because the types of ",(0,s.mdx)("inlineCode",{parentName:"p"},"LegacyStatus.Active")," and ",(0,s.mdx)("inlineCode",{parentName:"p"},"LegacyStatus.Off")," are different. One has the type ",(0,s.mdx)("inlineCode",{parentName:"p"},"'Active'")," and one has the type ",(0,s.mdx)("inlineCode",{parentName:"p"},"'Off'"),"."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":12,"startColumn":20,"endLine":12,"endColumn":41,"description":"Cannot assign `o[LegacyStatus.Active]` to `z` because string [1] is incompatible with boolean [2]. [incompatible-type]"}]','[{"startLine":12,"startColumn":20,"endLine":12,"endColumn":41,"description":"Cannot':!0,assign:!0,"`o[LegacyStatus.Active]`":!0,to:!0,"`z`":!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,boolean:!0,"[2].":!0,'[incompatible-type]"}]':!0},"const LegacyStatus = Object.freeze({\n  Active: 'Active',\n  Paused: 'Paused',\n  Off: 'Off',\n});\nconst o = {\n  [LegacyStatus.Active]: \"hi\",\n  [LegacyStatus.Off]: 1,\n};\nconst x: string = o[LegacyStatus.Active]; // OK\nconst y: number = o[LegacyStatus.Off]; // OK\nconst z: boolean = o[LegacyStatus.Active]; // Error - as expected\n")),(0,s.mdx)("p",null,"We can\u2019t use the same pattern with enums. All enum members have the same type, the enum type, so Flow can\u2019t track the relationship between keys and values."),(0,s.mdx)("p",null,"If you wish to map from an enum value to another value, you should use a ",(0,s.mdx)("a",{parentName:"p",href:"#toc-mapping-enums-to-other-values"},"function with an exhaustively-checked switch instead"),"."),(0,s.mdx)("h4",{id:"toc-disjoint-object-unions"},"Disjoint object unions"),(0,s.mdx)("p",null,"A defining feature of enums is that unlike unions, each enum member does not form its own separate type. Every member has the same type, the enum type.\nThis allows enum usage to be analyzed by Flow in a consistently fast way, however it means that in certain situations which require separate types, we can\u2019t use enums.\nConsider the following union, following the ",(0,s.mdx)("a",{parentName:"p",href:"../../types/unions/#toc-disjoint-object-unions"},"disjoint object union")," pattern:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Action =\n  | {type: 'Upload', data: string}\n  | {type: 'Delete', id: number};\n")),(0,s.mdx)("p",null,"Each object type in the union has a single common field (",(0,s.mdx)("inlineCode",{parentName:"p"},"type"),") which is used to distinguish which object type we are dealing with."),(0,s.mdx)("p",null,"We can\u2019t use enum types for this field, because for this mechanism to work, the type of that field must be different in each member of the union,\nbut enum members all have the same type."),(0,s.mdx)("p",null,"In the future, we might add the ability for enums to encapsulate additional data besides a key and a primitive value - this would allow us to replace disjoint object unions."),(0,s.mdx)("h4",{id:"toc-guaranteed-inlining"},"Guaranteed inlining"),(0,s.mdx)("p",null,"Flow Enums are designed to allow for inlining (e.g. ",(0,s.mdx)("a",{parentName:"p",href:"../defining-enums/#toc-literal-member-values"},"member values must be literals"),",\n",(0,s.mdx)("a",{parentName:"p",href:"../defining-enums/#toc-fixed-at-declaration"},"enums are frozen"),"), however the inlining itself needs to be part of the build system (whatever you use) rather than Flow itself."),(0,s.mdx)("p",null,"While enum member access (e.g. ",(0,s.mdx)("inlineCode",{parentName:"p"},"Status.Active"),") can be inlined (other than ",(0,s.mdx)("a",{parentName:"p",href:"../defining-enums/#toc-symbol-enums"},"symbol enums")," which cannot be inlined due to the nature of symbols),\nusage of its methods (e.g. ",(0,s.mdx)("inlineCode",{parentName:"p"},"Status.cast(x)"),") cannot be inlined."))}c.isMDXComponent=!0}}]);