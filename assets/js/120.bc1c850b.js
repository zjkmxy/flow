"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[120],{50120:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>m,contentTitle:()=>o,default:()=>s,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var t=a(58168),l=(a(96540),a(15680));a(60681);const i={title:"Primitive Types",slug:"/types/primitives"},o=void 0,r={unversionedId:"types/primitives",id:"types/primitives",title:"Primitive Types",description:"JavaScript has a number of different primitive types",source:"@site/docs/types/primitives.md",sourceDirName:"types",slug:"/types/primitives",permalink:"/en/docs/types/primitives",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/types/primitives.md",tags:[],version:"current",frontMatter:{title:"Primitive Types",slug:"/types/primitives"},sidebar:"docsSidebar",previous:{title:"Type Annotations",permalink:"/en/docs/types"},next:{title:"Literal Types",permalink:"/en/docs/types/literals"}},m={},d=[{value:"Booleans",id:"toc-booleans",level:2},{value:"Numbers",id:"toc-numbers",level:2},{value:"Strings",id:"toc-strings",level:2},{value:"<code>null</code> and <code>undefined</code>",id:"toc-null-and-void",level:2},{value:"Maybe types",id:"toc-maybe-types",level:3},{value:"Optional object properties",id:"toc-optional-object-properties",level:3},{value:"Optional function parameters",id:"toc-optional-function-parameters",level:3},{value:"Function parameters with defaults",id:"toc-function-parameters-with-defaults",level:3},{value:"Symbols",id:"toc-symbols",level:2},{value:"BigInts",id:"toc-bigints",level:2}],p={toc:d};function s(e){let{components:n,...a}=e;return(0,l.mdx)("wrapper",(0,t.A)({},p,a,{components:n,mdxType:"MDXLayout"}),(0,l.mdx)("p",null,"JavaScript has a number of different primitive types\n(",(0,l.mdx)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#primitive_values"},"MDN"),"):"),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null}),(0,l.mdx)("th",{parentName:"tr",align:null},"Example"),(0,l.mdx)("th",{parentName:"tr",align:null},"Flow type"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("strong",{parentName:"td"},"Booleans")),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"true")," or ",(0,l.mdx)("inlineCode",{parentName:"td"},"false")),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"boolean"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("strong",{parentName:"td"},"Strings")),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"'foo'")),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"string"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("strong",{parentName:"td"},"Numbers")),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"123")),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"number"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("strong",{parentName:"td"},"Null")),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"null")),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"null"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("strong",{parentName:"td"},"Undefined")),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"undefined")),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"void"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("strong",{parentName:"td"},"Symbols")," ",(0,l.mdx)("small",null,(0,l.mdx)("em",{parentName:"td"},"(new in ES2015)"))),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"Symbol('foo')")),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"symbol"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("strong",{parentName:"td"},"BigInts")," ",(0,l.mdx)("small",null,(0,l.mdx)("em",{parentName:"td"},"(new in ES2020)"))),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"123n")),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"bigint"))))),(0,l.mdx)("p",null,"Some primitive types appear in the language as literal values:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'true;\n"hello";\n3.14;\nnull;\nundefined;\n3n;\n')),(0,l.mdx)("p",null,"BigInts and Symbols can be created with calls to ",(0,l.mdx)("inlineCode",{parentName:"p"},"BigInt")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"Symbol"),", respectively:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'BigInt("2364023476023");\nSymbol("hello");\n')),(0,l.mdx)("p",null,"The Flow types of literal values are lowercase (mirroring the output of JavaScript's\n",(0,l.mdx)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof"},(0,l.mdx)("inlineCode",{parentName:"a"},"typeof")," expression"),"):"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'function func(a: number, b: string, c: boolean, d: bigint) { /* ... */ }\n\nfunc(3.14, "hello", true, 3n);\n')),(0,l.mdx)("p",null,"Some literals can also be used as ",(0,l.mdx)("a",{parentName:"p",href:"../literals"},"literal types"),":"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":4,"startColumn":11,"endLine":4,"endColumn":11,"description":"Cannot call `acceptTwo` with `1` bound to `x` because number [1] is incompatible with number literal `2` [2]. [incompatible-call]"}]','[{"startLine":4,"startColumn":11,"endLine":4,"endColumn":11,"description":"Cannot':!0,call:!0,"`acceptTwo`":!0,with:!0,"`1`":!0,bound:!0,to:!0,"`x`":!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,literal:!0,"`2`":!0,"[2].":!0,'[incompatible-call]"}]':!0},"function acceptTwo(x: 2) { /* ... */ }\n\nacceptTwo(2); // Works!\nacceptTwo(1); // Error!\n")),(0,l.mdx)("p",null,"Some primitives can also be wrapped as objects:"),(0,l.mdx)("blockquote",null,(0,l.mdx)("p",{parentName:"blockquote"},"NOTE: You probably never want to use the wrapper object variants.")),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'new Boolean(false);\nnew String("world");\nnew Number(42);\n')),(0,l.mdx)("p",null,"Types for the wrapper objects are capitalized (the same as their constructor):"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'function func(x: Number, y: String, z: Boolean) {\n  // ...\n}\n\nfunc(new Number(42), new String("world"), new Boolean(false));\n')),(0,l.mdx)("p",null,"These wrapper objects are rarely used."),(0,l.mdx)("h2",{id:"toc-booleans"},"Booleans"),(0,l.mdx)("p",null,"Booleans are ",(0,l.mdx)("inlineCode",{parentName:"p"},"true")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"false")," values in JavaScript. The ",(0,l.mdx)("inlineCode",{parentName:"p"},"boolean")," type in\nFlow accepts these values."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":16,"endLine":6,"endColumn":20,"description":"Cannot call `acceptsBoolean` with `\\"foo\\"` bound to `value` because string [1] is incompatible with boolean [2]. [incompatible-call]"}]','[{"startLine":6,"startColumn":16,"endLine":6,"endColumn":20,"description":"Cannot':!0,call:!0,"`acceptsBoolean`":!0,with:!0,'`\\"foo\\"`':!0,bound:!0,to:!0,"`value`":!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,boolean:!0,"[2].":!0,'[incompatible-call]"}]':!0},'function acceptsBoolean(value: boolean) { /* ... */ }\n\nacceptsBoolean(true);  // Works!\nacceptsBoolean(false); // Works!\n\nacceptsBoolean("foo"); // Error!\n')),(0,l.mdx)("p",null,"JavaScript can also implicitly convert other types of values into booleans."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-js"},'if (42) {} // 42 => true\nif ("") {} // "" => false\n')),(0,l.mdx)("p",null,"Flow understands these coercions and will allow them as part of an\n",(0,l.mdx)("inlineCode",{parentName:"p"},"if")," statement's test or other conditional contexts."),(0,l.mdx)("p",null,"To explicitly convert non-booleans to a ",(0,l.mdx)("inlineCode",{parentName:"p"},"boolean"),", you can use ",(0,l.mdx)("inlineCode",{parentName:"p"},"Boolean(x)")," or ",(0,l.mdx)("inlineCode",{parentName:"p"},"!!x"),"."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":16,"endLine":3,"endColumn":16,"description":"Cannot call `acceptsBoolean` with `0` bound to `value` because number [1] is incompatible with boolean [2]. [incompatible-call]"}]','[{"startLine":3,"startColumn":16,"endLine":3,"endColumn":16,"description":"Cannot':!0,call:!0,"`acceptsBoolean`":!0,with:!0,"`0`":!0,bound:!0,to:!0,"`value`":!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,boolean:!0,"[2].":!0,'[incompatible-call]"}]':!0},"function acceptsBoolean(value: boolean) { /* ... */ }\n\nacceptsBoolean(0);          // Error!\n\nacceptsBoolean(Boolean(0)); // Works!\nacceptsBoolean(!!0);        // Works!\n")),(0,l.mdx)("p",null,"You can ",(0,l.mdx)("a",{parentName:"p",href:"../../lang/refinements/"},"refine")," a value to ",(0,l.mdx)("inlineCode",{parentName:"p"},"boolean")," using a ",(0,l.mdx)("inlineCode",{parentName:"p"},"typeof")," check:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function acceptsBoolean(value: boolean) { /* ... */ }\n\nfunction func(value: mixed) {\n  if (typeof value === 'boolean') {\n    acceptsBoolean(value); // Works: `value` is `boolean`\n  }\n}\n")),(0,l.mdx)("p",null,"Remember that ",(0,l.mdx)("inlineCode",{parentName:"p"},"boolean")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"Boolean")," are different types."),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"A ",(0,l.mdx)("inlineCode",{parentName:"li"},"boolean")," is a literal value like ",(0,l.mdx)("inlineCode",{parentName:"li"},"true")," or ",(0,l.mdx)("inlineCode",{parentName:"li"},"false")," or the result of an\nexpression like ",(0,l.mdx)("inlineCode",{parentName:"li"},"a === b"),"."),(0,l.mdx)("li",{parentName:"ul"},"A ",(0,l.mdx)("inlineCode",{parentName:"li"},"Boolean")," is a wrapper object created by the global ",(0,l.mdx)("inlineCode",{parentName:"li"},"new Boolean(x)"),"\nconstructor. You probably don't want to use this!")),(0,l.mdx)("h2",{id:"toc-numbers"},"Numbers"),(0,l.mdx)("p",null,"Number literals in JavaScript are floating point numbers, for example ",(0,l.mdx)("inlineCode",{parentName:"p"},"42")," or ",(0,l.mdx)("inlineCode",{parentName:"p"},"3.14"),".\nJavaScript also considers ",(0,l.mdx)("inlineCode",{parentName:"p"},"Infinity")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"NaN")," to be numbers.\nThese are represented by the ",(0,l.mdx)("inlineCode",{parentName:"p"},"number")," type. JavaScript also has a separate ",(0,l.mdx)("a",{parentName:"p",href:"#toc-bigints"},"BigInt type"),"."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":8,"startColumn":15,"endLine":8,"endColumn":19,"description":"Cannot call `acceptsNumber` with `\\"foo\\"` bound to `value` because string [1] is incompatible with number [2]. [incompatible-call]"},{"startLine":9,"startColumn":15,"endLine":9,"endColumn":18,"description":"Cannot call `acceptsNumber` with `123n` bound to `value` because bigint [1] is incompatible with number [2]. [incompatible-call]"}]','[{"startLine":8,"startColumn":15,"endLine":8,"endColumn":19,"description":"Cannot':!0,call:!0,"`acceptsNumber`":!0,with:!0,'`\\"foo\\"`':!0,bound:!0,to:!0,"`value`":!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,number:!0,"[2].":!0,'[incompatible-call]"},{"startLine":9,"startColumn":15,"endLine":9,"endColumn":18,"description":"Cannot':!0,"`123n`":!0,bigint:!0,'[incompatible-call]"}]':!0},'function acceptsNumber(value: number) { /* ... */ }\n\nacceptsNumber(42);       // Works!\nacceptsNumber(3.14);     // Works!\nacceptsNumber(NaN);      // Works!\nacceptsNumber(Infinity); // Works!\n\nacceptsNumber("foo");    // Error!\nacceptsNumber(123n);     // Error!\n')),(0,l.mdx)("p",null,"You can ",(0,l.mdx)("a",{parentName:"p",href:"../../lang/refinements/"},"refine")," a value to ",(0,l.mdx)("inlineCode",{parentName:"p"},"number")," using a ",(0,l.mdx)("inlineCode",{parentName:"p"},"typeof")," check:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function acceptsNumber(value: number) { /* ... */ }\n\nfunction func(value: mixed) {\n  if (typeof value === 'number') {\n    acceptsNumber(value); // Works: `value` is `number`\n  }\n}\n")),(0,l.mdx)("p",null,"Remember that ",(0,l.mdx)("inlineCode",{parentName:"p"},"number")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"Number")," are different types."),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"A ",(0,l.mdx)("inlineCode",{parentName:"li"},"number")," is a literal value like ",(0,l.mdx)("inlineCode",{parentName:"li"},"42")," or ",(0,l.mdx)("inlineCode",{parentName:"li"},"3.14")," or the result of an\nexpression like ",(0,l.mdx)("inlineCode",{parentName:"li"},"parseFloat(x)"),"."),(0,l.mdx)("li",{parentName:"ul"},"A ",(0,l.mdx)("inlineCode",{parentName:"li"},"Number")," is a wrapper object created by the global ",(0,l.mdx)("inlineCode",{parentName:"li"},"new Number(x)")," constructor. You probably don't want to use this!")),(0,l.mdx)("h2",{id:"toc-strings"},"Strings"),(0,l.mdx)("p",null,"Strings are ",(0,l.mdx)("inlineCode",{parentName:"p"},'"foo"')," values in JavaScript. The ",(0,l.mdx)("inlineCode",{parentName:"p"},"string")," type in Flow accepts these values."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":15,"endLine":6,"endColumn":19,"description":"Cannot call `acceptsString` with `false` bound to `value` because boolean [1] is incompatible with string [2]. [incompatible-call]"}]','[{"startLine":6,"startColumn":15,"endLine":6,"endColumn":19,"description":"Cannot':!0,call:!0,"`acceptsString`":!0,with:!0,"`false`":!0,bound:!0,to:!0,"`value`":!0,because:!0,boolean:!0,"[1]":!0,is:!0,incompatible:!0,string:!0,"[2].":!0,'[incompatible-call]"}]':!0},'function acceptsString(value: string) { /* ... */ }\n\nacceptsString("foo"); // Works!\nacceptsString(`template literal`); // Works!\n\nacceptsString(false); // Error!\n')),(0,l.mdx)("p",null,"JavaScript implicitly converts other types of values into strings by\nconcatenating them."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-js"},'"foo" + 42; // "foo42"\n"foo" + {}; // "foo[object Object]"\n')),(0,l.mdx)("p",null,"Flow will only accept strings and numbers when concatenating them to strings."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":5,"startColumn":1,"endLine":5,"endColumn":10,"description":"Cannot use operator `+` with operands string [1] and object literal [2] [unsafe-addition]"},{"startLine":6,"startColumn":1,"endLine":6,"endColumn":10,"description":"Cannot use operator `+` with operands string [1] and empty array literal [2] [unsafe-addition]"},{"startLine":7,"startColumn":8,"endLine":7,"endColumn":9,"description":"Cannot coerce array literal to string because empty array literal [1] should not be coerced. [incompatible-type]"}]','[{"startLine":5,"startColumn":1,"endLine":5,"endColumn":10,"description":"Cannot':!0,use:!0,operator:!0,"`+`":!0,with:!0,operands:!0,string:!0,"[1]":!0,and:!0,object:!0,literal:!0,"[2]":!0,'[unsafe-addition]"},{"startLine":6,"startColumn":1,"endLine":6,"endColumn":10,"description":"Cannot':!0,empty:!0,array:!0,'[unsafe-addition]"},{"startLine":7,"startColumn":8,"endLine":7,"endColumn":9,"description":"Cannot':!0,coerce:!0,to:!0,because:!0,should:!0,not:!0,be:!0,"coerced.":!0,'[incompatible-type]"}]':!0},'"foo" + "foo"; // Works!\n"foo" + 42;    // Works!\n`foo ${42}`;   // Works!\n\n"foo" + {};    // Error!\n"foo" + [];    // Error!\n`foo ${[]}`;   // Error!\n')),(0,l.mdx)("p",null,"You must be explicit and convert other types into strings. You can do this by\nusing the String function or using another method for stringifying values."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'"foo" + String({});     // Works!\n"foo" + [].toString();  // Works!\n"" + JSON.stringify({}) // Works!\n')),(0,l.mdx)("p",null,"You can ",(0,l.mdx)("a",{parentName:"p",href:"../../lang/refinements/"},"refine")," a value to ",(0,l.mdx)("inlineCode",{parentName:"p"},"string")," using a ",(0,l.mdx)("inlineCode",{parentName:"p"},"typeof")," check:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function acceptsString(value: string) { /* ... */ }\n\nfunction func(value: mixed) {\n  if (typeof value === 'string') {\n    acceptsString(value); // Works: `value` is `string`\n  }\n}\n")),(0,l.mdx)("p",null,"Remember that ",(0,l.mdx)("inlineCode",{parentName:"p"},"string")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"String")," are different types."),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"A ",(0,l.mdx)("inlineCode",{parentName:"li"},"string")," is a literal value like ",(0,l.mdx)("inlineCode",{parentName:"li"},'"foo"')," or the result of an expression\nlike ",(0,l.mdx)("inlineCode",{parentName:"li"},'"" + 42'),"."),(0,l.mdx)("li",{parentName:"ul"},"A ",(0,l.mdx)("inlineCode",{parentName:"li"},"String")," is a wrapper object created by the global ",(0,l.mdx)("inlineCode",{parentName:"li"},"new String(x)")," constructor. You probably don't want to use this!")),(0,l.mdx)("h2",{id:"toc-null-and-void"},(0,l.mdx)("inlineCode",{parentName:"h2"},"null")," and ",(0,l.mdx)("inlineCode",{parentName:"h2"},"undefined")),(0,l.mdx)("p",null,"JavaScript has both ",(0,l.mdx)("inlineCode",{parentName:"p"},"null")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"undefined"),". Flow treats these as separate\ntypes: ",(0,l.mdx)("inlineCode",{parentName:"p"},"null")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"void")," (for ",(0,l.mdx)("inlineCode",{parentName:"p"},"undefined"),")."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":4,"startColumn":13,"endLine":4,"endColumn":21,"description":"Cannot call `acceptsNull` with `undefined` bound to `value` because undefined [1] is incompatible with null [2]. [incompatible-call]"},{"startLine":9,"startColumn":18,"endLine":9,"endColumn":21,"description":"Cannot call `acceptsUndefined` with `null` bound to `value` because null [1] is incompatible with undefined [2]. [incompatible-call]"}]','[{"startLine":4,"startColumn":13,"endLine":4,"endColumn":21,"description":"Cannot':!0,call:!0,"`acceptsNull`":!0,with:!0,"`undefined`":!0,bound:!0,to:!0,"`value`":!0,because:!0,undefined:!0,"[1]":!0,is:!0,incompatible:!0,null:!0,"[2].":!0,'[incompatible-call]"},{"startLine":9,"startColumn":18,"endLine":9,"endColumn":21,"description":"Cannot':!0,"`acceptsUndefined`":!0,"`null`":!0,'[incompatible-call]"}]':!0},"function acceptsNull(value: null) { /* ... */ }\n\nacceptsNull(null);      // Works!\nacceptsNull(undefined); // Error!\n\nfunction acceptsUndefined(value: void) { /* ... */ }\n\nacceptsUndefined(undefined); // Works!\nacceptsUndefined(null);      // Error!\n")),(0,l.mdx)("p",null,"You can ",(0,l.mdx)("a",{parentName:"p",href:"../../lang/refinements/"},"refine")," a value to ",(0,l.mdx)("inlineCode",{parentName:"p"},"null")," or ",(0,l.mdx)("inlineCode",{parentName:"p"},"void")," using equality checks:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function acceptsNull(value: null) { /* ... */ }\n\nfunction func(value: mixed) {\n  if (value === null) {\n    acceptsNull(value); // Works: `value` is `null`\n  }\n}\n")),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function acceptsUndefined(value: void) { /* ... */ }\n\nfunction func(value: mixed) {\n  if (value === undefined) {\n    acceptsUndefined(value); // Works: `value` is `void`\n  }\n}\n")),(0,l.mdx)("p",null,(0,l.mdx)("inlineCode",{parentName:"p"},"null")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"void")," also appear in other types:"),(0,l.mdx)("h3",{id:"toc-maybe-types"},"Maybe types"),(0,l.mdx)("p",null,(0,l.mdx)("a",{parentName:"p",href:"../maybe"},"Maybe types")," are for places where a value is optional and you can create them by\nadding a question mark in front of the type such as ",(0,l.mdx)("inlineCode",{parentName:"p"},"?string")," or ",(0,l.mdx)("inlineCode",{parentName:"p"},"?number"),"."),(0,l.mdx)("p",null,(0,l.mdx)("inlineCode",{parentName:"p"},"?T")," is equivalent to ",(0,l.mdx)("inlineCode",{parentName:"p"},"T | null | void"),"."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'function acceptsMaybeString(value: ?string) { /* ... */ }\n\nacceptsMaybeString("bar");     // Works!\nacceptsMaybeString(undefined); // Works!\nacceptsMaybeString(null);      // Works!\nacceptsMaybeString();          // Works!\n')),(0,l.mdx)("p",null,"To refine, ",(0,l.mdx)("inlineCode",{parentName:"p"},"value == null")," checks exactly for both ",(0,l.mdx)("inlineCode",{parentName:"p"},"null")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"undefined"),"."),(0,l.mdx)("p",null,"Read the ",(0,l.mdx)("a",{parentName:"p",href:"../maybe"},"maybe type docs")," for more details."),(0,l.mdx)("h3",{id:"toc-optional-object-properties"},"Optional object properties"),(0,l.mdx)("p",null,"Object types can have optional properties where a question mark ",(0,l.mdx)("inlineCode",{parentName:"p"},"?")," comes after\nthe property name."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-js"},"{propertyName?: string}\n")),(0,l.mdx)("p",null,"In addition to their set value type, these optional properties can either be\n",(0,l.mdx)("inlineCode",{parentName:"p"},"void")," or omitted altogether. However, they cannot be ",(0,l.mdx)("inlineCode",{parentName:"p"},"null"),"."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":7,"startColumn":21,"endLine":7,"endColumn":24,"description":"Cannot call `acceptsObject` with object literal bound to `value` because null [1] is incompatible with string [2] in property `foo`. [incompatible-call]"}]','[{"startLine":7,"startColumn":21,"endLine":7,"endColumn":24,"description":"Cannot':!0,call:!0,"`acceptsObject`":!0,with:!0,object:!0,literal:!0,bound:!0,to:!0,"`value`":!0,because:!0,null:!0,"[1]":!0,is:!0,incompatible:!0,string:!0,"[2]":!0,in:!0,property:!0,"`foo`.":!0,'[incompatible-call]"}]':!0},'function acceptsObject(value: {foo?: string}) { /* ... */ }\n\nacceptsObject({foo: "bar"});     // Works!\nacceptsObject({foo: undefined}); // Works!\nacceptsObject({});               // Works!\n\nacceptsObject({foo: null});      // Error!\n')),(0,l.mdx)("h3",{id:"toc-optional-function-parameters"},"Optional function parameters"),(0,l.mdx)("p",null,"Functions can have optional parameters where a question mark ",(0,l.mdx)("inlineCode",{parentName:"p"},"?")," comes after\nthe parameter name."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-js"},"function func(param?: string) { /* ... */ }\n")),(0,l.mdx)("p",null,"In addition to their set type, these optional parameters can either be ",(0,l.mdx)("inlineCode",{parentName:"p"},"void"),"\nor omitted altogether. However, they cannot be ",(0,l.mdx)("inlineCode",{parentName:"p"},"null"),"."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":7,"startColumn":23,"endLine":7,"endColumn":26,"description":"Cannot call `acceptsOptionalString` with `null` bound to `value` because null [1] is incompatible with string [2]. [incompatible-call]"}]','[{"startLine":7,"startColumn":23,"endLine":7,"endColumn":26,"description":"Cannot':!0,call:!0,"`acceptsOptionalString`":!0,with:!0,"`null`":!0,bound:!0,to:!0,"`value`":!0,because:!0,null:!0,"[1]":!0,is:!0,incompatible:!0,string:!0,"[2].":!0,'[incompatible-call]"}]':!0},'function acceptsOptionalString(value?: string) { /* ... */ }\n\nacceptsOptionalString("bar");     // Works!\nacceptsOptionalString(undefined); // Works!\nacceptsOptionalString();          // Works!\n\nacceptsOptionalString(null);      // Error!\n')),(0,l.mdx)("h3",{id:"toc-function-parameters-with-defaults"},"Function parameters with defaults"),(0,l.mdx)("p",null,"Function parameters can also have defaults. This is a feature of ES2015."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-js"},'function func(value: string = "default") { /* ... */ }\n')),(0,l.mdx)("p",null,"In addition to their set type, default parameters can also be ",(0,l.mdx)("inlineCode",{parentName:"p"},"void")," or omitted\naltogether. However, they cannot be ",(0,l.mdx)("inlineCode",{parentName:"p"},"null"),"."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":7,"startColumn":23,"endLine":7,"endColumn":26,"description":"Cannot call `acceptsOptionalString` with `null` bound to `value` because null [1] is incompatible with string [2]. [incompatible-call]"}]','[{"startLine":7,"startColumn":23,"endLine":7,"endColumn":26,"description":"Cannot':!0,call:!0,"`acceptsOptionalString`":!0,with:!0,"`null`":!0,bound:!0,to:!0,"`value`":!0,because:!0,null:!0,"[1]":!0,is:!0,incompatible:!0,string:!0,"[2].":!0,'[incompatible-call]"}]':!0},'function acceptsOptionalString(value: string = "foo") { /* ... */ }\n\nacceptsOptionalString("bar");     // Works!\nacceptsOptionalString(undefined); // Works!\nacceptsOptionalString();          // Works!\n\nacceptsOptionalString(null);      // Error!\n')),(0,l.mdx)("h2",{id:"toc-symbols"},"Symbols"),(0,l.mdx)("p",null,"Symbols are created with ",(0,l.mdx)("inlineCode",{parentName:"p"},"Symbol()")," in JavaScript. Flow has basic support for symbols, using the ",(0,l.mdx)("inlineCode",{parentName:"p"},"symbol")," type."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":15,"endLine":6,"endColumn":19,"description":"Cannot call `acceptsSymbol` with `false` bound to `value` because boolean [1] is incompatible with symbol [2]. [incompatible-call]"}]','[{"startLine":6,"startColumn":15,"endLine":6,"endColumn":19,"description":"Cannot':!0,call:!0,"`acceptsSymbol`":!0,with:!0,"`false`":!0,bound:!0,to:!0,"`value`":!0,because:!0,boolean:!0,"[1]":!0,is:!0,incompatible:!0,symbol:!0,"[2].":!0,'[incompatible-call]"}]':!0},"function acceptsSymbol(value: symbol) { /* ... */ }\n\nacceptsSymbol(Symbol()); // Works!\nacceptsSymbol(Symbol.isConcatSpreadable); // Works!\n\nacceptsSymbol(false); // Error!\n")),(0,l.mdx)("p",null,"You can ",(0,l.mdx)("a",{parentName:"p",href:"../../lang/refinements/"},"refine")," a value to ",(0,l.mdx)("inlineCode",{parentName:"p"},"symbol")," using a ",(0,l.mdx)("inlineCode",{parentName:"p"},"typeof")," check:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function acceptsSymbol(value: symbol) { /* ... */ }\n\nfunction func(value: mixed) {\n  if (typeof value === 'symbol') {\n    acceptsSymbol(value); // Works: `value` is `symbol`\n  }\n}\n")),(0,l.mdx)("h2",{id:"toc-bigints"},"BigInts"),(0,l.mdx)("p",null,"BigInts can be used to represent integers of arbitrary precision. In other words, they can store integers which are too large to store as a ",(0,l.mdx)("inlineCode",{parentName:"p"},"number"),"."),(0,l.mdx)("p",null,"A ",(0,l.mdx)("inlineCode",{parentName:"p"},"bigint")," literal is just a ",(0,l.mdx)("inlineCode",{parentName:"p"},"number")," literal along with an ",(0,l.mdx)("inlineCode",{parentName:"p"},"n")," suffix."),(0,l.mdx)("p",null,"Note that ",(0,l.mdx)("inlineCode",{parentName:"p"},"bigint")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"number")," are incompatible types. That is, a ",(0,l.mdx)("inlineCode",{parentName:"p"},"bigint")," cannot be used where a ",(0,l.mdx)("inlineCode",{parentName:"p"},"number")," is expected, and vice versa."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":4,"startColumn":15,"endLine":4,"endColumn":16,"description":"Cannot call `acceptsBigInt` with `42` bound to `value` because number [1] is incompatible with bigint [2]. [incompatible-call]"}]','[{"startLine":4,"startColumn":15,"endLine":4,"endColumn":16,"description":"Cannot':!0,call:!0,"`acceptsBigInt`":!0,with:!0,"`42`":!0,bound:!0,to:!0,"`value`":!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,bigint:!0,"[2].":!0,'[incompatible-call]"}]':!0},"function acceptsBigInt(value: bigint) { /* ... */ }\n\nacceptsBigInt(42n); // Works!\nacceptsBigInt(42); // Error!\n")),(0,l.mdx)("p",null,"You can ",(0,l.mdx)("a",{parentName:"p",href:"../../lang/refinements/"},"refine")," a value to ",(0,l.mdx)("inlineCode",{parentName:"p"},"bigint")," using a ",(0,l.mdx)("inlineCode",{parentName:"p"},"typeof")," check:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function acceptsBigInt(value: bigint) { /* ... */ }\n\nfunction func(value: mixed) {\n  if (typeof value === 'bigint') {\n    acceptsBigInt(value); // Works: `value` is `bigint`\n  }\n}\n")))}s.isMDXComponent=!0}}]);