"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[3077],{33077:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var i=t(58168),r=(t(96540),t(15680));t(60681);const a={title:"Type Guards",slug:"/types/type-guards"},o=void 0,s={unversionedId:"types/type-guards",id:"types/type-guards",title:"Type Guards",description:"Flow lets you define functions whose return expression encodes some type predicate over a parameter param. This predicate is annotated in place of a return type annotation as param is PredicateType. It declares that if the function returns true then param is of type PredicateType.",source:"@site/docs/types/type-guards.md",sourceDirName:"types",slug:"/types/type-guards",permalink:"/en/docs/types/type-guards",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/types/type-guards.md",tags:[],version:"current",frontMatter:{title:"Type Guards",slug:"/types/type-guards"},sidebar:"docsSidebar",previous:{title:"Mapped Types",permalink:"/en/docs/types/mapped-types"},next:{title:"Typeof Types",permalink:"/en/docs/types/typeof"}},p={},d=[{value:"Basic Usage",id:"toc-basic-usage",level:2},{value:"Defining a type guard function",id:"defining-a-type-guard-function",level:3},{value:"Using a type guard function to refine values",id:"using-a-type-guard-function-to-refine-values",level:3},{value:"One-sided Type Guards",id:"one-sided-type-guards",level:3},{value:"Refine with <code>Array.filter</code>",id:"refine-with-arrayfilter",level:2},{value:"Defining Type Guard Functions",id:"toc-restrictions-of-type-guard-functions",level:2},{value:"Predicate parameter is a regular parameter to the function",id:"predicate-parameter-is-a-regular-parameter-to-the-function",level:3},{value:"Predicate type is consistent with the parameter type",id:"predicate-type-is-consistent-with-the-parameter-type",level:3},{value:"Type guard function returns boolean",id:"type-guard-function-returns-boolean",level:3},{value:"Predicate type is consistent with refined type",id:"toc-consistency-checks-of-type-guard-functions",level:3},{value:"Adoption",id:"toc-adoption",level:2}],l={toc:d};function u(e){let{components:n,...t}=e;return(0,r.mdx)("wrapper",(0,i.A)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"Flow lets you define functions whose return expression encodes some type predicate over a parameter ",(0,r.mdx)("inlineCode",{parentName:"p"},"param"),". This predicate is annotated in place of a return type annotation as ",(0,r.mdx)("inlineCode",{parentName:"p"},"param is PredicateType"),". It declares that if the function returns ",(0,r.mdx)("inlineCode",{parentName:"p"},"true")," then ",(0,r.mdx)("inlineCode",{parentName:"p"},"param")," is of type ",(0,r.mdx)("inlineCode",{parentName:"p"},"PredicateType"),"."),(0,r.mdx)("p",null,"The syntax for a function like this is:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"function predicate(param: InputType): param is PredicateType {\n  return <some_expression>;\n}\n")),(0,r.mdx)("p",null,"The type of this function can also be written in terms of a type guard annotation:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"type PredicateFunc = (param: InputType) => param is PredicateType;\n")),(0,r.mdx)("h2",{id:"toc-basic-usage"},"Basic Usage"),(0,r.mdx)("p",null,"Let's see a simple example where we define a type guard function and then use it to refine some values."),(0,r.mdx)("h3",{id:"defining-a-type-guard-function"},"Defining a type guard function"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'type A = { type: "A"; data: string };\ntype B = { type: "B"; data: number };\ntype AorB = A | B;\n\nfunction isA(value: AorB): value is A {\n  return value.type === "A";\n}\n')),(0,r.mdx)("p",null,"We have defined a data type ",(0,r.mdx)("inlineCode",{parentName:"p"},"AorB")," that is a disjoint union of two types ",(0,r.mdx)("inlineCode",{parentName:"p"},"A")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"B")," that each have a property ",(0,r.mdx)("inlineCode",{parentName:"p"},"type")," used as tag."),(0,r.mdx)("p",null,"We have also written a ",(0,r.mdx)("em",{parentName:"p"},"user defined type guard")," function ",(0,r.mdx)("inlineCode",{parentName:"p"},"isA")," defined over objects of type ",(0,r.mdx)("inlineCode",{parentName:"p"},"AorB"),". This function returns ",(0,r.mdx)("inlineCode",{parentName:"p"},"true")," when the value of of the ",(0,r.mdx)("inlineCode",{parentName:"p"},"type")," property of its input is ",(0,r.mdx)("inlineCode",{parentName:"p"},'"A"'),". Using the definitions of ",(0,r.mdx)("inlineCode",{parentName:"p"},"A")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"B"),", Flow can prove that when the value of ",(0,r.mdx)("inlineCode",{parentName:"p"},"type")," is ",(0,r.mdx)("inlineCode",{parentName:"p"},'"A"')," then the type of ",(0,r.mdx)("inlineCode",{parentName:"p"},"value")," will be ",(0,r.mdx)("inlineCode",{parentName:"p"},"A"),"."),(0,r.mdx)("h3",{id:"using-a-type-guard-function-to-refine-values"},"Using a type guard function to refine values"),(0,r.mdx)("p",null,"Functions that have a declared type guard can be used to refine values in conditionals. In the example above, we can use ",(0,r.mdx)("inlineCode",{parentName:"p"},"isA")," to refine a variable of type ",(0,r.mdx)("inlineCode",{parentName:"p"},"AorB")," to just ",(0,r.mdx)("inlineCode",{parentName:"p"},"A"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":18,"startColumn":22,"endLine":18,"endColumn":22,"description":"Cannot assign `x` to `error` because string [1] is incompatible with number [2] in property `data`. [incompatible-type]"},{"startLine":18,"startColumn":22,"endLine":18,"endColumn":22,"description":"Cannot assign `x` to `error` because string literal `A` [1] is incompatible with string literal `B` [2] in property `type`. [incompatible-type]"}]','[{"startLine":18,"startColumn":22,"endLine":18,"endColumn":22,"description":"Cannot':!0,assign:!0,"`x`":!0,to:!0,"`error`":!0,because:!0,string:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,"[2]":!0,in:!0,property:!0,"`data`.":!0,'[incompatible-type]"},{"startLine":18,"startColumn":22,"endLine":18,"endColumn":22,"description":"Cannot':!0,literal:!0,"`A`":!0,"`B`":!0,"`type`.":!0,'[incompatible-type]"}]':!0},'type A = { type: "A"; data: string };\ntype B = { type: "B"; data: number };\ntype AorB = A | B;\n\nfunction isA(value: AorB): value is A {\n  return value.type === "A";\n}\n\nfunction test(x: AorB) {\n  if (isA(x)) {\n    // `x` has now been refined to type A.\n    // We can assign it variables of type A ...\n    const y: A = x;\n    // ...and access A\'s properties through `x`\n    const stringData: string = x.data;\n\n    // As a sanity check, the following assignment to B will error\n    const error: B = x;\n  }\n}\n')),(0,r.mdx)("p",null,"In the then-branch of the conditional ",(0,r.mdx)("inlineCode",{parentName:"p"},"if (isA(x))"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"x")," will have the type ",(0,r.mdx)("inlineCode",{parentName:"p"},"A"),"."),(0,r.mdx)("h3",{id:"one-sided-type-guards"},"One-sided Type Guards"),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"Note:")," This feature is available as of v0.237.0 when option ",(0,r.mdx)("inlineCode",{parentName:"p"},"one_sided_type_guards=true")," is set in the flowconfig. It is enabled by default as of v0.239.0."),(0,r.mdx)("p",null,"In some cases we may want to declare that a type guard function only refines the then-branch of a conditional. Consider for example the function"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function isPositive(n: ?number): boolean {\n  return n != null && n > 0;\n}\n")),(0,r.mdx)("p",null,"If we declared ",(0,r.mdx)("inlineCode",{parentName:"p"},"n is number")," as the type guard of this function then in the following code:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"declare n: ?number;\nif (isPositive(n)) {\n  // n is number here\n} else {\n  // n would be null | void here\n}\n")),(0,r.mdx)("p",null,"we would be able to establish that ",(0,r.mdx)("inlineCode",{parentName:"p"},"n")," is ",(0,r.mdx)("inlineCode",{parentName:"p"},"null | void")," in the else-branch. This is not true, however, since ",(0,r.mdx)("inlineCode",{parentName:"p"},"n")," could just be a non-negative number."),(0,r.mdx)("p",null,"One-sided type guards, which we annotate as ",(0,r.mdx)("inlineCode",{parentName:"p"},"implies param is PredicateType"),", let us specify that a predicate narrows the type in only the positive case. For example,"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function isPositive(n: ?number): implies n is number {\n  return n != null && n > 0;\n}\n")),(0,r.mdx)("p",null,"Now, we'll get the following behavior"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"declare n: ?number;\nif (isPositive(n)) {\n  // n is number here\n} else {\n  // n is still ?number\n}\n")),(0,r.mdx)("h2",{id:"refine-with-arrayfilter"},"Refine with ",(0,r.mdx)("inlineCode",{parentName:"h2"},"Array.filter")),(0,r.mdx)("p",null,"Flow recognizes when you call ",(0,r.mdx)("inlineCode",{parentName:"p"},"filter")," on an array of type ",(0,r.mdx)("inlineCode",{parentName:"p"},"Array<T>")," with a callback function that holds a type guard with type ",(0,r.mdx)("inlineCode",{parentName:"p"},"(value: T) => value is S"),".\nIt will use this to produce an output array of type ",(0,r.mdx)("inlineCode",{parentName:"p"},"Array<S>"),". Note that ",(0,r.mdx)("inlineCode",{parentName:"p"},"S")," needs to be a subtype of the type of the array element ",(0,r.mdx)("inlineCode",{parentName:"p"},"T"),"."),(0,r.mdx)("p",null,"For example"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":19,"startColumn":10,"endLine":19,"endColumn":15,"description":"Cannot return `result` because property `error` is missing in object type [1] but exists in object type [2] in array element. [prop-missing]"},{"startLine":19,"startColumn":10,"endLine":19,"endColumn":15,"description":"Cannot return `result` because property `value` is missing in object type [1] but exists in object type [2] in array element. [prop-missing]"},{"startLine":19,"startColumn":10,"endLine":19,"endColumn":15,"description":"Cannot return `result` because string literal `success` [1] is incompatible with string literal `error` [2] in property `type` of array element. [incompatible-return]"},{"startLine":25,"startColumn":17,"endLine":25,"endColumn":33,"description":"Inconsistent type guard declaration because property `error` is missing in object type [1] but exists in object type [2]. The type of `response` [3] refined with the predicate encoded in return expression `response.type === \'success\'` [4] needs to be compatible with the guard type `Error` [2]. See 1. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [prop-missing]"},{"startLine":25,"startColumn":17,"endLine":25,"endColumn":33,"description":"Inconsistent type guard declaration because string literal `success` [1] is incompatible with string literal `error` [2] in property `type`. The type of `response` [3] refined with the predicate encoded in return expression `response.type === \'success\'` [4] needs to be compatible with the guard type `Error` [5]. See 1. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]"},{"startLine":25,"startColumn":29,"endLine":25,"endColumn":33,"description":"Inconsistent type guard declaration because property `value` is missing in object type [1] but exists in object type [2]. The type of `response` [3] refined with the predicate encoded in return expression `response.type === \'success\'` [4] needs to be compatible with the guard type `Error` [1]. See 1. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [prop-missing]"},{"startLine":25,"startColumn":17,"endLine":25,"endColumn":33,"description":"Inconsistent type guard declaration. The negation of the predicate encoded in return expression `response.type === \'success\'` [1] needs to completely refine away the guard type `Error` [2]. Consider using a one-sided type-guard (`implies x is T`). See 2. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]"}]','[{"startLine":19,"startColumn":10,"endLine":19,"endColumn":15,"description":"Cannot':!0,return:!0,"`result`":!0,because:!0,property:!0,"`error`":!0,is:!0,missing:!0,in:!0,object:!0,type:!0,"[1]":!0,but:!0,exists:!0,"[2]":!0,array:!0,"element.":!0,'[prop-missing]"},{"startLine":19,"startColumn":10,"endLine":19,"endColumn":15,"description":"Cannot':!0,"`value`":!0,string:!0,literal:!0,"`success`":!0,incompatible:!0,with:!0,"`type`":!0,of:!0,'[incompatible-return]"},{"startLine":25,"startColumn":17,"endLine":25,"endColumn":33,"description":"Inconsistent':!0,guard:!0,declaration:!0,"[2].":!0,The:!0,"`response`":!0,"[3]":!0,refined:!0,the:!0,predicate:!0,encoded:!0,expression:!0,"`response.type":!0,"":"","'success'`":!0,"[4]":!0,needs:!0,to:!0,be:!0,compatible:!0,"`Error`":!0,See:!0,"1.":!0,"https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions.":!0,'[prop-missing]"},{"startLine":25,"startColumn":17,"endLine":25,"endColumn":33,"description":"Inconsistent':!0,"`type`.":!0,"[5].":!0,'[incompatible-type-guard]"},{"startLine":25,"startColumn":29,"endLine":25,"endColumn":33,"description":"Inconsistent':!0,"[1].":!0,"declaration.":!0,negation:!0,completely:!0,refine:!0,away:!0,Consider:!0,using:!0,a:!0,"one-sided":!0,"type-guard":!0,"(`implies":!0,x:!0,"T`).":!0,"2.":!0,'[incompatible-type-guard]"}]':!0},"type Success = $ReadOnly<{type: 'success', value: 23}>;\ntype Error = $ReadOnly<{type: 'error', error: string}>;\n\ntype Response =\n  | Success\n  | Error\n\nfunction filterSuccess(response: Array<Response>): Array<Success> {\n  return response.filter(\n    (response): response is Success => response.type === 'success'\n  );\n}\n\nfunction filterError1(response: Array<Response>): Array<Error> {\n  const result = response.filter(\n    (response): response is Success => response.type === 'success'\n  );\n  // The following is expected to error\n  return result;\n}\n\nfunction filterError2(response: Array<Response>): Array<Error> {\n  const result = response.filter(\n    // The following is expected to error\n    (response): response is Error => response.type === 'success'\n  );\n  return result;\n}\n")),(0,r.mdx)("p",null,"In ",(0,r.mdx)("inlineCode",{parentName:"p"},"filterError1"),", filtering produces ",(0,r.mdx)("inlineCode",{parentName:"p"},"Array<Success>")," that is not compatible with the expected return type ",(0,r.mdx)("inlineCode",{parentName:"p"},"Array<Error>"),"."),(0,r.mdx)("p",null,"In ",(0,r.mdx)("inlineCode",{parentName:"p"},"filterError2"),", the predicate ",(0,r.mdx)("inlineCode",{parentName:"p"},"response.type === 'success'")," is used to refine ",(0,r.mdx)("inlineCode",{parentName:"p"},"Response"),"s to ",(0,r.mdx)("inlineCode",{parentName:"p"},"Success"),"s, not ",(0,r.mdx)("inlineCode",{parentName:"p"},"Error"),"s."),(0,r.mdx)("h2",{id:"toc-restrictions-of-type-guard-functions"},"Defining Type Guard Functions"),(0,r.mdx)("p",null,"To ensure that refinement with type guard functions is sound, Flow runs a number of checks associated with these functions."),(0,r.mdx)("h3",{id:"predicate-parameter-is-a-regular-parameter-to-the-function"},"Predicate parameter is a regular parameter to the function"),(0,r.mdx)("p",null,"In a type guard annotation of the form ",(0,r.mdx)("inlineCode",{parentName:"p"},"parameter is Type"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"parameter")," needs to belong to the current function's parameter list."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":33,"endLine":1,"endColumn":36,"description":"Cannot find type guard parameter `prop` [1] in the parameters of this function (type). [function-predicate]"}]','[{"startLine":1,"startColumn":33,"endLine":1,"endColumn":36,"description":"Cannot':!0,find:!0,type:!0,guard:!0,parameter:!0,"`prop`":!0,"[1]":!0,in:!0,the:!0,parameters:!0,of:!0,this:!0,function:!0,"(type).":!0,'[function-predicate]"}]':!0},'function missing(param: mixed): prop is number {\n  return typeof param === "number";\n}\n')),(0,r.mdx)("p",null,"It cannot be a parameter bound in a destructuring pattern, or a rest paramter:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":48,"endLine":1,"endColumn":51,"description":"A type guard parameter `prop` [1] cannot reference pattern parameter `prop` [2]. [function-predicate]"}]','[{"startLine":1,"startColumn":48,"endLine":1,"endColumn":51,"description":"A':!0,type:!0,guard:!0,parameter:!0,"`prop`":!0,"[1]":!0,cannot:!0,reference:!0,pattern:!0,"[2].":!0,'[function-predicate]"}]':!0},'function destructuring({prop}: {prop: mixed}): prop is number {\n  return typeof prop === "number";\n}\n')),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":40,"endLine":1,"endColumn":44,"description":"A type guard parameter `value` [1] cannot reference rest parameter `value` [2]. [function-predicate]"}]','[{"startLine":1,"startColumn":40,"endLine":1,"endColumn":44,"description":"A':!0,type:!0,guard:!0,parameter:!0,"`value`":!0,"[1]":!0,cannot:!0,reference:!0,rest:!0,"[2].":!0,'[function-predicate]"}]':!0},"function rest(...value: Array<mixed>): value is Array<mixed> {\n  return Array.isArray(value);\n}\n")),(0,r.mdx)("h3",{id:"predicate-type-is-consistent-with-the-parameter-type"},"Predicate type is consistent with the parameter type"),(0,r.mdx)("p",null,"The type guard ",(0,r.mdx)("inlineCode",{parentName:"p"},"Type")," needs to be compatible with the type of the parameter. In other words, given a definition"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"function isT(x: ParamType): x is Type {\n  return ...\n}\n")),(0,r.mdx)("p",null,"Flow will check that ",(0,r.mdx)("inlineCode",{parentName:"p"},"Type")," is a subtype of ",(0,r.mdx)("inlineCode",{parentName:"p"},"ParamType"),". So the following will be an error:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":36,"endLine":1,"endColumn":41,"description":"Cannot use number [1] as type prediate for parameter `x` because number [1] is incompatible with string [2]. A user defined type guard needs to be compatible with its parameter\'s type. [incompatible-type-guard]"}]','[{"startLine":1,"startColumn":36,"endLine":1,"endColumn":41,"description":"Cannot':!0,use:!0,number:!0,"[1]":!0,as:!0,type:!0,prediate:!0,for:!0,parameter:!0,"`x`":!0,because:!0,is:!0,incompatible:!0,with:!0,string:!0,"[2].":!0,A:!0,user:!0,defined:!0,guard:!0,needs:!0,to:!0,be:!0,compatible:!0,its:!0,"parameter's":!0,"type.":!0,'[incompatible-type-guard]"}]':!0},'function isNumber(x: string): x is number {\n  return typeof x === "number";\n}\n')),(0,r.mdx)("h3",{id:"type-guard-function-returns-boolean"},"Type guard function returns boolean"),(0,r.mdx)("p",null,"A type guard function needs to return a boolean expression. The following are invalid declarations:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":39,"endLine":1,"endColumn":49,"description":"Cannot declare a type predicate [1] for function [2] because boolean [1] is incompatible with implicitly-returned undefined. [incompatible-return]"}]','[{"startLine":1,"startColumn":39,"endLine":1,"endColumn":49,"description":"Cannot':!0,declare:!0,a:!0,type:!0,predicate:!0,"[1]":!0,for:!0,function:!0,"[2]":!0,because:!0,boolean:!0,is:!0,incompatible:!0,with:!0,"implicitly-returned":!0,"undefined.":!0,'[incompatible-return]"}]':!0},"function isNumberNoReturn(x: string): x is string {}\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":2,"startColumn":10,"endLine":2,"endColumn":10,"description":"Cannot return `x` because null or undefined [1] is incompatible with boolean [2]. [incompatible-return]"},{"startLine":2,"startColumn":10,"endLine":2,"endColumn":10,"description":"Cannot return `x` because object type [1] is incompatible with boolean [2]. [incompatible-return]"}]','[{"startLine":2,"startColumn":10,"endLine":2,"endColumn":10,"description":"Cannot':!0,return:!0,"`x`":!0,because:!0,null:!0,or:!0,undefined:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,boolean:!0,"[2].":!0,'[incompatible-return]"},{"startLine":2,"startColumn":10,"endLine":2,"endColumn":10,"description":"Cannot':!0,object:!0,type:!0,'[incompatible-return]"}]':!0},"function nonMaybe<V: {...}>(x: ?V): x is V {\n  return x;\n}\n")),(0,r.mdx)("p",null,"A correct version of ",(0,r.mdx)("inlineCode",{parentName:"p"},"nonMaybe")," would be"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function nonMaybe<V: {...}>(x: ?V): x is V {\n  return !!x;\n}\n")),(0,r.mdx)("h3",{id:"toc-consistency-checks-of-type-guard-functions"},"Predicate type is consistent with refined type"),(0,r.mdx)("p",null,"In addition to the above checks, Flow also ensures that the declared type guard is consistent with the check happening in the body of the function. To establish this it needs to guarantee two things:"),(0,r.mdx)("ol",null,(0,r.mdx)("li",{parentName:"ol"},"The type of the refined parameter at the return location ",(0,r.mdx)("em",{parentName:"li"},"after")," the predicate of the return expression has been applied is a subtype of the guard type. For example, the following definitions are correct:")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":5,"startColumn":43,"endLine":5,"endColumn":62,"description":"Inconsistent type guard declaration. The negation of the predicate encoded in return expression `true` [1] needs to completely refine away the guard type union type [2]. Consider using a one-sided type-guard (`implies x is T`). See 2. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]"},{"startLine":5,"startColumn":43,"endLine":5,"endColumn":62,"description":"Inconsistent type guard declaration. The negation of the predicate encoded in return expression `true` [1] needs to completely refine away the guard type union type [2]. Consider using a one-sided type-guard (`implies x is T`). See 2. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]"}]','[{"startLine":5,"startColumn":43,"endLine":5,"endColumn":62,"description":"Inconsistent':!0,type:!0,guard:!0,"declaration.":!0,The:!0,negation:!0,of:!0,the:!0,predicate:!0,encoded:!0,in:!0,return:!0,expression:!0,"`true`":!0,"[1]":!0,needs:!0,to:!0,completely:!0,refine:!0,away:!0,union:!0,"[2].":!0,Consider:!0,using:!0,a:!0,"one-sided":!0,"type-guard":!0,"(`implies":!0,x:!0,is:!0,"T`).":!0,See:!0,"2.":!0,"https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions.":!0,'[incompatible-type-guard]"},{"startLine":5,"startColumn":43,"endLine":5,"endColumn":62,"description":"Inconsistent':!0,'[incompatible-type-guard]"}]':!0},'function numOrStr(x: mixed): x is number | string {\n  return (typeof x === "number" || typeof x === "string");\n}\n\nfunction numOrStrWithException(x: mixed): x is number | string {\n  if (typeof x === "number") {\n    return true;\n  } else {\n    if (typeof x === "string") {\n        return true;\n    } else {\n        throw new Error("");\n    }\n  }\n}\n')),(0,r.mdx)("p",null,"But in the following Flow will raise errors:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":35,"endLine":1,"endColumn":54,"description":"Inconsistent type guard declaration because: [incompatible-type-guard] Either boolean [1] is incompatible with number [2]. Or boolean [1] is incompatible with string [3]. \\nThe type of `x` [4] refined with the predicate encoded in return expression `((typeof x) === \\"number\\") || ((typeof x) === \\"boolean\\")` [5] needs to be compatible with the guard type union type [6]. See 1. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions."},{"startLine":1,"startColumn":35,"endLine":1,"endColumn":54,"description":"Inconsistent type guard declaration. The negation of the predicate encoded in return expression `((typeof x) === \\"number\\") || ((typeof x) === \\"boolean\\")` [1] needs to completely refine away the guard type union type [2]. Consider using a one-sided type-guard (`implies x is T`). See 2. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]"}]','[{"startLine":1,"startColumn":35,"endLine":1,"endColumn":54,"description":"Inconsistent':!0,type:!0,guard:!0,declaration:!0,"because:":!0,"[incompatible-type-guard]":!0,Either:!0,boolean:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,"[2].":!0,Or:!0,string:!0,"[3].":!0,"\\nThe":!0,of:!0,"`x`":!0,"[4]":!0,refined:!0,the:!0,predicate:!0,encoded:!0,in:!0,return:!0,expression:!0,"`((typeof":!0,"x)":!0,"":"",'\\"number\\")':!0,"||":!0,"((typeof":!0,'\\"boolean\\")`':!0,"[5]":!0,needs:!0,to:!0,be:!0,compatible:!0,union:!0,"[6].":!0,See:!0,"1.":!0,'https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions."},{"startLine":1,"startColumn":35,"endLine":1,"endColumn":54,"description":"Inconsistent':!0,"declaration.":!0,The:!0,negation:!0,completely:!0,refine:!0,away:!0,Consider:!0,using:!0,a:!0,"one-sided":!0,"type-guard":!0,"(`implies":!0,x:!0,"T`).":!0,"2.":!0,"https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions.":!0,'[incompatible-type-guard]"}]':!0},'function numOrStrError(x: mixed): x is number | string {\n  return (typeof x === "number" || typeof x === "boolean");\n}\n')),(0,r.mdx)("ol",{start:2},(0,r.mdx)("li",{parentName:"ol"},"Type guard functions can be used to refine the else-branch of conditionals. For example,")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'function isNumber(x: mixed): x is number {\n  return typeof x === "number";\n}\n\ndeclare var value: number | string;\nif (isNumber(value)) {\n  value as number; // okay\n} else {\n  value as string; // also okay\n}\n')),(0,r.mdx)("p",null,"Therefore, the inverse form of the first requirement also needs to hold. Specifically, if we negate the predicate encoded in the function, and use it to refine the input, then the result must not overlap with the type guard at all. This condition is equivalent to checking that the type guard refined with the negation of the function predicate is a subtype of ",(0,r.mdx)("inlineCode",{parentName:"p"},"empty"),". For example the following raises an error:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":30,"endLine":1,"endColumn":40,"description":"Inconsistent type guard declaration. The negation of the predicate encoded in return expression `((typeof x) === \'number\') && (x > 0)` [1] needs to completely refine away the guard type number [2]. Consider using a one-sided type-guard (`implies x is T`). See 2. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]"}]','[{"startLine":1,"startColumn":30,"endLine":1,"endColumn":40,"description":"Inconsistent':!0,type:!0,guard:!0,"declaration.":!0,The:!0,negation:!0,of:!0,the:!0,predicate:!0,encoded:!0,in:!0,return:!0,expression:!0,"`((typeof":!0,"x)":!0,"":"","'number')":!0,"&&":!0,"(x":!0,">":!0,"0)`":!0,"[1]":!0,needs:!0,to:!0,completely:!0,refine:!0,away:!0,number:!0,"[2].":!0,Consider:!0,using:!0,a:!0,"one-sided":!0,"type-guard":!0,"(`implies":!0,x:!0,is:!0,"T`).":!0,See:!0,"2.":!0,"https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions.":!0,'[incompatible-type-guard]"}]':!0},"function isPosNum(x: mixed): x is number {\n    return typeof x === 'number' && x > 0;\n}\n")),(0,r.mdx)("p",null,"This is because the negation of the predicate of ",(0,r.mdx)("inlineCode",{parentName:"p"},"isPosNum"),' is "',(0,r.mdx)("inlineCode",{parentName:"p"},"x")," is not a number or ",(0,r.mdx)("inlineCode",{parentName:"p"},"x<=0"),'". This predicate is equivalent to the empty predicate and does not refine the input type it is applied to.'),(0,r.mdx)("p",null,"If you're seeing errors related to this check, consider using a one-sided type guard (write ",(0,r.mdx)("inlineCode",{parentName:"p"},"implies x is T"),"). Ones-sided type guards do not require this check, since they do not refine the else-branch of conditionals."),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"Note:")," This check only happens when ",(0,r.mdx)("inlineCode",{parentName:"p"},"one_sided_type_guards=true")," is set in the flowconfig. It happens by default as of v0.239.0."),(0,r.mdx)("ol",{start:3},(0,r.mdx)("li",{parentName:"ol"},"The parameter that is refined cannot be reassigned in the body of the type guard function. Therefore the following are errors:")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":10,"endLine":3,"endColumn":30,"description":"Cannot use type guard parameter `x` [1] because at this return point it is written to in [2]. [function-predicate]"}]','[{"startLine":3,"startColumn":10,"endLine":3,"endColumn":30,"description":"Cannot':!0,use:!0,type:!0,guard:!0,parameter:!0,"`x`":!0,"[1]":!0,because:!0,at:!0,this:!0,return:!0,point:!0,it:!0,is:!0,written:!0,to:!0,in:!0,"[2].":!0,'[function-predicate]"}]':!0},'function isNumberError1(x: mixed): x is number {\n  x = 1;\n  return typeof x === "number";\n}\n')),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":36,"endLine":1,"endColumn":36,"description":"Cannot use type guard parameter `x`, because `x` [1] is reassigned in [2]. [function-predicate]"}]','[{"startLine":1,"startColumn":36,"endLine":1,"endColumn":36,"description":"Cannot':!0,use:!0,type:!0,guard:!0,parameter:!0,"`x`,":!0,because:!0,"`x`":!0,"[1]":!0,is:!0,reassigned:!0,in:!0,"[2].":!0,'[function-predicate]"}]':!0},'function isNumberError2(x: mixed): x is number {\n  function foo() {\n    x = 1;\n  }\n  foo();\n  return typeof x === "number";\n}\n')),(0,r.mdx)("h2",{id:"toc-adoption"},"Adoption"),(0,r.mdx)("p",null,"To use type guards, you need to upgrade your infrastructure so that it supports the syntax:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"flow")," and ",(0,r.mdx)("inlineCode",{parentName:"li"},"flow-parser"),": 0.209.1. Between v0.209.1 to v0.211.1, you need to explicitly enable it in your .flowconfig, under the ",(0,r.mdx)("inlineCode",{parentName:"li"},"[options]")," heading, add ",(0,r.mdx)("inlineCode",{parentName:"li"},"type_guards=true"),". One-sided type guards are available as of version 0.237.0 with the option ",(0,r.mdx)("inlineCode",{parentName:"li"},"one_sided_type_guards=true"),", and are enabled by default as of v0.239.0."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"prettier"),": 3"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"babel")," with ",(0,r.mdx)("inlineCode",{parentName:"li"},"babel-plugin-syntax-hermes-parser"),". See ",(0,r.mdx)("a",{parentName:"li",href:"../../tools/babel/"},"our Babel guide")," for setup instructions."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"eslint")," with ",(0,r.mdx)("inlineCode",{parentName:"li"},"hermes-eslint"),". See ",(0,r.mdx)("a",{parentName:"li",href:"../../tools/eslint/"},"our ESLint guide")," for setup instructions.")))}u.isMDXComponent=!0}}]);