"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[1944],{71944:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>p,toc:()=>c});var o=t(58168),a=(t(96540),t(15680));t(60681);const r={title:"Higher-order Components",slug:"/react/hoc"},i=void 0,p={unversionedId:"react/hoc",id:"react/hoc",title:"Higher-order Components",description:"Higher-order components are discouraged in modern React code and will not be updated for Component Syntax.",source:"@site/docs/react/hoc.md",sourceDirName:"react",slug:"/react/hoc",permalink:"/en/docs/react/hoc",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/react/hoc.md",tags:[],version:"current",frontMatter:{title:"Higher-order Components",slug:"/react/hoc"},sidebar:"docsSidebar",previous:{title:"Ref Functions",permalink:"/en/docs/react/refs"},next:{title:"Render Types",permalink:"/en/docs/react/render-types"}},s={},c=[{value:"The Trivial HOC",id:"toc-the-trivial-hoc",level:3},{value:"Injecting Props",id:"toc-injecting-props",level:3},{value:"Preserving the Instance Type of a Component",id:"toc-preserving-the-instance-type-of-a-component",level:3},{value:"Exporting Wrapped Components",id:"toc-exporting-wrapped-components",level:3}],m={toc:c};function d(e){let{components:n,...t}=e;return(0,a.mdx)("wrapper",(0,o.A)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.mdx)("admonition",{type:"danger"},(0,a.mdx)("p",{parentName:"admonition"},"Higher-order components are discouraged in modern React code and will not be updated for ",(0,a.mdx)("a",{parentName:"p",href:"../component-syntax"},"Component Syntax"),".\nConsider using a hook to accomplish your task instead.")),(0,a.mdx)("p",null,"A popular pattern in React is the ",(0,a.mdx)("a",{parentName:"p",href:"https://facebook.github.io/react/docs/higher-order-components.html"},"higher-order component pattern"),", so it's\nimportant that we can provide effective types for higher-order components in\nFlow. If you don't already know what a higher-order component is then make sure\nto read the ",(0,a.mdx)("a",{parentName:"p",href:"https://facebook.github.io/react/docs/higher-order-components.html"},"React documentation on higher-order components")," before\ncontinuing."),(0,a.mdx)("p",null,"You can make use of the ",(0,a.mdx)("a",{parentName:"p",href:"../types/#toc-react-abstractcomponent"},(0,a.mdx)("inlineCode",{parentName:"a"},"React.AbstractComponent"))," type to annotate your higher order components."),(0,a.mdx)("h3",{id:"toc-the-trivial-hoc"},"The Trivial HOC"),(0,a.mdx)("p",null,"Let's start with the simplest HOC:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"import * as React from 'react';\n\nfunction trivialHOC<Config: {...}>(\n  Component: React.AbstractComponent<Config>\n): React.AbstractComponent<Config> {\n  return Component;\n}\n")),(0,a.mdx)("p",null,"This is a basic template for what your HOCs might look like. At runtime, this HOC doesn't\ndo anything at all. Let's take a look at some more complex examples."),(0,a.mdx)("h3",{id:"toc-injecting-props"},"Injecting Props"),(0,a.mdx)("p",null,"A common use case for higher-order components is to inject a prop.\nThe HOC automatically sets a prop and returns a component which no longer requires\nthat prop. For example, consider a navigation prop. How would one type this?"),(0,a.mdx)("p",null,"To remove a prop from the config, we can take a component that includes the\nprop and return a component that does not. It's best to construct these\ntypes using object type spread."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":27,"startColumn":2,"endLine":27,"endColumn":20,"description":"Cannot create `MyEnhancedComponent` element because property `b` is missing in props [1] but exists in object type [2]. [prop-missing]"}]','[{"startLine":27,"startColumn":2,"endLine":27,"endColumn":20,"description":"Cannot':!0,create:!0,"`MyEnhancedComponent`":!0,element:!0,because:!0,property:!0,"`b`":!0,is:!0,missing:!0,in:!0,props:!0,"[1]":!0,but:!0,exists:!0,object:!0,type:!0,"[2].":!0,'[prop-missing]"}]':!0},"import * as React from 'react';\n\ntype InjectedProps = {foo: number}\n\nfunction injectProp<Config>(\n  Component: React.AbstractComponent<{...Config, ...InjectedProps}>\n): React.AbstractComponent<Config> {\n  return function WrapperComponent(\n    props: Config,\n  ) {\n    return <Component {...props} foo={42} />;\n  };\n}\n\nfunction MyComponent(props: {\n  a: number,\n  b: number,\n  ...InjectedProps,\n}): React.Node {}\n\nconst MyEnhancedComponent = injectProp(MyComponent);\n\n// We don't need to pass in `foo` even though `MyComponent` requires it:\n<MyEnhancedComponent a={1} b={2} />; // OK\n\n// We still require `a` and `b`:\n<MyEnhancedComponent a={1} />; // ERROR\n")),(0,a.mdx)("h3",{id:"toc-preserving-the-instance-type-of-a-component"},"Preserving the Instance Type of a Component"),(0,a.mdx)("p",null,"Recall that the instance type of a function component is ",(0,a.mdx)("inlineCode",{parentName:"p"},"void"),". Our example\nabove wraps a component in a function, so the returned component has the instance\ntype ",(0,a.mdx)("inlineCode",{parentName:"p"},"void"),"."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":29,"startColumn":27,"endLine":29,"endColumn":29,"description":"Cannot create `MyEnhancedComponent` element because in property `ref`: [incompatible-type] Either a call signature declaring the expected parameter / return type is missing in `React.RefObject` [1] but exists in function type [2]. Or `React.RefObject` [1] is incompatible with number [3]."}]','[{"startLine":29,"startColumn":27,"endLine":29,"endColumn":29,"description":"Cannot':!0,create:!0,"`MyEnhancedComponent`":!0,element:!0,because:!0,in:!0,property:!0,"`ref`:":!0,"[incompatible-type]":!0,Either:!0,a:!0,call:!0,signature:!0,declaring:!0,the:!0,expected:!0,parameter:!0,"/":!0,return:!0,type:!0,is:!0,missing:!0,"`React.RefObject`":!0,"[1]":!0,but:!0,exists:!0,function:!0,"[2].":!0,Or:!0,incompatible:!0,with:!0,number:!0,'[3]."}]':!0},"import * as React from 'react';\n\ntype InjectedProps = {foo: number}\n\nfunction injectProp<Config>(\n  Component: React.AbstractComponent<{...Config, ...InjectedProps}>\n): React.AbstractComponent<Config> {\n  return function WrapperComponent(\n    props: Config,\n  ) {\n    return <Component {...props} foo={42} />;\n  };\n}\n\n// A class component in this example\nclass MyComponent extends React.Component<{\n  a: number,\n  b: number,\n  ...InjectedProps,\n}> {}\n\nconst MyEnhancedComponent = injectProp(MyComponent);\n\n// If we create a ref object for the component, it will never be assigned\n// an instance of MyComponent!\nconst ref = React.createRef<MyComponent>();\n\n// Error, mixed is incompatible with MyComponent.\n<MyEnhancedComponent ref={ref} a={1} b={2} />;\n")),(0,a.mdx)("p",null,"We get this error message because ",(0,a.mdx)("inlineCode",{parentName:"p"},"React.AbstractComponent<Config>")," doesn't set the ",(0,a.mdx)("inlineCode",{parentName:"p"},"Instance")," type\nparameter, so it is automatically set to ",(0,a.mdx)("inlineCode",{parentName:"p"},"mixed"),". If we wanted to preserve the instance type\nof the component, we can use ",(0,a.mdx)("a",{parentName:"p",href:"https://reactjs.org/docs/forwarding-refs.html"},(0,a.mdx)("inlineCode",{parentName:"a"},"React.forwardRef")),":"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"import * as React from 'react';\n\ntype InjectedProps = {foo: number}\n\nfunction injectAndPreserveInstance<Config, Instance>(\n  Component: React.AbstractComponent<{...Config, ...InjectedProps}, Instance>\n): React.AbstractComponent<Config, Instance> {\n  return React.forwardRef<Config, Instance>((props, ref) =>\n      <Component ref={ref} foo={3} {...props} />\n  );\n}\n\nclass MyComponent extends React.Component<{\n  a: number,\n  b: number,\n  ...InjectedProps,\n}> {}\n\nconst MyEnhancedComponent = injectAndPreserveInstance(MyComponent);\n\nconst ref = React.createRef<MyComponent>();\n\n// All good! The ref is forwarded.\n<MyEnhancedComponent ref={ref} a={1} b={2} />;\n")),(0,a.mdx)("h3",{id:"toc-exporting-wrapped-components"},"Exporting Wrapped Components"),(0,a.mdx)("p",null,"If you try to export a wrapped component, chances are that you'll run into a missing annotation error:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":13,"startColumn":36,"endLine":13,"endColumn":58,"description":"Cannot build a typed interface for this module. You should annotate the exports of this module with types. Cannot determine the type of this call expression. Please provide an annotation, e.g., by adding a type cast around this expression. [signature-verification-failure]"}]','[{"startLine":13,"startColumn":36,"endLine":13,"endColumn":58,"description":"Cannot':!0,build:!0,a:!0,typed:!0,interface:!0,for:!0,this:!0,"module.":!0,You:!0,should:!0,annotate:!0,the:!0,exports:!0,of:!0,module:!0,with:!0,"types.":!0,Cannot:!0,determine:!0,type:!0,call:!0,"expression.":!0,Please:!0,provide:!0,an:!0,"annotation,":!0,"e.g.,":!0,by:!0,adding:!0,cast:!0,around:!0,'[signature-verification-failure]"}]':!0},"import * as React from 'react';\n\nfunction trivialHOC<Config: {...}>(\n  Component: React.AbstractComponent<Config>,\n): React.AbstractComponent<Config> {\n  return Component;\n}\n\ntype Props = $ReadOnly<{bar: number, foo?: number}>;\n\nfunction MyComponent({bar, foo = 3}: Props): React.Node {}\n\nexport const MyEnhancedComponent = trivialHOC(MyComponent); // ERROR\n")),(0,a.mdx)("p",null,"You can add an annotation to your exported component using ",(0,a.mdx)("inlineCode",{parentName:"p"},"React.AbstractComponent"),":"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"import * as React from 'react';\n\nfunction trivialHOC<Config: {...}>(\n  Component: React.AbstractComponent<Config>,\n): React.AbstractComponent<Config> {\n  return Component;\n}\n\ntype Props = $ReadOnly<{bar: number, foo?: number}>;\n\nfunction MyComponent({bar, foo = 3}: Props): React.Node {}\n\nexport const MyEnhancedComponent: React.AbstractComponent<Props> = trivialHOC(MyComponent); // OK\n")))}d.isMDXComponent=!0}}]);