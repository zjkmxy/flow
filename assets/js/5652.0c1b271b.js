"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[5652],{45652:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var a=t(58168),i=(t(96540),t(15680));t(60681);const o={title:"Annotation Requirement",slug:"/lang/annotation-requirement"},r=void 0,l={unversionedId:"lang/annotation-requirement",id:"lang/annotation-requirement",title:"Annotation Requirement",description:"Note: As of version 0.199 Flow uses Local Type Inference as its inference algorithm.",source:"@site/docs/lang/annotation-requirement.md",sourceDirName:"lang",slug:"/lang/annotation-requirement",permalink:"/en/docs/lang/annotation-requirement",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/lang/annotation-requirement.md",tags:[],version:"current",frontMatter:{title:"Annotation Requirement",slug:"/lang/annotation-requirement"},sidebar:"docsSidebar",previous:{title:"File Signatures (Types-First)",permalink:"/en/docs/lang/types-first"},next:{title:"Getting Started",permalink:"/en/docs/react"}},s={},d=[{value:"Variable declarations",id:"variable-declarations",level:2},{value:"Function Parameters",id:"function-parameters",level:2},{value:"Contextual Typing",id:"toc-contextual-typing",level:2},{value:"Function Return Types",id:"toc-function-return-types",level:2},{value:"Generic Calls",id:"toc-generic-calls",level:2},{value:"Computing a Solution",id:"computing-a-solution",level:3},{value:"Errors during Polymorphic Calls",id:"errors-during-polymorphic-calls",level:3},{value:"Under-constrained Type Parameters",id:"under-constrained-type-parameters",level:4},{value:"Incompatibility Errors",id:"incompatibility-errors",level:4},{value:"Empty Array Literals",id:"toc-empty-array-literals",level:2}],m={toc:d};function p(e){let{components:n,...t}=e;return(0,i.mdx)("wrapper",(0,a.A)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("blockquote",null,(0,i.mdx)("p",{parentName:"blockquote"},(0,i.mdx)("strong",{parentName:"p"},"Note:")," As of version 0.199 Flow uses ",(0,i.mdx)("a",{parentName:"p",href:"https://medium.com/flow-type/local-type-inference-for-flow-aaa65d071347"},"Local Type Inference")," as its inference algorithm.\nThe rules in this section reflect the main design features in this inference scheme.")),(0,i.mdx)("p",null,"Flow tries to avoid requiring type annotation for parts of programs where types can easily\nbe inferred from the immediate context of an expression, variable, parameter, etc."),(0,i.mdx)("h2",{id:"variable-declarations"},"Variable declarations"),(0,i.mdx)("p",null,"Take for example the following variable definition"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},'const len = "abc".length;\n')),(0,i.mdx)("p",null,"All information necessary to infer the type of ",(0,i.mdx)("inlineCode",{parentName:"p"},"len")," is included in the initializer\n",(0,i.mdx)("inlineCode",{parentName:"p"},'"abc".length'),". Flow will first determine that ",(0,i.mdx)("inlineCode",{parentName:"p"},'"abc"')," is a string, and then that the\n",(0,i.mdx)("inlineCode",{parentName:"p"},"length")," property of a string is a number."),(0,i.mdx)("p",null,"The same logic can be applied for all ",(0,i.mdx)("inlineCode",{parentName:"p"},"const"),"-like initializations. Where things\nget a little more complicated is when variable initialization spans across multiple statements,\nfor example in"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},'declare const maybeString: ?string;\n\nlet len;\nif (typeof maybeString === "string") {\n  len = maybeString.length;\n} else {\n  len = 0;\n}\n')),(0,i.mdx)("p",null,"Flow can still determine that ",(0,i.mdx)("inlineCode",{parentName:"p"},"len")," is a ",(0,i.mdx)("inlineCode",{parentName:"p"},"number"),", but in order to do so it looks\nahead to multiple initializer statements. See section on ",(0,i.mdx)("a",{parentName:"p",href:"../variables"},"variable declarations"),"\nfor details on how various initializer patterns determine the type of a variable,\nand when an annotation on a variable declaration is necessary."),(0,i.mdx)("h2",{id:"function-parameters"},"Function Parameters"),(0,i.mdx)("p",null,'Unlike variable declarations, this kind of "lookahead" reasoning cannot be used to determine\nthe type of function parameters. Consider the function'),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"function getLength(x) {\n  return x.length;\n}\n")),(0,i.mdx)("p",null,"There are many kinds of ",(0,i.mdx)("inlineCode",{parentName:"p"},"x")," on which we could access and return a ",(0,i.mdx)("inlineCode",{parentName:"p"},"length")," property:\nan object with a ",(0,i.mdx)("inlineCode",{parentName:"p"},"length")," property, or a string, just to name a few. If later on in\nthe program we had the following calls to ",(0,i.mdx)("inlineCode",{parentName:"p"},"getLength")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},'getLength("abc");\ngetLength({length: 1});\n')),(0,i.mdx)("p",null,"one possible inference would be that ",(0,i.mdx)("inlineCode",{parentName:"p"},"x")," is a ",(0,i.mdx)("inlineCode",{parentName:"p"},"string | { length: number }"),". What this implies,\nhowever, is that the type of ",(0,i.mdx)("inlineCode",{parentName:"p"},"getLength")," is determined by any part of the current\nprogram. This kind of global reasoning can lead to surprising action-at-a-distance\nbehavior, and so is avoided. Instead, Flow requires that function parameters are annotated. Failure to\nprovide such a type annotation manifests as a ",(0,i.mdx)("inlineCode",{parentName:"p"},"[missing-local-annot]")," error on the parameter ",(0,i.mdx)("inlineCode",{parentName:"p"},"x"),",\nand the body of the function is checked with ",(0,i.mdx)("inlineCode",{parentName:"p"},"x: any"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":20,"endLine":1,"endColumn":20,"description":"Missing an annotation on `x`. [missing-local-annot]"}]','[{"startLine":1,"startColumn":20,"endLine":1,"endColumn":20,"description":"Missing':!0,an:!0,annotation:!0,on:!0,"`x`.":!0,'[missing-local-annot]"}]':!0},"function getLength(x) {\n  return x.length;\n}\n\nconst n = getLength(1); // no error since getLength's parameter type is 'any'\n")),(0,i.mdx)("p",null,"To fix this error, one can simply annotate ",(0,i.mdx)("inlineCode",{parentName:"p"},"x")," as"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function getLength(x: string) {\n  return x.length;\n}\n")),(0,i.mdx)("p",null,"The same requirement holds for class methods"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":25,"endLine":3,"endColumn":25,"description":"Missing an annotation on `x`. [missing-local-annot]"}]','[{"startLine":3,"startColumn":25,"endLine":3,"endColumn":25,"description":"Missing':!0,an:!0,annotation:!0,on:!0,"`x`.":!0,'[missing-local-annot]"}]':!0},"class WrappedString {\n  data: string;\n  setStringNoAnnotation(x) {\n    this.data = x;\n  }\n  setString(x: string) {\n    this.data = x;\n  }\n}\n")),(0,i.mdx)("h2",{id:"toc-contextual-typing"},"Contextual Typing"),(0,i.mdx)("p",null,"Function parameters do not always need to be explicitly annotated. In the case of a\ncallback function to a function call, the parameter type can easily\nbe inferred from the immediate context. Consider for example the following code"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"const arr = [0, 1, 2];\nconst arrPlusOne = arr.find(x => x % 2 === 1);\n")),(0,i.mdx)("p",null,"Flow infers that the type of ",(0,i.mdx)("inlineCode",{parentName:"p"},"arr")," is ",(0,i.mdx)("inlineCode",{parentName:"p"},"Array<number>"),". Combining this with the builtin\ninformation for ",(0,i.mdx)("inlineCode",{parentName:"p"},"Array.find"),", Flow can determine that the type of ",(0,i.mdx)("inlineCode",{parentName:"p"},"x => x % 2 + 1"),"\nneeds to be ",(0,i.mdx)("inlineCode",{parentName:"p"},"number => mixed"),". This type acts as a ",(0,i.mdx)("em",{parentName:"p"},"hint")," for Flow and provides enough\ninformation to determine the type of ",(0,i.mdx)("inlineCode",{parentName:"p"},"x")," as ",(0,i.mdx)("inlineCode",{parentName:"p"},"number"),"."),(0,i.mdx)("p",null,"Any attendant annotation can potentially act as a hint to a function parameter, for example"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"const fn1: (x: number) => number = x => x + 1;\n")),(0,i.mdx)("p",null,"However, it is also possible that an annotation cannot be used as a function\nparameter hint:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":20,"endLine":1,"endColumn":20,"description":"An annotation on `x` is required because Flow cannot infer its type from local context. [missing-local-annot]"}]','[{"startLine":1,"startColumn":20,"endLine":1,"endColumn":20,"description":"An':!0,annotation:!0,on:!0,"`x`":!0,is:!0,required:!0,because:!0,Flow:!0,cannot:!0,infer:!0,its:!0,type:!0,from:!0,local:!0,"context.":!0,'[missing-local-annot]"}]':!0},"const fn2: mixed = x => x + 1;\n")),(0,i.mdx)("p",null,"In this example the ",(0,i.mdx)("inlineCode",{parentName:"p"},"mixed")," type simply does not include enough information to\nextract a candidate type for ",(0,i.mdx)("inlineCode",{parentName:"p"},"x"),"."),(0,i.mdx)("p",null,"Flow can infer the types for unannotated parameters even when they are nested within\nother expressions like objects. For example in\nin"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":48,"endLine":1,"endColumn":48,"description":"Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]"}]','[{"startLine":1,"startColumn":48,"endLine":1,"endColumn":48,"description":"Cannot':!0,cast:!0,"`x`":!0,to:!0,string:!0,because:!0,number:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,"[2].":!0,'[incompatible-cast]"}]':!0},"const fn3: {f: (number) => void} = {f: (x) => {x as string}};\n")),(0,i.mdx)("p",null,"Flow will infer ",(0,i.mdx)("inlineCode",{parentName:"p"},"number")," as the type of ",(0,i.mdx)("inlineCode",{parentName:"p"},"x"),", and so the cast fails."),(0,i.mdx)("h2",{id:"toc-function-return-types"},"Function Return Types"),(0,i.mdx)("p",null,"Unlike function parameters, a function's return type does not need to be annotated in general.\nSo the above definition of ",(0,i.mdx)("inlineCode",{parentName:"p"},"getLength")," won't raise any Flow errors."),(0,i.mdx)("p",null,"There are, however, a couple of notable exceptions to this rule. The first one is\nclass methods. If we included to the ",(0,i.mdx)("inlineCode",{parentName:"p"},"WrappedString")," class a ",(0,i.mdx)("inlineCode",{parentName:"p"},"getString")," method\nthat returns the internal ",(0,i.mdx)("inlineCode",{parentName:"p"},"data")," property:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":3,"startColumn":23,"endLine":3,"endColumn":22,"description":"Missing an annotation on return. [missing-local-annot]"}]','[{"startLine":3,"startColumn":23,"endLine":3,"endColumn":22,"description":"Missing':!0,an:!0,annotation:!0,on:!0,"return.":!0,'[missing-local-annot]"}]':!0},"class WrappedString {\n  data: string;\n  getString(x: string) {\n    return this.data;\n  }\n}\n")),(0,i.mdx)("p",null,"Flow would complain that ",(0,i.mdx)("inlineCode",{parentName:"p"},"getString")," is missing an annotation on the return."),(0,i.mdx)("p",null,"The second exception is recursive definitions. A trivial example of this would be"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":1,"endLine":1,"endColumn":14,"description":"The following definitions recursively depend on each other, and Flow cannot compute their types:\\n - function [1] depends on other definition [2]\\n - function [3] depends on other definition [4]\\nPlease add type annotations to these definitions [5] [6] [definition-cycle]"}]','[{"startLine":1,"startColumn":1,"endLine":1,"endColumn":14,"description":"The':!0,following:!0,definitions:!0,recursively:!0,depend:!0,on:!0,each:!0,"other,":!0,and:!0,Flow:!0,cannot:!0,compute:!0,their:!0,"types:\\n":!0,"-":!0,function:!0,"[1]":!0,depends:!0,other:!0,definition:!0,"[2]\\n":!0,"[3]":!0,"[4]\\nPlease":!0,add:!0,type:!0,annotations:!0,to:!0,these:!0,"[5]":!0,"[6]":!0,'[definition-cycle]"}]':!0},"function foo() {\n  return bar();\n}\n\nfunction bar() {\n  return foo();\n}\n")),(0,i.mdx)("p",null,"The above code raises a ",(0,i.mdx)("inlineCode",{parentName:"p"},"[definition-cycle]")," error, which points to the two locations\nthat form a dependency cycle, the two missing return annotations. Adding\na return annotation to either function would resolve the issue."),(0,i.mdx)("p",null,"Effectively, the requirement on an annotation for method returns is a special-case\nof the recursive definition restriction. The recursion is possible through access on\n",(0,i.mdx)("inlineCode",{parentName:"p"},"this"),"."),(0,i.mdx)("h2",{id:"toc-generic-calls"},"Generic Calls"),(0,i.mdx)("p",null,"In calls to ",(0,i.mdx)("a",{parentName:"p",href:"../../types/generics"},"generic functions")," the type of the result may\ndepend on the types of the values passed in as arguments.\nThis section discusses how this result is computed, when type arguments are not\nexplicitly provided."),(0,i.mdx)("p",null,"Consider for example the definition"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"declare function map<T, U>(\n  f: (T) => U,\n  array: $ReadOnlyArray<T>,\n): Array<U>;\n")),(0,i.mdx)("p",null,"and a potential call with arguments ",(0,i.mdx)("inlineCode",{parentName:"p"},"x => x + 1")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"[1, 2, 3]"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"map(x => x + 1, [1, 2, 3]);\n")),(0,i.mdx)("p",null,"Here Flow infers that the type of ",(0,i.mdx)("inlineCode",{parentName:"p"},"x")," is ",(0,i.mdx)("inlineCode",{parentName:"p"},"number"),"."),(0,i.mdx)("p",null,"Some other common examples of generic calls are calling the constructor of the generic\n",(0,i.mdx)("a",{parentName:"p",href:"https://github.com/facebook/flow/blob/82f88520f2bfe0fa13748b5ead711432941f4cb9/lib/core.js#L1799-L1801"},(0,i.mdx)("inlineCode",{parentName:"a"},"Set")," class"),"\nor calling ",(0,i.mdx)("inlineCode",{parentName:"p"},"useState")," from the React library:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":4,"startColumn":23,"endLine":4,"endColumn":34,"description":"Cannot call hook [1] because React hooks can only be called within components or hooks. [react-rule-hook]"}]','[{"startLine":4,"startColumn":23,"endLine":4,"endColumn":34,"description":"Cannot':!0,call:!0,hook:!0,"[1]":!0,because:!0,React:!0,hooks:!0,can:!0,only:!0,be:!0,called:!0,within:!0,components:!0,or:!0,"hooks.":!0,'[react-rule-hook]"}]':!0},"const set = new Set([1, 2, 3]);\n\nimport {useState} from 'react';\nconst [num, setNum] = useState(42);\n")),(0,i.mdx)("p",null,"Flow here infers that the type of ",(0,i.mdx)("inlineCode",{parentName:"p"},"set")," is ",(0,i.mdx)("inlineCode",{parentName:"p"},"Set<number>"),", and that ",(0,i.mdx)("inlineCode",{parentName:"p"},"num")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"setNum"),"\nare ",(0,i.mdx)("inlineCode",{parentName:"p"},"number")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"(number) => void"),", respectively."),(0,i.mdx)("h3",{id:"computing-a-solution"},"Computing a Solution"),(0,i.mdx)("p",null,"Computing the result of a generic call amounts to:"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"coming up with a solution for ",(0,i.mdx)("inlineCode",{parentName:"li"},"T")," and ",(0,i.mdx)("inlineCode",{parentName:"li"},"U")," that does not contain generic parts,"),(0,i.mdx)("li",{parentName:"ol"},"replacing ",(0,i.mdx)("inlineCode",{parentName:"li"},"T")," and ",(0,i.mdx)("inlineCode",{parentName:"li"},"U")," with the solution in the signature of ",(0,i.mdx)("inlineCode",{parentName:"li"},"map"),", and"),(0,i.mdx)("li",{parentName:"ol"},"performing a call to this new signature of ",(0,i.mdx)("inlineCode",{parentName:"li"},"map"),".")),(0,i.mdx)("p",null,"This process is designed with two goals in mind:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("em",{parentName:"li"},"Soundness"),". The results need to lead to a correct call when we reach step (3)."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("em",{parentName:"li"},"Completeness"),". The types Flow produces need to be as precise and informative as possible,\nto ensure that other parts of the program will be successfully checked.")),(0,i.mdx)("p",null,"Let's see how these two goals come into play in the ",(0,i.mdx)("inlineCode",{parentName:"p"},"map")," example from above."),(0,i.mdx)("p",null,"Flow detects that ",(0,i.mdx)("inlineCode",{parentName:"p"},"$ReadOnlyArray<T>")," needs to be compatible with the type of ",(0,i.mdx)("inlineCode",{parentName:"p"},"[1, 2, 3]"),".\nIt can therefore infer that ",(0,i.mdx)("inlineCode",{parentName:"p"},"T")," is ",(0,i.mdx)("inlineCode",{parentName:"p"},"number"),"."),(0,i.mdx)("p",null,"With the knowledge of ",(0,i.mdx)("inlineCode",{parentName:"p"},"T")," it can now successfully check ",(0,i.mdx)("inlineCode",{parentName:"p"},"x => x + 1"),". The parameter ",(0,i.mdx)("inlineCode",{parentName:"p"},"x"),"\nis contextually typed as ",(0,i.mdx)("inlineCode",{parentName:"p"},"number"),", and thus the result ",(0,i.mdx)("inlineCode",{parentName:"p"},"x + 1")," is also a number.\nThis final constraint allows us to compute ",(0,i.mdx)("inlineCode",{parentName:"p"},"U")," as a ",(0,i.mdx)("inlineCode",{parentName:"p"},"number")," too."),(0,i.mdx)("p",null,"The new signature of ",(0,i.mdx)("inlineCode",{parentName:"p"},"map")," after replacing the generic parts with the above solution\nis"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"(f: (number) => number, array: $ReadOnlyArray<number>) => Array<number>\n")),(0,i.mdx)("p",null,"It is easy to see that the call would be successfully checked."),(0,i.mdx)("h3",{id:"errors-during-polymorphic-calls"},"Errors during Polymorphic Calls"),(0,i.mdx)("p",null,"If the above process goes on smoothly, you should not be seeing any errors associated with the call.\nWhat happens though when this process fails?"),(0,i.mdx)("p",null,"There are two reasons why this process could fail:"),(0,i.mdx)("h4",{id:"under-constrained-type-parameters"},"Under-constrained Type Parameters"),(0,i.mdx)("p",null,"There are cases where Flow might not have enough information to decide the type of a type parameter.\nLet's examine again a call to the builtin generic\n",(0,i.mdx)("a",{parentName:"p",href:"https://github.com/facebook/flow/blob/82f88520f2bfe0fa13748b5ead711432941f4cb9/lib/core.js#L1799-L1801"},(0,i.mdx)("inlineCode",{parentName:"a"},"Set")," class"),"\nconstructor, this time without passing any arguments:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":1,"startColumn":17,"endLine":1,"endColumn":19,"description":"Cannot call `Set` because `T` [1] is underconstrained by new `Set` [2]. Either add explicit type arguments or cast the expression to your expected type. [underconstrained-implicit-instantiation]"}]','[{"startLine":1,"startColumn":17,"endLine":1,"endColumn":19,"description":"Cannot':!0,call:!0,"`Set`":!0,because:!0,"`T`":!0,"[1]":!0,is:!0,underconstrained:!0,by:!0,new:!0,"[2].":!0,Either:!0,add:!0,explicit:!0,type:!0,arguments:!0,or:!0,cast:!0,the:!0,expression:!0,to:!0,your:!0,expected:!0,"type.":!0,'[underconstrained-implicit-instantiation]"}]':!0},'const set = new Set();\nset.add("abc");\n')),(0,i.mdx)("p",null,"During the call to ",(0,i.mdx)("inlineCode",{parentName:"p"},"new Set"),", we are not providing enough information for Flow to\ndetermine the type for ",(0,i.mdx)("inlineCode",{parentName:"p"},"T"),", even though the subsequent call to ",(0,i.mdx)("inlineCode",{parentName:"p"},"set.add")," clearly\nimplies that ",(0,i.mdx)("inlineCode",{parentName:"p"},"T")," will be a string. Remember that inference of type arguments is\nlocal to the call, so Flow will not attempt to look ahead in later statements\nto determine this."),(0,i.mdx)("p",null,"In the absence of information, Flow would be at liberty to infer ",(0,i.mdx)("em",{parentName:"p"},"any")," type\nas ",(0,i.mdx)("inlineCode",{parentName:"p"},"T"),": ",(0,i.mdx)("inlineCode",{parentName:"p"},"any"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"mixed"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"empty"),", etc.\nThis kind of decision is undesirable, as it can lead to surprising results.\nFor example, if we silently decided on ",(0,i.mdx)("inlineCode",{parentName:"p"},"Set<empty>")," then the call to ",(0,i.mdx)("inlineCode",{parentName:"p"},'set.add("abc")')," would\nfail with an incompatibility between ",(0,i.mdx)("inlineCode",{parentName:"p"},"string")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"empty"),", without a clear indication\nof where the ",(0,i.mdx)("inlineCode",{parentName:"p"},"empty")," came from."),(0,i.mdx)("p",null,"So instead, in situations like this, you'll get an ",(0,i.mdx)("inlineCode",{parentName:"p"},"[underconstrained-implicit-instantiation]")," error.\nThe way to fix this error is by adding a type annotation. There a few potential ways to do this:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"Add an annotation at the call-site in one of two ways:"),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"an explicit type argument",(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"const set = new Set<string>();\n"))),(0,i.mdx)("li",{parentName:"ul"},"an annotation on the initialization variable:",(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"const set: Set<string> = new Set();\n"))))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"Add a default type on the type parameter ",(0,i.mdx)("inlineCode",{parentName:"p"},"T")," at the definition of the class:"),(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"declare class SetWithDefault<T = string> extends $ReadOnlySet<T> {\n  constructor(iterable?: ?Iterable<T>): void;\n  // more methods ...\n}\n")),(0,i.mdx)("p",{parentName:"li"},"In the absence of any type information at the call-site, Flow will use the default\ntype of ",(0,i.mdx)("inlineCode",{parentName:"p"},"T")," as the inferred type argument:"),(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"const defaultSet = new SetWithDefault(); // defaultSet is SetWithDefault<string>\n")))),(0,i.mdx)("h4",{id:"incompatibility-errors"},"Incompatibility Errors"),(0,i.mdx)("p",null,"Even when Flow manages to infer non-generic types for the type parameters in a generic\ncall, these types might still lead to incompatibilities either in the current call or in\ncode later on."),(0,i.mdx)("p",null,"For example, if we had the following call to ",(0,i.mdx)("inlineCode",{parentName:"p"},"map"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":2,"startColumn":10,"endLine":2,"endColumn":14,"description":"Cannot use operator `+` with operands object literal [1] and number [2] [unsafe-addition]"}]','[{"startLine":2,"startColumn":10,"endLine":2,"endColumn":14,"description":"Cannot':!0,use:!0,operator:!0,"`+`":!0,with:!0,operands:!0,object:!0,literal:!0,"[1]":!0,and:!0,number:!0,"[2]":!0,'[unsafe-addition]"}]':!0},"declare function map<T, U>(f: (T) => U, array: $ReadOnlyArray<T>): Array<U>;\nmap(x => x + 1, [{}]);\n")),(0,i.mdx)("p",null,"Flow will infer ",(0,i.mdx)("inlineCode",{parentName:"p"},"T")," as ",(0,i.mdx)("inlineCode",{parentName:"p"},"{}"),", and therefore type ",(0,i.mdx)("inlineCode",{parentName:"p"},"x")," as ",(0,i.mdx)("inlineCode",{parentName:"p"},"{}"),". This will cause an error when checking the arrow function\nsince the ",(0,i.mdx)("inlineCode",{parentName:"p"},"+")," operation is not allowed on objects."),(0,i.mdx)("p",null,"Finally, a common source of errors is the case where the inferred type in a generic\ncall is correct for the call itself, but not indicative of the expected use later in the code.\nFor example, consider"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":2,"startColumn":23,"endLine":2,"endColumn":34,"description":"Cannot call hook [1] because React hooks can only be called within components or hooks. [react-rule-hook]"},{"startLine":5,"startColumn":8,"endLine":5,"endColumn":18,"description":"Cannot call `setStr` with `maybeString` bound to the first parameter because: [incompatible-call] Either null or undefined [1] is incompatible with function type [2]. Or null or undefined [1] is incompatible with string [3]."}]','[{"startLine":2,"startColumn":23,"endLine":2,"endColumn":34,"description":"Cannot':!0,call:!0,hook:!0,"[1]":!0,because:!0,React:!0,hooks:!0,can:!0,only:!0,be:!0,called:!0,within:!0,components:!0,or:!0,"hooks.":!0,'[react-rule-hook]"},{"startLine":5,"startColumn":8,"endLine":5,"endColumn":18,"description":"Cannot':!0,"`setStr`":!0,with:!0,"`maybeString`":!0,bound:!0,to:!0,the:!0,first:!0,parameter:!0,"because:":!0,"[incompatible-call]":!0,Either:!0,null:!0,undefined:!0,is:!0,incompatible:!0,function:!0,type:!0,"[2].":!0,Or:!0,string:!0,'[3]."}]':!0},"import {useState} from 'react';\nconst [str, setStr] = useState(\"\");\n\ndeclare const maybeString: ?string;\nsetStr(maybeString);\n")),(0,i.mdx)("p",null,"Passing the string ",(0,i.mdx)("inlineCode",{parentName:"p"},'""')," to the call to ",(0,i.mdx)("inlineCode",{parentName:"p"},"useState")," makes Flow infer ",(0,i.mdx)("inlineCode",{parentName:"p"},"string")," as the type\nof the state. So ",(0,i.mdx)("inlineCode",{parentName:"p"},"setStr")," will also expect a ",(0,i.mdx)("inlineCode",{parentName:"p"},"string")," as input when called later on,\nand therefore passing a ",(0,i.mdx)("inlineCode",{parentName:"p"},"?string")," will be an error."),(0,i.mdx)("p",null,'Again, to fix this error it suffices to annotate the expected "wider" type of state\nwhen calling ',(0,i.mdx)("inlineCode",{parentName:"p"},"useState"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},'const [str, setStr] = useState<?string>("");\n')),(0,i.mdx)("h2",{id:"toc-empty-array-literals"},"Empty Array Literals"),(0,i.mdx)("p",null,"Empty array literals (",(0,i.mdx)("inlineCode",{parentName:"p"},"[]"),") are handled specially in Flow. You can read about their ",(0,i.mdx)("a",{parentName:"p",href:"../../types/arrays/#toc-empty-array-literals"},"behavior and requirements"),"."))}p.isMDXComponent=!0}}]);