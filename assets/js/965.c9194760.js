"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[965],{90965:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var o=n(58168),a=(n(96540),n(15680));n(60681);const r={title:"File Signatures (Types-First)",slug:"/lang/types-first"},i=void 0,s={unversionedId:"lang/types-first",id:"lang/types-first",title:"File Signatures (Types-First)",description:"Flow checks codebases by processing each file separately in dependency",source:"@site/docs/lang/types-first.md",sourceDirName:"lang",slug:"/lang/types-first",permalink:"/en/docs/lang/types-first",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/lang/types-first.md",tags:[],version:"current",frontMatter:{title:"File Signatures (Types-First)",slug:"/lang/types-first"},sidebar:"docsSidebar",previous:{title:"Lazy Mode",permalink:"/en/docs/lang/lazy-modes"},next:{title:"Annotation Requirement",permalink:"/en/docs/lang/annotation-requirement"}},l={},d=[{value:"How to upgrade your codebase to Types-First",id:"toc-how-to-upgrade-your-codebase-to-types-first",level:2},{value:"Upgrade Flow version",id:"toc-upgrade-flow-version",level:3},{value:"Prepare your codebase for Types-First",id:"toc-prepare-your-codebase-for-types-first",level:3},{value:"Seal your intermediate results",id:"toc-seal-your-intermediate-results",level:4},{value:"A codemod for large codebases",id:"toc-a-codemod-for-large-codebases",level:4},{value:"Enable the types-first flag",id:"toc-enable-the-types-first-flag",level:3},{value:"Deal with newly introduced errors",id:"toc-deal-with-newly-introduced-errors",level:3},{value:"Array tuples treated as regular arrays in exports",id:"toc-array-tuples-treated-as-regular-arrays-in-exports",level:4},{value:"Indirect object assignments in exports",id:"toc-indirect-object-assignments-in-exports",level:4},{value:"Exported variables with updates",id:"toc-exported-variables-with-updates",level:3}],p={toc:d};function m(e){let{components:t,...n}=e;return(0,a.mdx)("wrapper",(0,o.A)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"Flow checks codebases by processing each file separately in dependency\norder. For every file containing important typing information for the checking\nprocess, a signature needs to be extracted and stored in\nmain memory, to be used for files that depend on it. Flow relies on annotations\navailable at the boundaries of files to build these signatures. We call this\nrequirement of Flow's architecture ",(0,a.mdx)("em",{parentName:"p"},"Types-First"),"."),(0,a.mdx)("p",null,"The benefit of this architecture is dual:"),(0,a.mdx)("ol",null,(0,a.mdx)("li",{parentName:"ol"},(0,a.mdx)("p",{parentName:"li"},"It dramatically improves ",(0,a.mdx)("em",{parentName:"p"},"performance"),", in particular when it comes to\nrechecks. Suppose we want Flow to check a file ",(0,a.mdx)("inlineCode",{parentName:"p"},"foo.js"),", for which it hasn't\nchecked its dependencies yet. Flow extracts the dependency signatures just by\nlooking at the annotations around the exports. This process is mostly\nsyntactic, and therefore much faster than full type inference that legacy versions\nof Flow (prior to v0.125) used to perform in order to generate signatures.")),(0,a.mdx)("li",{parentName:"ol"},(0,a.mdx)("p",{parentName:"li"},"It improves error ",(0,a.mdx)("em",{parentName:"p"},"reliability"),". Inferred types often become complicated, and may\nlead to errors being reported in downstream files, far away from their actual source.\nType annotations at file boundaries of files can help localize such errors, and\naddress them in the file that introduced them."))),(0,a.mdx)("p",null,"The trade-off for this performance benefit is that exported parts of the code need to be\nannotated with types, or to be expressions whose type can be trivially inferred\n(for example numbers and strings)."),(0,a.mdx)("p",null,"More information on the Types-First architecture can be found in ",(0,a.mdx)("a",{parentName:"p",href:"https://medium.com/flow-type/types-first-a-scalable-new-architecture-for-flow-3d8c7ba1d4eb"},"this post"),"."),(0,a.mdx)("h2",{id:"toc-how-to-upgrade-your-codebase-to-types-first"},"How to upgrade your codebase to Types-First"),(0,a.mdx)("blockquote",null,(0,a.mdx)("p",{parentName:"blockquote"},"Note: Types-first has been the default mode since v0.134 and the only available\nmode since v0.143. No ",(0,a.mdx)("inlineCode",{parentName:"p"},".flowconfig")," options are necessary to enable it since then.\nIn case you're upgrading your codebase from a much earlier version here are some\nuseful tools.")),(0,a.mdx)("h3",{id:"toc-upgrade-flow-version"},"Upgrade Flow version"),(0,a.mdx)("p",null,"Types-first mode was officially released with version 0.125, but has been available in\n",(0,a.mdx)("em",{parentName:"p"},"experimental")," status as of version 0.102. If you are currently on an older\nFlow version, you\u2019d have to first upgrade Flow. Using the latest Flow version\nis the best way to benefit from the performance benefits outlined above."),(0,a.mdx)("h3",{id:"toc-prepare-your-codebase-for-types-first"},"Prepare your codebase for Types-First"),(0,a.mdx)("p",null,"Types-first requires annotations at module boundaries in order to build type\nsignature for files. If these annotations are missing, then a ",(0,a.mdx)("inlineCode",{parentName:"p"},"signature-verification-failure"),"\nis raised, and the exported type for the respective part of the code will be ",(0,a.mdx)("inlineCode",{parentName:"p"},"any"),"."),(0,a.mdx)("p",null,"To see what types are missing to make your codebase types-first ready, add the\nfollowing line to the ",(0,a.mdx)("inlineCode",{parentName:"p"},"[options]")," section of the ",(0,a.mdx)("inlineCode",{parentName:"p"},".flowconfig")," file:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"well_formed_exports=true\n")),(0,a.mdx)("p",null,"Consider for example a file ",(0,a.mdx)("inlineCode",{parentName:"p"},"foo.js")," that exports a function call to ",(0,a.mdx)("inlineCode",{parentName:"p"},"foo")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"declare function foo<T>(x: T): T;\nmodule.exports = foo(1);\n")),(0,a.mdx)("p",null,"The return type of function calls is currently not trivially inferable (due to\nfeatures like polymorphism, overloading etc.). Their result needs to be annotated\nand so you\u2019d see the following error:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"Cannot build a typed interface for this module. You should annotate the exports\nof this module with types. Cannot determine the type of this call expression. Please\nprovide an annotation, e.g., by adding a type cast around this expression.\n(`signature-verification-failure`)\n\n   4\u2502 module.exports = foo(1);\n                       ^^^^^^\n")),(0,a.mdx)("p",null,"To resolve this, you can add an annotation like the following:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"declare function foo<T>(x: T): T;\nmodule.exports = foo(1) as number;\n")),(0,a.mdx)("blockquote",null,(0,a.mdx)("p",{parentName:"blockquote"},"Note: As of version 0.134, types-first is the default mode. This mode automatically\nenables ",(0,a.mdx)("inlineCode",{parentName:"p"},"well_formed_exports"),", so you would see these errors without explicitly\nsetting this flag. It is advisable to set ",(0,a.mdx)("inlineCode",{parentName:"p"},"types_first=false")," during this part of\nthe upgrade.")),(0,a.mdx)("h4",{id:"toc-seal-your-intermediate-results"},"Seal your intermediate results"),(0,a.mdx)("p",null,"As you make progress adding types to your codebase, you can include directories\nso that they don\u2019t regress as new code gets committed, and until the entire project\nhas well-formed exports. You can do this by adding lines like the following to your\n.flowconfig:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"well_formed_exports.includes=<PROJECT_ROOT>/path/to/directory\n")),(0,a.mdx)("blockquote",null,(0,a.mdx)("p",{parentName:"blockquote"},"Warning: That this is a ",(0,a.mdx)("em",{parentName:"p"},"substring")," check, not a regular expression (for performance\nreasons).")),(0,a.mdx)("h4",{id:"toc-a-codemod-for-large-codebases"},"A codemod for large codebases"),(0,a.mdx)("p",null,"Adding the necessary annotations to large codebases can be quite tedious. To ease\nthis burden, we are providing a codemod based on Flow's inference, that can be\nused to annotate multiple files in bulk. See ",(0,a.mdx)("a",{parentName:"p",href:"../../cli/annotate-exports/"},"this tutorial")," for more."),(0,a.mdx)("h3",{id:"toc-enable-the-types-first-flag"},"Enable the types-first flag"),(0,a.mdx)("p",null,"Once you have eliminated signature verification errors, you can turn on the types-first\nmode, by adding the following line to the ",(0,a.mdx)("inlineCode",{parentName:"p"},"[options]")," section of the ",(0,a.mdx)("inlineCode",{parentName:"p"},".flowconfig")," file:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"types_first=true\n")),(0,a.mdx)("p",null,"You can also pass ",(0,a.mdx)("inlineCode",{parentName:"p"},"--types-first")," to the ",(0,a.mdx)("inlineCode",{parentName:"p"},"flow check")," or ",(0,a.mdx)("inlineCode",{parentName:"p"},"flow start")," commands."),(0,a.mdx)("p",null,"The ",(0,a.mdx)("inlineCode",{parentName:"p"},"well_formed_exports")," flag from before is implied by ",(0,a.mdx)("inlineCode",{parentName:"p"},"types_first"),". Once\nthis process is completed and types-first has been enabled, you can remove\n",(0,a.mdx)("inlineCode",{parentName:"p"},"well_formed_exports"),"."),(0,a.mdx)("p",null,"Unfortunately, it is not possible to enable types-first mode for part of your repo; this switch\naffects all files managed by the current ",(0,a.mdx)("inlineCode",{parentName:"p"},".flowconfig"),"."),(0,a.mdx)("blockquote",null,(0,a.mdx)("p",{parentName:"blockquote"},"Note: The above flags are available in versions of Flow ",(0,a.mdx)("inlineCode",{parentName:"p"},">=0.102")," with the ",(0,a.mdx)("inlineCode",{parentName:"p"},"experimental."),"\nprefix (and prior to v0.128, it used ",(0,a.mdx)("inlineCode",{parentName:"p"},"whitelist")," in place of ",(0,a.mdx)("inlineCode",{parentName:"p"},"includes"),"):"),(0,a.mdx)("pre",{parentName:"blockquote"},(0,a.mdx)("code",{parentName:"pre"},"experimental.well_formed_exports=true\nexperimental.well_formed_exports.whitelist=<PROJECT_ROOT>/path/to/directory\nexperimental.types_first=true\n"))),(0,a.mdx)("blockquote",null,(0,a.mdx)("p",{parentName:"blockquote"},"Note: If you are using a version where types-first is enabled by default (ie. ",(0,a.mdx)("inlineCode",{parentName:"p"},">=0.134"),"),\nmake sure you set ",(0,a.mdx)("inlineCode",{parentName:"p"},"types_first=false")," in your .flowconfig while running the codemods.")),(0,a.mdx)("h3",{id:"toc-deal-with-newly-introduced-errors"},"Deal with newly introduced errors"),(0,a.mdx)("p",null,"Switching between classic and types-first mode may cause some new Flow errors,\nbesides signature-verification failures that we mentioned earlier. These errors\nare due differences in the way types based on annotations are interpreted, compared\nto their respective inferred types."),(0,a.mdx)("p",null,"Below are some common error patterns and how to overcome them."),(0,a.mdx)("h4",{id:"toc-array-tuples-treated-as-regular-arrays-in-exports"},"Array tuples treated as regular arrays in exports"),(0,a.mdx)("p",null,"In types-first, an array literal in an ",(0,a.mdx)("em",{parentName:"p"},"export position")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"module.exports = [e1, e2];\n")),(0,a.mdx)("p",null,"is treated as having type ",(0,a.mdx)("inlineCode",{parentName:"p"},"Array<t1 | t2>"),", where ",(0,a.mdx)("inlineCode",{parentName:"p"},"e1")," and ",(0,a.mdx)("inlineCode",{parentName:"p"},"e2")," have types ",(0,a.mdx)("inlineCode",{parentName:"p"},"t1"),"\nand ",(0,a.mdx)("inlineCode",{parentName:"p"},"t2"),", instead of the tuple type ",(0,a.mdx)("inlineCode",{parentName:"p"},"[t1, t2]"),"."),(0,a.mdx)("p",null,"In classic mode, the inferred type encompassed both types at the same time. This\nmight cause errors in importing files that expect for example to find type ",(0,a.mdx)("inlineCode",{parentName:"p"},"t1"),"\nin the first position of the import."),(0,a.mdx)("p",null,(0,a.mdx)("strong",{parentName:"p"},"Fix:")," If a tuple type is expected, then the annotation ",(0,a.mdx)("inlineCode",{parentName:"p"},"[t1, t2]")," needs to be\nexplicitly added on the export side."),(0,a.mdx)("h4",{id:"toc-indirect-object-assignments-in-exports"},"Indirect object assignments in exports"),(0,a.mdx)("p",null,"Flow allows the code"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"function foo(): void {}\nfoo.x = () => {};\nfoo.x.y = 2;\nmodule.exports = foo;\n")),(0,a.mdx)("p",null,"but in types-first the exported type will be"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-plaintext"},"{\n  (): void;\n  x: () => void;\n}\n")),(0,a.mdx)("p",null,"In other words it won\u2019t take into account the update on ",(0,a.mdx)("inlineCode",{parentName:"p"},"y"),"."),(0,a.mdx)("p",null,(0,a.mdx)("strong",{parentName:"p"},"Fix:")," To include the update on ",(0,a.mdx)("inlineCode",{parentName:"p"},"y")," in the exported type, the export will need\nto be annotated with the type"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-plaintext"},"{\n  (): void;\n  x: { (): void; y: number; };\n};\n")),(0,a.mdx)("p",null,"The same holds for more complex assignment patterns like"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"function foo(): void {}\nObject.assign(foo, { x: 1});\nmodule.exports = foo;\n")),(0,a.mdx)("p",null,"where you\u2019ll need to manually annotate the export with ",(0,a.mdx)("inlineCode",{parentName:"p"},"{ (): void; x: number }"),",\nor assignments preceding the function definition"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"foo.x = 1;\nfunction foo(): void {}\nmodule.exports = foo;\n")),(0,a.mdx)("p",null,"Note that in the last example, Flow types-first will pick up the static update if\nit was after the definition:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"function foo(): void {}\nfoo.x = 1;\nmodule.exports = foo;\n")),(0,a.mdx)("h3",{id:"toc-exported-variables-with-updates"},"Exported variables with updates"),(0,a.mdx)("p",null,"The types-first signature extractor will not pick up subsequent update of an exported\nlet-bound variables. Consider the example"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},'let foo: number | string = 1;\nfoo = "blah";\nmodule.exports = foo;\n')),(0,a.mdx)("p",null,"In classic mode the exported type would be ",(0,a.mdx)("inlineCode",{parentName:"p"},"string"),". In types-first it will be\n",(0,a.mdx)("inlineCode",{parentName:"p"},"number | string"),", so if downstream typing depends on the more precise type, then\nyou might get some errors."),(0,a.mdx)("p",null,(0,a.mdx)("strong",{parentName:"p"},"Fix:")," Introduce a new variable on the update and export that one. For example"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},'const foo1: number | string = 1;\nconst foo2 = "blah";\nmodule.exports = foo2;\n')))}m.isMDXComponent=!0}}]);