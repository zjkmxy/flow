"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[6041],{36041:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>p,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>s});var a=t(58168),r=(t(96540),t(15680));const i={title:"Property Variance and Other Upcoming Changes","short-title":"Property Variance",author:"Sam Goldman",hide_table_of_contents:!0},p=void 0,o={permalink:"/blog/2016/10/04/Property-Variance",source:"@site/blog/2016-10-04-Property-Variance.md",title:"Property Variance and Other Upcoming Changes",description:"The next release of Flow, 0.34, will include a few important changes to object",date:"2016-10-04T00:00:00.000Z",formattedDate:"October 4, 2016",tags:[],hasTruncateMarker:!0,authors:[{name:"Sam Goldman"}],frontMatter:{title:"Property Variance and Other Upcoming Changes","short-title":"Property Variance",author:"Sam Goldman",hide_table_of_contents:!0},prevItem:{title:"Introducing Flow-Typed",permalink:"/blog/2016/10/13/Flow-Typed"},nextItem:{title:"Windows Support is Here!",permalink:"/blog/2016/08/01/Windows-Support"}},l={authorsImageUrls:[void 0]},s=[{value:"What is Variance?",id:"what-is-variance",level:3},{value:"Input and Output",id:"input-and-output",level:4},{value:"Property Invariance",id:"property-invariance",level:2},{value:"Property Variance",id:"property-variance",level:3},{value:"Invariant-by-default Dictionary Types",id:"invariant-by-default-dictionary-types",level:3},{value:"Covariant-by-default Method Types",id:"covariant-by-default-method-types",level:3},{value:"More Flexible Getters and Setters",id:"more-flexible-getters-and-setters",level:3}],d={toc:s};function m(e){let{components:n,...t}=e;return(0,r.mdx)("wrapper",(0,a.A)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"The next release of Flow, 0.34, will include a few important changes to object\ntypes:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"property variance,"),(0,r.mdx)("li",{parentName:"ul"},"invariant-by-default dictionary types,"),(0,r.mdx)("li",{parentName:"ul"},"covariant-by-default method types,"),(0,r.mdx)("li",{parentName:"ul"},"and more flexible getters and setters.")),(0,r.mdx)("h3",{id:"what-is-variance"},"What is Variance?"),(0,r.mdx)("p",null,"Defining the subtype relationship between types is a core responsibility of Flow\nas a type system. These relationships are determined either directly for\nsimple types or, for complex types, defined in terms of their parts."),(0,r.mdx)("p",null,"Variance describes the subtyping relationship for complex types as it relates\nto the subtyping relationships of their parts."),(0,r.mdx)("p",null,"For example, Flow directly encodes the knowledge that ",(0,r.mdx)("inlineCode",{parentName:"p"},"string")," is a subtype of\n",(0,r.mdx)("inlineCode",{parentName:"p"},"?string"),". Intuitively, a ",(0,r.mdx)("inlineCode",{parentName:"p"},"string")," type contains string values while a ",(0,r.mdx)("inlineCode",{parentName:"p"},"?string"),"\ntype contains ",(0,r.mdx)("inlineCode",{parentName:"p"},"null"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"undefined"),", and also string values, so membership in the\nformer naturally implies membership in the later."),(0,r.mdx)("p",null,"The subtype relationships between two function types is not as direct. Rather,\nit is derived from the subtype relationships between the functions' parameter\nand return types."),(0,r.mdx)("p",null,"Let's see how this works for two simple function types:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"type F1 = (x: P1) => R1;\ntype F2 = (x: P2) => R2;\n")),(0,r.mdx)("p",null,"Whether ",(0,r.mdx)("inlineCode",{parentName:"p"},"F2")," is a subtype of ",(0,r.mdx)("inlineCode",{parentName:"p"},"F1")," depends on the relationships between ",(0,r.mdx)("inlineCode",{parentName:"p"},"P1")," and\n",(0,r.mdx)("inlineCode",{parentName:"p"},"P2")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"R1")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"R2"),". Let's use the notation ",(0,r.mdx)("inlineCode",{parentName:"p"},"B <: A")," to mean ",(0,r.mdx)("inlineCode",{parentName:"p"},"B")," is a\nsubtype of ",(0,r.mdx)("inlineCode",{parentName:"p"},"A"),"."),(0,r.mdx)("p",null,"It turns out that ",(0,r.mdx)("inlineCode",{parentName:"p"},"F2 <: F1")," if ",(0,r.mdx)("inlineCode",{parentName:"p"},"P1 <: P2")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"R2 <: R1"),'. Notice that the\nrelationship for parameters is reversed? In technical terms, we can say that\nfunction types are "contravariant" with respect to their parameter types and\n"covariant" with respect to their return types.'),(0,r.mdx)("p",null,"Let's look at an example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},'function f(callback: (x: string) => ?number): number {\n  return callback("hi") || 0;\n}\n')),(0,r.mdx)("p",null,"What kinds of functions can we pass to ",(0,r.mdx)("inlineCode",{parentName:"p"},"f"),"? Based on the subtyping rule above,\nthen we can pass a function whose parameter type is a supertype of ",(0,r.mdx)("inlineCode",{parentName:"p"},"string")," and\nwhose return type is a subtype of ",(0,r.mdx)("inlineCode",{parentName:"p"},"?number"),"."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"function g(x: ?string): number {\n  return x ? x.length : 0;\n}\nf(g);\n")),(0,r.mdx)("p",null,"The body of ",(0,r.mdx)("inlineCode",{parentName:"p"},"f")," will only ever pass ",(0,r.mdx)("inlineCode",{parentName:"p"},"string")," values into ",(0,r.mdx)("inlineCode",{parentName:"p"},"g"),", which is safe\nbecause ",(0,r.mdx)("inlineCode",{parentName:"p"},"g")," takes at least ",(0,r.mdx)("inlineCode",{parentName:"p"},"string")," by taking ",(0,r.mdx)("inlineCode",{parentName:"p"},"?string"),". Conversely, ",(0,r.mdx)("inlineCode",{parentName:"p"},"g")," will\nonly ever return ",(0,r.mdx)("inlineCode",{parentName:"p"},"number")," values to ",(0,r.mdx)("inlineCode",{parentName:"p"},"f"),", which is safe because ",(0,r.mdx)("inlineCode",{parentName:"p"},"f")," handles at\nleast ",(0,r.mdx)("inlineCode",{parentName:"p"},"number")," by handling ",(0,r.mdx)("inlineCode",{parentName:"p"},"?number"),"."),(0,r.mdx)("h4",{id:"input-and-output"},"Input and Output"),(0,r.mdx)("p",null,'One convenient way to remember when something is covariant vs. contravariant is\nto think about "input" and "output."'),(0,r.mdx)("p",null,"Parameters are in an ",(0,r.mdx)("em",{parentName:"p"},"input"),' position, often called a "negative" position.\nComplex types are contravariant in their input positions.'),(0,r.mdx)("p",null,"Return is an ",(0,r.mdx)("em",{parentName:"p"},"output"),' position, often called a "positive" position. Complex\ntypes are covariant in their output positions.'),(0,r.mdx)("h2",{id:"property-invariance"},"Property Invariance"),(0,r.mdx)("p",null,"Just as function types are composed of parameter and return types, so too are\nobject types composed of property types. Thus, the subtyping relationship\nbetween objects is derived from the subtyping relationships of their\nproperties."),(0,r.mdx)("p",null,"However, unlike functions which have input parameters and an output return,\nobject properties can be read and written. That is, properties are ",(0,r.mdx)("em",{parentName:"p"},"both")," input\nand output."),(0,r.mdx)("p",null,"Let's see how this works for two simple object types:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"type O1 = {p: T1};\ntype O2 = {p: T2};\n")),(0,r.mdx)("p",null,"As with function types, whether ",(0,r.mdx)("inlineCode",{parentName:"p"},"O2")," is a subtype of ",(0,r.mdx)("inlineCode",{parentName:"p"},"O1")," depends on the\nrelationship between its parts, ",(0,r.mdx)("inlineCode",{parentName:"p"},"T1")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"T2"),"."),(0,r.mdx)("p",null,"Here it turns out that ",(0,r.mdx)("inlineCode",{parentName:"p"},"O2 <: O1")," if ",(0,r.mdx)("inlineCode",{parentName:"p"},"T2 <: T1")," ",(0,r.mdx)("em",{parentName:"p"},"and")," ",(0,r.mdx)("inlineCode",{parentName:"p"},"T1 <: T2"),'. In technical\nterms, object types are "invariant" with respect to their property types.'),(0,r.mdx)("p",null,"Let's look at an example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"function f(o: {p: ?string}): void {\n  // We can read p from o\n  let len: number;\n  if (o.p) {\n    len = o.p.length;\n  } else {\n    len = 0;\n  }\n\n  // We can also write into p\n  o.p = null;\n}\n")),(0,r.mdx)("p",null,"What kinds of objects can we pass into ",(0,r.mdx)("inlineCode",{parentName:"p"},"f"),", then? If we try to pass in an\nobject with a subtype property, we get an error:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},'var o1: {p: string} = {p: ""};\nf(o1);\n')),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},'function f(o: {p: ?string}) {}\n                   ^ null. This type is incompatible with\nvar o1: {p: string} = {p: ""};\n            ^ string\nfunction f(o: {p: ?string}) {}\n                   ^ undefined. This type is incompatible with\nvar o1: {p: string} = {p: ""};\n            ^ string\n')),(0,r.mdx)("p",null,"Flow has correctly identified an error here. If the body of ",(0,r.mdx)("inlineCode",{parentName:"p"},"f")," writes ",(0,r.mdx)("inlineCode",{parentName:"p"},"null"),"\ninto ",(0,r.mdx)("inlineCode",{parentName:"p"},"o.p"),", then ",(0,r.mdx)("inlineCode",{parentName:"p"},"o1.p")," would no longer have type ",(0,r.mdx)("inlineCode",{parentName:"p"},"string"),"."),(0,r.mdx)("p",null,"If we try to pass an object with a supertype property, we again get an error:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"var o2: {p: ?(string|number)} = {p: 0};\nf(o2);\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},'var o1: {p: ?(string|number)} = {p: ""};\n                     ^ number. This type is incompatible with\nfunction f(o: {p: ?string}) {}\n                   ^ string\n')),(0,r.mdx)("p",null,"Again, Flow correctly identifies an error, because if ",(0,r.mdx)("inlineCode",{parentName:"p"},"f")," tried to read ",(0,r.mdx)("inlineCode",{parentName:"p"},"p"),"\nfrom ",(0,r.mdx)("inlineCode",{parentName:"p"},"o"),", it would find a number."),(0,r.mdx)("h3",{id:"property-variance"},"Property Variance"),(0,r.mdx)("p",null,"So objects have to be invariant with respect to their property types because\nproperties can be read from and written to. But just because you ",(0,r.mdx)("em",{parentName:"p"},"can")," read and\nwrite, doesn't mean you always do."),(0,r.mdx)("p",null,"Consider a function that gets the length of an nullable string property:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"function f(o: {p: ?string}): number {\n  return o.p ? o.p.length : 0;\n}\n")),(0,r.mdx)("p",null,"We never write into ",(0,r.mdx)("inlineCode",{parentName:"p"},"o.p"),", so we should be able to pass in an object where the\ntype of property ",(0,r.mdx)("inlineCode",{parentName:"p"},"p")," is a subtype of ",(0,r.mdx)("inlineCode",{parentName:"p"},"?string"),". Until now, this wasn't possible\nin Flow."),(0,r.mdx)("p",null,"With property variance, you can explicitly annotate object properties as being\ncovariant and contravariant. For example, we can rewrite the above function:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},'function f(o: {+p: ?string}): number {\n  return o.p ? o.p.length : 0;\n}\n\nvar o: {p: string} = {p: ""};\nf(o); // no type error!\n')),(0,r.mdx)("p",null,"It's crucial that covariant properties only ever appear in output positions. It\nis an error to write to a covariant property:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"function f(o: {+p: ?string}) {\n  o.p = null;\n}\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"o.p = null;\n^ object type. Covariant property `p` incompatible with contravariant use in\no.p = null;\n^ assignment of property `p`\n")),(0,r.mdx)("p",null,"Conversely, if a function only ever writes to a property, we can annotate the\nproperty as contravariant. This might come up in a function that initializes an\nobject with default values, for example."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},'function g(o: {-p: string}): void {\n  o.p = "default";\n}\nvar o: {p: ?string} = {p: null};\ng(o);\n')),(0,r.mdx)("p",null,"Contravariant properties can only ever appear in input positions. It is an\nerror to read from a contravariant property:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"function f(o: {-p: string}) {\n  o.p.length;\n}\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"o.p.length;\n^ object type. Contravariant property `p` incompatible with covariant use in\no.p.length;\n^ property `p`\n")),(0,r.mdx)("h3",{id:"invariant-by-default-dictionary-types"},"Invariant-by-default Dictionary Types"),(0,r.mdx)("p",null,"The object type ",(0,r.mdx)("inlineCode",{parentName:"p"},"{[key: string]: ?number}")," describes an object that can be used\nas a map. We can read any property and Flow will infer the result type as\n",(0,r.mdx)("inlineCode",{parentName:"p"},"?number"),". We can also write ",(0,r.mdx)("inlineCode",{parentName:"p"},"null")," or ",(0,r.mdx)("inlineCode",{parentName:"p"},"undefined")," or ",(0,r.mdx)("inlineCode",{parentName:"p"},"number")," into any\nproperty."),(0,r.mdx)("p",null,"In Flow 0.33 and earlier, these dictionary types were treated covariantly by\nthe type system. For example, Flow accepted the following code:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"function f(o: {[key: string]: ?number}) {\n  o.p = null;\n}\ndeclare var o: {p: number};\nf(o);\n")),(0,r.mdx)("p",null,"This is unsound because ",(0,r.mdx)("inlineCode",{parentName:"p"},"f")," can overwrite property ",(0,r.mdx)("inlineCode",{parentName:"p"},"p")," with ",(0,r.mdx)("inlineCode",{parentName:"p"},"null"),". In Flow\n0.34, dictionaries are invariant, like named properties. The same code now\nresults in the following type error:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"function f(o: {[key: string]: ?number}) {}\n                               ^ null. This type is incompatible with\ndeclare var o: {p: number};\n                   ^ number\nfunction f(o: {[key: string]: ?number}) {}\n                               ^ undefined. This type is incompatible with\ndeclare var o: {p: number};\n                   ^ number\n")),(0,r.mdx)("p",null,"Covariant and contravariant dictionaries can be incredibly useful, though. To\nsupport this, the same syntax used to support variance for named properties can\nbe used for dictionaries as well."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"function f(o: {+[key: string]: ?number}) {}\ndeclare var o: {p: number};\nf(o); // no type error!\n")),(0,r.mdx)("h3",{id:"covariant-by-default-method-types"},"Covariant-by-default Method Types"),(0,r.mdx)("p",null,"ES6 gave us a shorthand way to write object properties which are functions."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"var o = {\n  m(x) {\n    return x * 2\n  }\n}\n")),(0,r.mdx)("p",null,"Flow now interprets properties which use this shorthand method syntax as\ncovariant by default. This means it is an error to write to the property ",(0,r.mdx)("inlineCode",{parentName:"p"},"m"),"."),(0,r.mdx)("p",null,"If you don't want covariance, you can use the long form syntax:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},"var o = {\n  m: function(x) {\n    return x * 2;\n  }\n}\n")),(0,r.mdx)("h3",{id:"more-flexible-getters-and-setters"},"More Flexible Getters and Setters"),(0,r.mdx)("p",null,"In Flow 0.33 and earlier, getters and setters had to agree exactly on their\nreturn type and parameter type, respectively. Flow 0.34 lifts that restriction."),(0,r.mdx)("p",null,"This means you can write code like the following:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-js"},'// @flow\ndeclare var x: string;\n\nvar o = {\n  get x(): string {\n    return x;\n  },\n  set x(value: ?string) {\n    x = value || "default";\n  }\n}\n')))}m.isMDXComponent=!0}}]);